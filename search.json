[{"title":"樊登讲论语：先进","url":"https://lujw666.github.io/2021/03/14/fandeng-001/","content":"思 维 导 图\n\n\n荐 语《论语》是对樊登人生影响最大的一本书，《樊登讲论语》是樊登的心血之作。本书结合了现代的心理学、社会学、管理学、育儿知识、教育学、创业方法、领导力解读《论语》，让你在轻松读透《论语》的同时，把《论语》用起来！ \n\n\n你 将 获 得\n如何管理好自己与团队\n如何建立良性人际关系\n如何在不确定中受益\n如何与世界和谐相处\n\n\n\n作 者 简 介樊登\n樊登读书创始人、首席内容官，曾在中央电视台主持《12演播室》《三星智力快车》等节目。\n著有《樊登讲论语：学而》《樊登讲论语：先进》《陪孩子终身成长》《可复制的领导力》《低风险创业》《读书是一辈子的事》等。\n\n\n精 彩 选 段\n美和恶之间的分界有时是难以度量的，是需要我们权衡的。P.92\n君子是有原则的，以一颗公心在做事。P.149\n君子不器，意味着人不要把自己变成固定的物体，永远不要让自己处于固化状态。P.233\n我们做事情的时候，要学会与自己和解，让内心变得不纠结，轻装上阵，做自己该做的事、快乐的事。P.426\n\n注：上述页码为句子在实体书中所在的页码。\n\n\n\n\n演 讲 实 录各位好，非常高兴《樊登讲论语》的下半篇——《先进》篇正式面世了。今天我给大家在《先进》篇当中摘出二十句我认为对每一个人的生活都会有影响的句子跟大家分享。\n很多人问说为什么叫“先进”？因为论语一共有二十个篇章，我讲的时候因为部头太大了，所以出版社说把它分成上下两册。上册就选了第一篇的篇名叫《学而》，下册选了第十一篇的篇名叫《先进》。\n《论语》上半部十篇，下半部十篇，让我去选择这里边最喜欢哪个，是一件非常困难的事。所以我的选择标准是：哪些句子跟我们每一个人的生活关系最大？我就挑出了这么二十句。在讲上半部的时候收获了大家很多的好评，给了我动力和信心来讲下半部。\n首先是《先进》篇，《先进》篇我选的第一句，是“季路问事鬼神”的事。季路就是子路，子路是孔子手下年纪比较大的一个学生，而且他因为出身比较卑微，所以跟孔子之间经常会闹出很多笑话，性子非常直，经常会“子路愠见”，就是不高兴就过来找孔子吵架的这种人。\n然后有一天，子路问了孔子一个特别有意思的事，这个事可能每一个人心中都会有这样的疑问。子路问孔子：“如何事鬼神？”这一段是这么说的：“季路问事鬼神。子曰：‘未能事人，焉能事鬼？’曰：‘敢问死。’曰：‘未知生，焉知死？’”你发现孔子对于自己没法回答的问题，他都有办法给怼回去。\n子路来问的问题是我们怎么事鬼神。因为在春秋的那个时候，很多人还在大力地祭祀，很多人在争论到底该不该用活人陪葬？到底该不该有“始作俑者”，拿陶俑去陪葬？我们在丧葬这件事情上，到底应该花多少钱才算是合适的？然后孔子回答说：“未能事人，焉能事鬼？”\n这句话太实用了，就是直到今天，我们可能很多人也不知道这个世界上到底有没有鬼。但是孔子的回答是：“你先把人的事搞好，你连怎么样侍奉人你都没学好，你凭什么去学侍奉鬼呢？那事离你太远了，别想了。”然后子路又接着问：“那敢问死？”也就是说，死是怎么回事？死了以后我们去哪儿？死了以后到底是有还是没有？这就是一个终极问题。\n孔子用同样的逻辑怼回去了。孔子说：“未知生，焉知死。”这是名言。就是你活明白了吗？你对你活着的这些事搞清楚了没有？有这么多需要我们去研究的东西，你都没搞明白，宇宙、苍生，然后经济、政治，这么多东西都需要我们去探索、去学习，让活人能够活得更好，才是我们力所能及应该做的事情。然后你非得去研究说死了以后去哪儿，这种事别研究。\n那孔子为什么对于这些不知道的事情不谈呢？这个叫“六合之外，存而不论”。就是看不到的这些东西，孔子的态度是“我不能够随便地说它没有，我也不能够随便地说它有”。因为说“没有”和说“有”，孔子都要负很大的责任。在另外一本书当中有这么一段，子贡跑来问孔子：“这个人死了以后到底有没有灵魂？”孔子说：“我不能说。”\n子贡说：“为什么不能说？”孔子说：“你看，假如我告诉你们人死了以后是有灵魂、有来世的，那么所有的这些孝子贤孙就会花大量的力气在陪葬这件事情上，这个社会就会有大量的成本都在安排死后的事情。所以我不能说是有的。那你也不能说没有，为什么呢？我如果告诉大家说，死了以后人死如灯灭，死完什么都没有了。那么就会有很多人把父母的丧葬不当回事。反正没有了，扔在道边，不用管他——这也不合乎于礼。我现在影响力这么大，我说一句话就可能很多人照着这个去做。所以，我不能够说有还是没有。”\n然后，子贡就接着问：“那现在就咱俩，没别人，我也不跟别人说，你就悄悄告诉我到底是有还是没有。”孔子说：“等你死了就知道了。”这就跟对付子路的办法是一样的。就是孔子始终不揭开这个盖子。这其实是中国人的一种智慧。如果我们坚定地认为有来世，坚定地认为有鬼神这样的东西，那真的会造成特别多的迷信。\n但是，如果一个人完全没有信仰，完全没有敬畏，觉得就是无所谓，我只要现在、当下、眼前的东西，有可能这个人就会没有边界。我们能够做到的事情是把生活先过好，把能研究的东西先研究明白。而至于那些没法研究清楚的事放在一边，不用讨论。不需要什么东西都一定要找到一个标准的答案才行。所以，“季路问事鬼神。子曰：‘未能事人，焉能事鬼？’问：‘敢问死。’曰：‘未知生，焉知死？’”大家感受到孔子的智慧了吧？\n然后，在这一章当中我选出来的另一句是子贡和孔子的一段互动。子贡问：“师与商也孰贤？子曰：“师也过，商也不及。”曰：“然则师愈与？”子曰：“过犹不及。”这句话太重要了，这句话给中国人所追求的中庸的态度找到了一个特别好的例子。\n子贡问老师说：“师和商两个人，谁更好一点?”“师”是颛孙师，就是子张，然后“商”是卜商,就是子夏，子张和子夏都比孔子要小几十岁，属于比较年轻的学生。子贡的年纪稍微大一点，属于大师兄这一辈。\n然后，子贡就问孔子，这两个年轻人，子张和子夏这两个人都是很出色、很优秀的青年才俊，谁更好？然后孔子说：“师也过，商也不及。”子张，也就是颛孙师这个人，有点“过”，这个子夏有点“不够”，这个“过”和“不够”怎么体现出来呢？比如说子张老来问孔子问题，这些问题都特别急功近利。我们用英文词来形容叫作aggressive（有进取心的），就这个人特别有野心，特别想要进步。然后整天在努力地奋斗，努力得甚至都有点钻营的感觉了。\n然后，“商也不及”，就是子夏这个人，你看他经常讲没关系、无所谓、不要紧，没有那么严重，他又往后撤，他缺少了一定的原则性，他经常会给自己的要求不够高。\n然后这时候子贡就问：“然则师愈与？”第一个“愈”就是超过，那照你这么说子张是不是好一点？就这个人比较努力、比较奋斗，所以这个人”过”。然后，孔子就讲了一句名言，叫”过犹不及”。”过犹不及”就是太过和不够都不好，这两件事是一样的。\n你看我们在生活当中随便举个例子，比如说教育孩子，我们对孩子要有足够的爱，有一个词叫“无条件的爱”，“无条件的爱”掌握不好就变成溺爱了。溺爱就是“过”，就是什么事都行，没关系、无所谓，你要什么给你买什么。从来没有人说他不对，这就”过”了。\n那“不及”是什么呢？“不及”就是没有爱。然后整天吼他，冲他大喊大叫，那你说这两个哪个好呢？是说那个吊打的更好呢？还是这个不管的更好呢？“过犹不及”这两种状况都会产生相似的结果。我们曾经看到过这样的案例，在新闻中也能读得到类似案例：有的家庭的孩子是在溺爱中长大了，有的家庭的孩子是被暴力打着长大的。最后你会发现这两个孩子走上同样一条道路，他们都有可能会犯罪，都有可能会去吸毒等等。\n为什么？就是无论是不爱还是溺爱，都不会让这个孩子感受到安全感。那真正合适的方法在哪儿呢？就是孔子讲的“中庸之道”。我们中国人讲中庸之道，经常在小时候被错误地理解，以为就是“六十分万岁”，就是差不多，别太追求更高分了。其实不是，中庸之道绝对不是凑合，中庸之道是一个极致。而且孔子讲过，我这一辈子见了这么多人，我没见过一个真正能够做到中庸的人。\n这是相当不容易的一件事，包括柏拉图也这么认为。他跟孔子是同一个时代的人，在那时候也讲”合适是美德”，这其实也是中庸之道。就是你能够做一件事情，一出手正好合适。那孔子为什么说连他在内，这么多人都没法做到中庸呢？因为中庸很难，中庸是一种极致。什么极致？中庸是合适的极致。你像我们讲了这么多书，讲领导力，然后讲营养，我们讲怎么带孩子，我们讲了各种范畴的书，到最后的核心其实都在度的把握上。而这个度的把握又是最难的一件事。\n有人经常讲，樊老师那你就告诉我那个度到底是多少，我就按照那个度去做就好了。如果世界上所有的事情都这么简单的话，这个世界就特别无趣、没意思。你说怎么对孩子是好的？好了，回家五件事，一、二、三、四、五这么一做，就是最好的。哪有这么简单？生命如此复杂，然后你用一个公式竟然就解决了这些东西，那生活有什么劲儿？生活有趣的地方就在于我们要无限趋近于那个合适的点，这就是修炼的过程\n但是，如果一个人意识不到这一点，他意识不到过犹不及，他不知道自己所做的这个行为到底是”过”还是”不及”，他总觉得自己是对的，缺少反思能力，缺少对自我行为的反观。这时候，他就不可能收敛于那个合适的点，他会朝着一个方向越走越偏。\n任何一件事情你都可以拿出来举例子，你说勇敢这件事好不好呢？勇敢肯定是一件好事。但是如果一个人过于勇敢，动不动就跟人打架，难道是一件好事吗？如果一个人太不勇敢，导致他变得懦弱，这也不是一件好事。任何一个美德只要失去了合适的度，你就发现它会跑偏。所以这个”过犹不及”是中国人的智慧。这个是孔子在《论语》当中给到大家的建议，希望我们每一个人能够建立批判性的反思能力。\n这里我要推荐大家去读一本书，就是我们讲过的《思辨与立场》。《思辨与立场》说如果你在生活当中还有烦恼，一定是因为你的思维方式错了。那核心是什么呢？就是我们反思的对象应该是我们自身，当我们不断地反思自身的时候，我们的行为才会越来越趋近于那个合适的点。\n而如果我们整天反思的都是看别人不对，然后都觉得自己特别好，我这个人都没啥问题，我最大的问题就是人缘太好——整天做这样的自我标榜和总结，最后的结果就是你要么”过”，要么”不及”。你会失去切近于中庸之道的可能性。\n所以，子贡问：“师与商也孰贤？”子曰：“师也过，商也不及。”曰：“然则师愈与？”子曰：“过犹不及。”大家其实可以把“过犹不及”变成一个座右铭。然后写在自己的桌上，这个确实对我们每一个人都是一个很好的提醒。\n接下来我们说《颜渊》篇。《颜渊》篇里有很多人来问政，在《孔子》那个电影里，陆毅演的那个角色就是季康子，也就是季氏家族的年轻一代的掌门人。然后，季康子问政于孔子曰：“如杀无道，以就有道，何如？”孔子对曰：“子为政，焉用杀？子欲善而民善矣，君子之德风，小人之德草。草上之风，必偃。”\n我为什么选这一段？我在讲领导力的时候经常会引用这一句话。季康子是个年轻的掌门人，他上台以后，他就问孔子说：“如杀无道，以就有道，何如？”就是我把那些坏人拉出来砍头，杀了。然后，倡导大家都去向好的学习，你觉得这样做对不对？这个可能是有点听了孔子讲的“举直错诸枉，能使枉者直”，我们要把好人举荐出来，这时候你发现周围的那些坏人，也慢慢地变成了好人。”蓬生麻中，不扶自直”就是这个道理。\n所以，一个公司里边，你想看这个公司的领导正不正，你就看他提拔的人对不对。如果一个公司提拔上来的人全都是一些喜欢拍马屁的奸佞小人，那叫作”举枉错诸直”。就是你把弯曲的拿上来了，你没有把直的拿出来。\n但是，如果这个公司提拔上来的人一看，是不唯上的，不取悦领导的，然后努力做业务的，具有批判性思维的，这个叫作“直”，“举直错诸枉”。所以季康子有点心急，说如果要把“举直错诸枉”这件事做好的话，我用杀人的方法怎么样？我把那些不好的我都杀掉，孔子对曰：“子为政，焉用杀？”你来管理，干吗杀人呢？然后“子欲善而民善矣”，如果你真的想要往好的方向走，老百姓就会往好的方向走。为什么呢？“君子之德风，小人之德草。草上之风，必偃。”\n各位注意，君子和小人不是骂人，我们今天一讲君子跟小人就觉得说骂人，这个人是君子，那个人是小人。哪有这么容易的区分。在《论语》当中，“君子”跟“小人”经常出现的时候，表示的是社会地位。管理者你可以用”君子”来叫，然后被管理者就是“小人”，这是一种用法。当它跟修养挂钩的时候，我希望大家把“君子”跟“小人”理解为两种状态。就是我们每一个人体内都有两种状态，一种是君子的状态，一种是小人的状态：“君子求诸己，小人求诸人”；“君子和而不同，小人同而不和”；“君子泰而不骄，小人骄而不泰”；“君子群而不党，小人党而不群”。\n你看，我们每一个人在人生的不同阶段，都有可能表现出“君子”的行为和“小人”的行为。而且根据我的观察，我们在童年时期，更多表现的是“小人”的行为。就你看小时候我们最喜欢拉帮结派，就爱说“咱们不跟他玩”“我们讨厌他”。然后我们喜欢的人，就是跟我们有同样爱好的人。你看都是“小人”的这个特点，谁跟我们不一样，我们就孤立谁。因为小孩子他的认知就那么直接、简单，他是个“小人”。\n但是如果这个“小人”的状态始终不变，你想想看，一个人如果长到了三十岁、四十岁，还跟一个小孩子一样任性，还跟一个小孩子一样用简单的认知来判断谁是好人，谁是坏人，谁跟我在一起我就支持谁，反之我就反对谁。因为他是我的老乡，所以我一定要支持他。三四十岁了你还这样，那你体内“小人”的成分没有减少。所以我们这一辈子是一个修炼的过程，就是要不断地减少我们体内“小人”的成分。然后不断地增加我们体内“君子”的成分。 “君子之德风，小人之德草”，讲的是两种社会地位。管理者的德行像风一样，被管理者的德行像草一样。\n“草上之风必偃”，就是你这个风往那儿一刮，这个草就倒了，草就跟着风的方向就倒过去了。所以季康子作为一个领导者，你现在希望你的老百姓能够向善，能够积极，能够变得更好，那最重要的一件事就是你来做，你来倡导这件事情，你来努力地往你期待的那个方向去行动，你所做的事情别人会看得到。\n我们讲过一本书，叫作《哈佛商学院最受欢迎的领导课》。那本书里面有一条原则特别有意思，说当一个人成为领导以后，他立刻就成了团队里的大猩猩。这个话很多人不明白，说什么叫成为团队里的大猩猩？就是你不再是一个人了，你变成了这个团队里面的一个硕大无比的大猩猩。同样是这个体积，从那楼道里走过来，大家的眼睛都盯着你，你身上的任何一个小小的细节都会被放大。\n“楚王好细腰，宫中多饿死”，你想想看，楚王就是喜欢腰细的。结果好多宫女都饿死了，就是为了把腰搞得更细就饿死了。你的一点点偏好只要显露出来，你就会发现它会被底下的人无限地放大，我们讲过宋徽宗，各位记得吧，宋徽宗喜欢祥瑞，喜欢玩石头，搞花石纲。然后只要他敢露出这么一点点爱好，在徽宗本人看来会觉得说这都是艺术，这都挺好的，我把艺术带到了一个高峰。他如果是个艺术家，这样做是没有问题的。\n但他是一个皇帝，他如果要把艺术带到一个高峰，全中国的人都会为了那些破石头交税。然后大量的老百姓没饭吃、饿死，就是为了能够把这石头凑上去。然后他喜欢祥瑞，各地就整天报祥瑞，这儿见到一只玉兔，那儿见到一个灵芝，然后黄河水突然变清了，整天报这些东西来骗他。这就是从上到下的一种信号放大的过程。\n在管理的过程当中，领导者的信号会被经常性地放大。所以，你看我在我们公司算是创始人，然后我就经常要跟大家不断地强调，你们要允许我发言，前提就是别把我说的话太当回事。如果你们把我说的话太当回事，我说的每一句话都一定要执行，那我就不敢说话。因为很有可能会被无限放大，最后付出很多的成本。我做了一件错事，员工还不觉得有错，因为这是老板说的，这就是一个公司的文化。\n所以孔子告诉季康子：“君子之德风，小人之德草。”对于你来讲最重要的一件事，就是你去向善，你去培养你的德行。你放心，这件事情一定会传递出去，所以不需要使那么大的劲。\n你只需要“为政以德，譬如北辰，居其所而众星共之”，我们在上部当中曾经讲过。复杂体系不能够用大量的、简单的、机械化的方式来驱动，像季康子所用的方法就是机械化的方式：符合的留下来，不符合的杀掉。他成为了一个“质检员”。这时候你发现你有做不完的工作，这样的管理者又累又错。因为复杂体系根本没法靠简单的纠错就能够解决。复杂体系靠的是培养氛围，靠的是把大家的生命力焕发出来，让所有的人都知道方向在哪儿。所以，华为有一句话我们也特别欣赏，叫作“方向大致正确，团队充满活力”。这就是一个生态系统的典型特点。\n所以，这句话我认为跟我们的生活和工作都有着特别重要的关系。包括很多人带孩子，整天把眼睛盯在孩子身上纠错，这儿改一下，那儿改一下。我有时候在网上看到那些父亲和孩子发生矛盾的视频，我心里边特别难过。我觉得一个家庭这么美好，怎么会变成这个样子呢？太可怜了，跟打仗一样，完全是敌对的关系。\n你有没有想过，“君子之德风，小人之德草”，你作为一个家长，你能不能够先爱学习？你能不能够先跟别人说话客客气气的？你能不能够关心别人的情感、情绪，而不是上来就跟人硬怼？这时候你的孩子一定会长得跟你越来越像，跟季康子的道理是一模一样的。\n所以希望大家能够喜欢这句：季康子问政于孔子曰：“如杀无道，以就有道，何如？”孔子对曰：“子为政，焉用杀？子欲善而民善矣。君子之德风，小人之德草。草上之风，必偃。”\n接下来，还是在这一篇当中，有一句叫作“君子成人之美”。子曰：“君子成人之美，不成人之恶。小人反是。”我是在重新整理《论语》的时候，对这句话特别有感觉的，什么叫“君子成人之美”？我们过去有一种解读是说，“君子成人之美”就是能够看到别人的优点，我觉得不对，我觉得“君子成人之美”是你能够帮助别人促成什么样的事。\n其实我们在生活当中是别人的助援，别人要做一些事情，你可能加把劲、添根柴，这事就做成了。然后你要帮别人做成什么样的事呢？好事。你比如说，这家孩子考了大学，缺点学费，然后这时候你能帮他一点，让孩子能够上大学，这个叫作“君子成人之美，不成人之恶”。什么叫“成人之恶”？有一次我们家有个很近的亲戚找我，让我给他们的孩子走后门，安排一个工作，但是我说不行，我不能干这样的事，我说这样做其实把孩子害了，这不是一件好事，这是一件坏事。\n因为我们觉得找工作很难，我们就要想办法走后门，把孩子塞到一个工作岗位里边去，那是父母的眼界决定的。父母的眼界只盯上了他一个月能够挣两千或者三千块钱的基本工资，就觉得很好。再过十年这个孩子可能就废了，这个孩子除了每个月挣那点工资之外，他什么都不会。\n对于一个年轻人来讲，他最大的资本就是时间，就是年龄，就是可以试错。所以，这时候哪怕找不到工作，也让他去社会上折腾，去从最基本的事开始做起，去吃苦。再过个三五年你再看，这个人的能力就完全不一样了。所以这种事能帮也不帮，为什么呢？“君子不成人之恶”。\n还有一些更糟糕的“成人之恶”。比如说行贿受贿这样的事情，比如说拉托这样的事情。就是好多人在酒桌上把这句话用俗了，说今天给你们俩介绍在一块儿了，特别好，“君子成人之美”。真的特别好吗？这两个人在干坏事，你在这中间起到催化剂的作用，这就叫作“成人之恶”。所以，为什么有很多人愿意“成人之恶”呢？因为”成人之恶”能够收获捷径，这个词英文叫shortcut，捷径。\n你看跟孔子讲的“君子群而不党，小人党而不群”是一模一样的。君子不拉帮结派，拉帮结派是非常危险的一件事。因为拉帮结派代表着你做事根本不讲原则，你不是从原则出发考虑一个事该不该做，你是考虑人际关系，你是考虑是不是老乡，或者是不是有利益的绑定。这时候你发现，一旦出问题，那可能是一锅端。更重要的是你自己的良心道德也过不去。\n所以，不要走这种“成人之恶”的捷径，我们如果能够“成人之美”，我们努力地帮别人做成一些对社会有益的好事，对这个人人生发展方向有价值的好事。这时候不是捷径，可能会更累、更难。因为正确的事情都是需要付出一定的精力、时间去慢慢做的，还不一定能够成功，还有运气的成分。所以我们值得这样做，我们值得去努力地做一些有价值的事情，而不是寻找捷径。\n所以这句话告诉大家，子曰：“君子成人之美，不成人之恶。小人反是。”大家以后在帮别人忙的时候，你也考虑一下这事到底是该帮还是不该帮。不要担心拒绝的压力，人必须得能够说不。如果你永远都学不会拒绝，那很有可能你会被道德绑架。\n这里面还有一句叫“乡愿，德之贼”。孔子讲：“乡愿，德之贼。”什么叫“乡愿”？“乡愿”就是那种觉得什么都好，没关系，都不错，然后整天到哪儿都是个老好人。在别人看来似乎觉得这个人道德好高尚，但他没有原则。乡愿和君子的区别就如“恶紫之夺朱”。紫色和大红色是非常容易混淆的，然后乡愿和圣人是非常容易混淆的。\n孔子最讨厌的就是乡愿来冒充圣人。他没有原则，谁都讨好，什么事都嘻嘻哈哈的，最后让别人以为这人可能是个圣人吧。因为他什么都成，“成人之美”“成人之恶”，他都做。那他就不是一个君子。所以”君子成人之美，不成人之恶”。然后最后一句很有力量，就四个字，“小人反是”——小人刚好反过来。小人看到别人要做好事，他老捣乱，他老想办法劝人家别做，说”读什么书？读书有什么意思”，但是别人要做坏事的时候他特别来劲。所以这个大家自己判断。\n接下来我们说到《子路》这一章，《子路》这一篇我选了三句，因为这篇精彩的话实在是太多了。第一句，“子夏为莒父宰，问政。子曰：‘无欲速，无见小利。欲速则不达，见小利则大事不成。’”中国人都会知道这句话”欲速则不达”，后边还有一句叫”见小利则大事不成”。这个子夏前面我们提到过了，他是个年轻人，到莒父作宰，到县里边做官。问政，就过来问说我该怎么做，我做这领导，我应该怎么去把这个团队搞起来？然后，子曰：“无欲速”，这个“无”在这儿一般念“勿”，就是不要想快。然后“无见小利”，不要去追求蝇头小利。“欲速则不达，见小利则大事不成。”\n这个话到了今天，我们通过幂次法则的方式把它验证。你发现好的项目全都是一点一点滚出来的。这个在创业上叫作“飞机起跑曲线”。很多人说樊登读书是个爆款网红项目，觉得说一夜之间红起来了。哪有一夜之间这样的事呢？只是之前你不知道而已。之前我们做了那么多年，没有人听说过我们。我们在这个飞机起跑曲线的前端，一直在”吭哧吭哧”地慢慢讲。我们身边可能只有一千个用户、五千个用户，甚至到五万个、十万个用户的时候，你是根本看不到的。\n但是，在那一段时间所积累下来的东西，就叫作know how（诀窍）。就是你所拥有的这些经验和知识不断地磨合、不断地迭代、不断地打拼，然后当它走过了这么一个拐弯的点的时候就上去了，你看Y=NX这么一个方程，它的曲线是过了拐弯点以后陡升。移动互联网时代，几乎所有新公司的特点都是这个样子。\n那“无欲速”是什么意思呢？如果一个人看到别人的项目起来了，那怎么办？我们也照着做一个，照着做一个的往往不对，往往出问题，原因是什么？因为你能够看到的起点其实已经是人家的半山腰了。你从半山腰切入进去跟人家学习，然后，你说我多花钱，我多融资投进去，然后赌一把。这时候往往就是一个大坑就跳下去了。那天我跟薇娅聊天也是这样，好多人觉得薇娅就是一夜爆红，哪有，做了那么多年，只不过之前大家不知道而已。\n但是很多人就想：我学她，我去搞最低价，然后我也直播。死了一大批，很多人都做不起来。这就是孔子讲的“无欲速，无见小利。”那为什么要“无欲速，无见小利”呢？就是我们讲过一本书叫《低风险创业》，也是我写的。还有一本书叫《精益创业》。这两本书有一个共同的特点：创业不要花太多的钱。创业花太多的钱会影响到你对事情的准确判断，钱会掩盖你犯下的错误。因为你账上一直都有钱，所以你就一直按照你的计划去做事。这时候你发现你所做的东西没有反思和迭代，这个反思和迭代是非常重要的一个过程。\n但是因为有钱，不着急，所以就没有。没有的结果就导致突然之间没钱的时候，你才发现来不及了。而“无欲速”的特点就是我不着急，我没有想着三年之内做个上市公司，我先用乐趣来迭代我的产品，就先服务那么少一点点人，一点点试。然后让幂次法则发生作用。\n幂次法则怎么发生作用呢？只要你的客户口碑好，能够带来新客户，幂次法则就会发生作用。所有的好产品的共同特点就是口碑好。\n现在这个时代，跟过去我们打广告的时候不一样了。你还记得九十年代的时候，我们有很多企业喜欢争央视的标王。就是一次投几个亿，买一个天气预报后边的广告。那个时候就是“欲速”。标王花了太多的力气在买广告这件事上，大量的钱全都花在买广告上了。他们在产品上下的力气就减少了，从而导致的结果是广告卖得越爆，产品的口碑越差，这个公司死得越快。所以，这时候你发现孔子讲的”别着急，不要老想快”很有道理。\n然后“无见小利”就是不要着急赚那点小钱。这个牵扯到心理学当中一个非常重要的点，叫作“延迟满足感”。哈佛大学的人曾经做过一个棉花糖实验。就是让一帮小孩坐在这儿，然后说桌上放着棉花糖，你现在可以吃，你吃了就没有了。但是，如果你能够忍住十分钟不吃，我再给你一个。然后就看这帮小孩吃不吃，拿摄像头监控着。你会发现很多孩子想都不想拿起来就吃，糖放在这儿还能受得了吗？然后有的孩子就认真坐那儿忍着，拿起来闻一闻，放下，摸一下、捏一捏，就是不吃，一直忍着，到点了才打开吃，又得到一个奖励。\n这个实验干吗呢？就是想看看这样的孩子会有什么不同。他们会连续跟踪这些孩子，去看他们的学习成绩，看他们工作的效果，看他们最后的成就。最后得出了一个结论：区分成功和失败的一个非常重要的心理上的标志就是延迟满足感的能力。\n你在我们会生活当中也能够看得到，凡是付钱付得频率特别高的，往往都是收入不高的工作。假如你希望说一单一结，每一单都要结，那你只能干体力劳动；你说我一个月一结，那就是打工；然后如果我能够接受年薪，那就是高管。假如我愿意跟着公司一块儿上市，那你的延迟满足感更强。\n那你说像埃隆·马斯克这样的人更奇怪，他都已经赚钱了，不满足，把这些钱全部拿出去，再做登陆火星、搞特斯拉这样的深入研究。因为他不需要前期的满足感，他可以控制好自己的欲望。然后去做一些更伟大的事，这就是延迟满足的能力。\n孔子跟子夏所叮嘱的“无欲速，无见小利，欲速则不达”，如果你特别想快，你可能就掉坑里边，就折了。然后，“见小利则大事不成”。小利见得太多确实会产生诱惑，我经常会劝很多刚毕业的大学生不要创业。为什么呢？我见过特别多这样的项目，它典型的特点都是他就做校园周边的生意。一个大学生他有多大的眼界？他就是在校园周边开个小旅馆、咖啡厅、自习室。因为他就没长大，他眼睛所看到的所有市场就是那么大，所以他一创业干的就是这么点小事。如果干败了还好，干败了他有机会接受教训去干点别的事，最怕的是一干这个还挣钱了，一个月能挣两万、五万。好了，这人搞不好干一辈子，这就叫作”见小利则大事不成”。\n所以请大家记住这条“飞机起跑曲线”。因为彼得·蒂尔在《从0到1》里边讲了这个世界大部分的事情不是正态分布的，这个世界上大部分的事情都是幂次分布的。你看现在财富变得越来越集中，图书的发行量变得越来越集中，名声变得越来越集中。幂次效应在社会生活中变得越来越显著。而如果我们忽略了这个飞机起跑的过程，我们特别希望一步就跨上一个大台阶，往往的结果就是你没法找到你自己真正有别于别人的know how（诀窍），也就是你的秘密。没有秘密的企业是做不大的。\n接下来这句，子曰：“君子和而不同，小人同而不和。”汉学家们（外国人研究中国文化的人）一致认为，中国文化给全世界最大的贡献就是和谐。我有一次在北京汉学家大会上去采访：“你们觉得中国文化对世界的贡献在哪儿？”他们说：“和谐。”为什么是和谐呢？因为“君子和而不同，小人同而不和”。中国的和谐是建立在尊重不同的基础之上，而这个世界上有很多种文化，有的文化的特点就是凡是不同的都叫异教徒，你如果是我的异教徒，那我就要毁灭你。\n这个和谐的特点呢，晏子讲得特别清楚，叫“譬如调羹”，就好像我们要做一碗羹。调羹的特点是你不能以羹调羹。以羹调羹就是全是料，把这些料拌在一块儿，越拌越稠，没法吃了。也不能以水调水，你全是水，放在一块儿搅，那搅来搅去也是水。必须以水调羹，就是你有藕粉放在那儿，冲点水进去拌一拌，羹就出来了，就可以喝了。这就是“不同”所带来的好处。\n所以对于一个团队来讲，尊重不同是很重要的；对于一个社会来讲，尊重不同也是同样重要的。我们这个社会特别需要的就是一些包容性。为什么？包容性能够带来活力。所有的创新都是来自于边缘地带，都是来自于两个不同的文化的交界处。这时候你发现它就能够出现很多的创新。\n十六、十七世纪的巴黎，为什么能够快速地崛起，成为世界时尚之都？因为那个时候巴黎的人有了包容的心态，然后修了桥，搭起了路灯，把夜间点亮。然后你让各种各样的人，包括王公贵族、贩夫走卒，都能够在一条大街上走来走去。然后互相看样学样，学宫里的人怎么穿衣服。所以就从那儿开始，巴黎成为了世界时尚之都。\n所以创造这种交流的机会，创造这些不同的在一起的空间，这就是一个城市、一个社会非常重要的原则。这句话能够在各种层面使用：个人、家庭、社会、城市、国家，我们都能够体会到和谐的美好。所以，不要追求把其他人都改造成跟你一模一样的人。两个人在一起过日子最重要的就是你跟我不一样，但是我们俩能够过得很好；如果我非得把你扳成跟我一样的人，两个人可能会打一辈子的仗，然后最后不了了之。所以子曰：“君子和而不同，小人同而不和”。\n接下来这句话是人力资源里边用得最多的，叫作：“子曰：‘君子易事而难说也，说之不以道，不说也；及其使人也，器之。小人难事而易说也。说之虽不以道，说也；及其使人也，求备焉。’”这个话有点复杂，先解释一下。\n“君子易事而难说”，就是一个君子你很容易跟他共事，但是你很难讨他的欢心，为什么呢？“说之不以道，不说也。”你如果让他高兴的这个事不合乎道，他是不会高兴的。然后“及其使人也，器之”，当这个君子用人的时候，“器之”就是你是一个什么材料，我就把你放在一个什么地方，用人之长，你做好你自己的事就好了，这个叫作“器之”。\n然后“小人难事而易说也”，小人难合作，但是特别容易讨他的欢心，为什么呢？因为“说之虽不以道，说也”，你不合乎道，讨他高兴，他也会高兴。你比如说，帮领导搬个家，给领导送个手机，给领导的孩子送去幼儿园，每天拍领导的马屁，种种这样的行为，领导高兴，说这是我的人，这人对我多忠心，这个叫作“说之虽不以道，说也”。\n但是你要注意后边这句“及其使人也，求备焉”。这种领导你看起来说很好相处，每天嘻嘻哈哈、高高兴兴，但是当他用人的时候求全责备。求全责备就是你这事做好了，但你那个事没做好，那还不行。因为他不是一个君子，他的特点就是随心所欲。小人一旦到了一个位子上，他典型的特点就是我说了算，我就是法。\n《论语》当中曾经有一段，别人问孔子，有没有“一言以兴邦”“一言以丧邦”的？孔子说，“一言以丧邦”的人很多。我当皇帝最快乐的事就是没人能违抗我，这就叫“一言以丧邦”。如果一个人当了领导以后，他最大的快乐就是我说什么都得算，完了，因为他判断东西完全没有原则。\n一个优秀的领导的特点是自己做对了小声说，自己做错了大声说。这个领导具备批判性思维，他才能够公平地对待其他人。这个东西你说拿什么机器来替代，说用一个什么KPI（关键绩效指标）来替代所有的判断，别想，不可能。KPI根本判断不了人的内心，KPI根本判断不了这个人的创造力、未来，KPI更多判断的是这个人的运气，就他运气好才实现了。\n但是如果这个人内在缺乏这杆秤，这就是我们说人生复杂的特点就在这儿，它最后都归结在人身上，这个人的特点是什么样的，就会决定了他怎么对待他人。我就不明白孔子当年，没有那么复杂的职场，也没有那么多的宫斗，没有大公司，他竟然能够如此准确地找到君子跟小人的脉。君子的特点就是你想讨好他，没用，送手机他也不高兴，甚至不要，他骂你都有可能。工作做好了是最重要的，“说之不以道，不说也”。\n但是小人特别容易受贿，特别容易让他高兴，拍马屁永远有效。那这时候你发现你的苦日子在后头。所以反过来想，我们作为一个在下边的人，我们也不要试图去钻这样的空子。我们说这个领导好搞，这个领导我只要拍他马屁他就高兴，甚至有很多人在职场当中所总结的经验就是拍马屁，觉得只要我马屁拍得好，只要我会表现，我就能够青云直上、一路往前。短期之内遇到某些领导可能会有效，长期一定会受挫。\n因为黑天鹅事件迟早会发生，一旦黑天鹅事件发生，你就会发现这样的领导是不能够跟你甘苦与共的。他的特点就是好的时候都行，坏的时候全是你的问题。所以区分清楚领导之道，也要搞清楚自己为臣之道。子曰：“君子易事而难说也，说之不以道，不说也；及其使人也，器之。小人难事而易说也，说之虽不以道，说也；及其使人也，求备焉。”\n接下来，我们到《宪问》这一章。《宪问》这一章，我选了两句，其中第一句是我在讲课的时候常用的一句。子曰：“古之学者为己，今之学者为人。”这话太好了。在孔子嘴里边只要说古之什么什么，基本都是好的，因为孔子是好古嘛。他说”吾从周”，他从周公那学来了好多东西，他觉得古人的东西是淳朴的、美好的、合乎于道的，现在被这些季氏、诸侯们搞得越来越糟糕了。\n所以孔子说“古之学者为己，今之学者为人”。我们现在人听了不是“我为人人，人人为我”吗？我们为人难道不是个好事吗？错了，学问是要用在自己身上。“古之学者为己”，古时候学东西的人，学东西是为了谁呢？为了改变自己。所以，他读一本书看到一句话，我能不能用？是不是我做得不对？我有没有对照？然后“今之学者为人”的特点是现在的人读一本书，觉得“我们老板如果读这个书就好了”“这书我一定要让我老婆看”。我见过太多这样的留言。\n我现在不是在直播卖书吗？因为我希望让更多的人不光是听书，还能够自己读一些书，所以我每周四晚上都会做一个直播卖书的活动。然后每次卖书的时候我就发现大量的人都是留言说“五年级的小朋友应该看什么书”“初一的男孩应该看什么书”“初三的内向的女孩应该看什么书”，他们把我当成了一个推荐书的专家，然后不断地问别人应该看什么书。背后的想法很明显，就是他们觉得孩子不够完美，所以要让孩子读书。\n但实际上你要知道读书就是代表着谦虚，而谦虚这件事情只能够自己对自己说，你不能够要求别人谦虚。你说你应该谦虚，那就是你傲慢，因为你能够判断出来他应该谦虚。哪有那么容易，你唯一能够判断的是你应该谦虚。所以《黑天鹅》的作者塔勒布说读书是最好的学习方式，为什么？因为读书代表着你还有一点点谦虚的态度。\n而我们很多家长自己不读书，整天就是希望孩子读书，最后的结果只能是什么？越来越糟。原因是你给孩子买的书孩子不会看，孩子会觉得好讨厌，每天给我那么多的书，你自己又不读，整天让我读，我都没见过你有什么进步，你整天让我进步，我真进步快了，你跟不上了怎么办。所以“古之学者为己”，你只需要把自己学好，你看到任何好东西，你的第一反应都是我能不能用？我能不能改？这才是一个真正有效的学习方法。\n有的父母说我就是很着急，孩子不动，我怎么办呢？你就别把那么多精力放在孩子身上就好了，原因是孩子有他自己的生命力，你给他稍微宽松一点，他的大脑皮层可以更放松，大脑皮层更放松，他就更有创意。我们讲过《自驱型成长》这样的书，是从脑科学的角度让我们了解你不能够通过施压的方法让别人发生改变。\n但是“今之学者为人”，今天我们很多人学东西就是为别人学的，学了就是希望别人能够改变，这是悲剧。你使了很大的劲，然后效果还非常糟糕，你不如把这些力气用在自己身上。所以我总结我们公司这么多年来的发展，我发现如果我们做对了什么事的话，那就是我是带头学习的人，我每天学的所有的东西我自己先用，用完了别人用不用我不管，我的办法就是我讲给你们听，你们听懂了愿意用你们就用，听懂了不愿意用，我也不管，那是各自的造化。\n最后的结果你会发现，他就会跟上来。因为他看到你在进步，所以他们也会学习，也会跟上。所以多在自己身上使劲，你才能够真的改变这个世界。改变这个世界最有效的方法，不是去改变别人。如果有捷径的话，捷径就是改变自己，每个人把自己的事做好，这个世界就好了。所以，子曰：“古之学者为己，今之学者为人。”\n下面这句特好玩，这是孔子说子贡的话：“子贡方人。子曰：‘赐也贤乎哉？夫我则不暇。’”我每次读到这句我就想笑。“子贡方人”是什么？子贡特别喜欢讨论别人的事，这个人厉害，那个人不行，谁比谁差一点，谁跟孔子差了多少个子贡，就整天说这些东西。\n然后孔子知道这个事以后，孔子也没批评子贡，子贡乐了。孔子说“赐也贤乎哉”，这个子贡的名字叫端木赐。所以孔子称呼子贡为“赐”，说子贡（赐）恐怕是很棒吧，“贤乎哉”，他是真好，他已经非常好了吧，为什么？“夫我则不暇”，如果是我的话，没功夫讨论这事，这就是一个非常带有幽默、调侃性质的一个提醒。然后把子贡放在了《论语》当中，让大家知道子贡的一个小缺点，但是同时也增加了子贡的知名度。\n这句话为什么要选呢？我最近被很多新闻刷屏，大家都说2021年是吃瓜之年，大家都在拼命地吃瓜，觉得瓜多得吃不完。每天掉下来那么多的瓜，跟你有什么关系？那是人家的生活。那是他的错误也好，他的命运也好，或者是他的道德水准也好，你真的比他强那么多吗？然后你真的通过说他就能够伸张社会正义吗？\n我们每天费了好大的力气，看那么几个明星，今天这儿出事了，明天那儿出事了。我就整天在心里边讲着“夫我则不暇”，没那么多闲功夫，有这功夫你读点书多好，你做点有意义的事。你跑跑步、锻炼锻炼身体，你去帮助一些需要帮助的人，你哪怕喂个流浪猫、流浪狗都好过你整天在背后说别人坏话，没必要。\n花太多的力气去看别人的笑话，其实就是我们的大脑没有足够进化的标志。你知道为什么原始人喜欢干这事？越原始的人越喜欢盯着别人的缺点错误，然后不断地狂欢。他太需要得到社会的认同，他太需要得到群体的接纳。当发生了一件事，你不表态，那你是不是跟我们不是一条心呢？所以，我必须永远站在绝大多数的那一边。\n但是，现在这个社会已经不是原始社会了，我们不会因为说我没有表态这件事情，我就死了，不至于。这是我们从原始社会留下来的习惯而已，这个习惯使得我们特别喜欢八卦，使得我们特别喜欢挑别人的错，特别喜欢看别人倒霉，幸灾乐祸、落井下石，干这样的事。\n但是如果你像孔子一样，是一个冷静的人，孔子的大脑皮层一定是发育得特别好。他的冷静程度，你就经常会觉得这个人是没有杏仁核吧。就是他不会有杏仁核的发动，突然之间跟人打架什么这样的事，他永远是冷静的、理智的、幽默的、有创造力的，他是一个社会化了的人。但是如果我们天天狂欢于别人的倒霉，我们就是一个缺乏社会化的人。所以提醒大家“夫我则不暇”，时间很有限、很宝贵，每个人能分到身上的一天只有二十四个小时，所以要多干一点有价值的有意义的事。\n看到了那样的新闻，你乐一下、高兴一下也就过去了。不要那么狂欢，那个是耗费精力的事，而且也确实缺乏善意。《了不起的盖茨比》大家读过那个书的开篇，作者就讲“我的爸爸告诉我不要轻易地评判任何人”，因为你没有跟他们有过同样的经历，你所经历的跟他们经历的不一样，你不知道细节。所以，“子贡方人。子曰：‘赐也贤乎哉？夫我则不暇。’”\n接下来我们到《卫灵公》这一章，这个《卫灵公》篇，我选了四句，因为这里精彩的话也是特别多。“在陈绝粮，从者病，莫能兴。子路愠，见曰：‘君子亦有穷乎？’子曰：‘君子固穷，小人穷斯滥矣。’”\n“君子固穷”这句话，大家应该都很熟悉。因为我们上高中的时候学过一篇课文叫《孔乙己》，大家老嘲笑孔乙己，说孔乙己穷，孔乙己就敲敲桌子跟他们讲”君子固穷”，就从这儿来的。\n“在陈绝粮”就是孔子到了陈蔡这个地方，绝粮了。“绝粮于陈蔡，从者病，莫能兴”，因为那时候遇上战乱，周围在打仗，粮食也运不进来，大家就饿得已经起不来了。“莫能兴”就是坐都坐不起来了，所有跟着孔子的人都已经没劲了。然后“子路愠见”，子路很生气，走进来很生气地跟孔子讲：“君子亦有穷乎？”就是说你整天教我们做君子，整天教我们君子之道，跟我讲那么多的大道理，把我们带到沟里来了，穷成这个样子，我们今天走上穷途末路了，你看到了没有。\n子路对于孔子所教给他的东西，有可能产生了怀疑和动摇。其实我估计很多学生都有这样的动摇，就觉得我们这个“道”实行不下去了吧。但是没有人像子路这么快人快语。子路是一个脑回路特别直的人，所以直接进来就跟孔子讲：“君子亦有穷乎？”子曰：“君子固穷，小人穷斯滥矣。”你看孔子的杏仁核没有发动，他没有被这个子路带动，说要不然你走，不会。\n孔子说“君子固穷”，什么叫“君子固穷”？君子就算是遇到了这样的穷困，我们也能够固守我们的操守、我们的原则、我们的道德底线，这个叫“君子固穷”。\n“小人穷斯滥矣”，就是小人一旦走到穷途末路，就无所不用其极了，他就想干什么就干什么，为所欲为，抢劫 、杀人、偷盗都有可能做出来。所以这句话给了我们特别大的激励。我们心中经常会担忧：我们的人生有没有可能也会有一天走到穷途末路？有一天也会走到“绝粮于陈蔡”这样的境地？\n我有一次跟我的朋友聊，我说大家都说我心态好，好多人说我心态好会不会是因为我的物质条件挺好？我没受穷，周围的环境很好，所以我心态好。假如我真的像孔子一样“绝粮于陈蔡”，房贷也还不上了，房租也交不起了，看到孩子要交学费拿不出钱来，那个时候你还能不能够保持这么好的心态？这就是这句话给我带来的拷问。\n你能不能够“君子固穷”，然后“小人穷斯滥矣”。我们该固守的操守，我们该有的道德、品性，对他人的态度能不能够保持下来？甚至这种从容的态度，孔子在“绝粮于陈蔡”的时候，依然能够这么从容，说出这么智慧的话，就说明他是处在快乐当中。\n《梁漱溟先生讲孔孟》里就讲到“孔子不找”，他的快乐不需要向外找，他随时随地淡定、快乐、从容。他的快乐不在于钱，甚至不在于能不能吃得饱饭，而在于“道”。所以，孔子讲“朝闻道，夕死可矣”。就是能够闻“道”，死了也没关系。“道之不行也，知之”，就是“道之不行”，这事我已经知道了。但是没关系，我该做的事我还要做：“人能弘道，非道弘人”。所以，“在陈绝粮，从者病，莫能兴。子路愠见曰：‘君子亦有穷乎？’子曰：‘君子固穷，小人穷斯滥矣。’”\n接下来这句话讲的是史鱼，史鱼是卫国的一个大夫、卫国的一个官员，孔子在卫国待了很长时间，跟着卫灵公，所以孔子认识很多卫国大夫，像蘧伯玉、史鱼这样的人。子曰：“直哉史鱼！邦有道，如矢；邦无道，如矢，君子哉蘧伯玉！邦有道，则仕；邦无道，则可卷而怀之。”我为什么选这句？这句就是我们讲的“反脆弱”，会杠铃式配置的人是具有”反脆弱”能力的人，无论是“邦有道”，还是“邦无道”，他都能够活得很好。\n如果一个人说，我把所有的宝全部都压在这个君主身上，这个君主好，我就跟着他一块儿干，这个君主不好，我就完蛋。他变成杠铃的一头（意思是把鸡蛋放在一个篮子里），他没有做杠铃式配置，这时候你发现他的人生会变得很脆弱。只要环境发生了改变，政治的氛围发生了改变，这个人可能就没法再去做事了。\n孔子举这两个人的例子说：“直哉史鱼”。史鱼这个人的特点是“直”， “直”是一个好事，但是如果只有“直”就不够。史鱼说“邦有道，如矢”，如果这个国家特别好，这个人像箭一样，射出去的那个箭，“如矢”。 “邦无道，如矢”就是国家不好，政治昏暗，他依然是像箭一样地射出去。那这种人的特点是什么呢？他一定会折断。你看唐朝的时候，最昏暗的时期应该是李林甫、杨国忠那个时候，后来导致了安史之乱。\n李林甫能够只手遮天到什么程度？这人口蜜腹剑、只手遮天。杜甫他们参加科考，考完了以后一个都没选。整个一场科考考完，一个及格的都没有，全都没有选。然后报到玄宗那儿说这个一个都没选，玄宗说：“怎么回事？怎么会？这批学生这么差吗？”李林甫说：“野无遗贤呐，不是学生差，是皇上你厉害。”“为什么？”“你太棒了！咱们这个政府现在这么厉害，野无遗贤，市场上已经没有好人不被我们用的了，所有的好人都已经被我们用了。所以这次考试选拔不出来。”\n你看，怎么说都行，连这样的说法都能够过关。你说你在这样的一个朝廷之上，然后你去跟人家对抗，你什么事都站出来直说，到最后的结果就是很多大臣最后都不得其死。有的被杖毙、有的被流放、有的被刺死。你没法保身，你想你为这些事牺牲了自己的生命，不值当。其实，你还可以有很多事要做。但是你一直都像一个箭一样这么直。\n孔子对史鱼的命运表示了担心，“邦有道”“邦无道”，这是不一样的。然后“君子哉蘧伯玉”，你看蘧伯玉的这个评价高，他是个君子。因为君子不光是有“直”，君子还有智慧、仁德、勇敢，叫“智、仁、勇，三达德”，这才叫君子。这个蘧伯玉，“邦有道，则仕”，国家如果好的话出来当官，因为我愿意跟这些人在一起好好当官。“邦无道，则可卷而怀之”，当国家不行、完蛋、混乱、奸臣当道的时候“卷而怀之”，卷起来回家教书去，当个老师、算命先生或者医生等等。总之他能够活下来，把这个火种先保留下来。然后慢慢地教学，慢慢地发扬道德精神。\n你看孔子就是这样一个人。孔子是“邦有道德，则仕；邦无道，则可卷而怀之”。人家不让他当官了他没有说跟人拼命，说不让我当官我死给你看，没有，孔子说不让我当官，祭祀的时候的肉都不分给我，就摆明了是给你脸色，不让你好好干了。孔子拉着车到边境，到了边境线并没有直接就走，在边境线待了三天，等着，万一那边再把肉送过来呢？我就可以再回去。孔子是一个非常有弹性的人，到了边境线待了三天以后，发现肉还是不来，算了，还是周游列国吧，这才走的。\n他能够找到自己安身立命的地方，他讲“君子不器”，他不是一个当官的料。我们说这人是块料，那就是他是个东西，这个东西能干吗？这个东西能够当官，你看他就变成了东西了，那假如没有官给你当呢？那这个人就什么都做不了了。但是孔子认为我不是一块料，我不是一个东西，我可以当官，官当不了我可以教书，书教不了我可以写歌，写歌写不了我可以开车。孔子是礼、乐、射、御、书、数都会。所以，他的人生的反脆弱能力极强。这就是他适合成为教育家的原因。\n希望大家也可以考量一下你所在的单位。有一次有个人问我就说，我们单位的领导不行，我要不要跟他一块儿干？我说你这个说得有点笼统。首先你说你们单位的领导不行，这个判断准确不准确？就不一定。然后如果只是我们自己不行，却认为是单位的领导不行，那你换了任何岗位，你会遇到更多不靠谱的领导。另外这个不行是哪里不行？是能力不行还是道德不行？如果是能力不行大家可以帮忙，可以一块儿使劲。如果这个人价值观有问题，在骗人在搞诈骗。然后你还要跟他一块儿干，那叫为虎作伥，就危险了，你都得考量。\n这就是”邦有道，邦无道”。你自己决定你是该跟他一起做呢？还是应该赶紧离开，不要再为虎作伥。所以人生的杠铃式配置是一个智慧，这个是特别重要的一件事。子曰：“直哉史鱼！邦有道，如矢；邦无道，如矢。君子哉蘧伯玉！邦有道，则仕；邦无道，则可卷而怀之。”\n接下来这句话是我们推荐大家读书的时候最常用的一句话。子曰：“吾尝终日不食，终夜不寝，以思，无益，不如学也。” 孔子说我曾经“终日不食”，一天到晚什么也不吃，“尝”在古文当中就是曾经。然后“终夜不寝”，一晚上睁着眼睛不睡觉，“以思”就思考这个大问题，思考宇宙、思考苍生这样的大问题。“无益”搞了半天啥也没想明白。“不如学也”，你不如找两本书来看一看就解决了。这个确实，孔子讲“学而不思则罔，思而不学则殆”就这个道理。就是学和思是要配合在一起的。\n但是你不能没有学去思。牛顿说，如果说我有点成就的话，我也是站在巨人的肩膀上。如果你把牛顿的东西真的多读几遍的话，你会发现牛顿站在了太多人的肩膀上。我们都以为微积分是牛顿发明的，或者牛顿跟莱布尼兹同时发明的。实际上，从两千多年前，阿基米德就有了微积分的概念。然后一直到中间伽利略、开普勒、笛卡尔、费马这些人不断地在这个上面添砖加瓦，给牛顿铺垫好了特别多的工具。所以，牛顿到最后突破的那一刻，是使用了前人大量的工具作出最终的突破。这就是叫作“不如学也”。\n牛顿之所以有这个突破的可能性，是因为那时候刚好赶上黑死病。然后他就回到了老家，把能够找到的数学书全部都看了一遍。牛顿那时候，全世界的数学反正也不多，还没有发现微积分，所以数学是有限的。他把能够找到的数学书全都读了一遍。然后在这个基础之上，才突破了这个微积分最难的那些关口，打造了一个完整的工具。\n所以孔子讲，没事别一天到晚瞎琢磨，瞎琢磨得太多，会浪费特别多的精力，不如先多读书。王阳明年轻的时候听别人讲“格物致知”，学朱熹，然后就说咱们“格物”吧。王阳明跟一个朋友俩人一块儿对着竹子，格这个竹子，就是看这个竹子要看出理来。这个竹子当中的义理到底是什么？连着看了几天几夜，差点把命要了，就直接晕倒了。这营养不良跟不上，心脏病什么等等，就差点死了。后来王阳明说“格物”没用，说拿这个竹子看不出什么道理来，王阳明老老实实读书。当他读了大量的书以后，他才创立了心学。就是这个道理。\n有个很有名的公案，一个女学生给杨绛先生写信，述说自己人生的烦恼，她觉得非常烦恼，看不惯这个社会，看不惯男人，看不惯一大堆……这样的信写过来。杨绛先生回信说，你的所有问题都在于烦恼太多，而读书太少。你不读书，我跟你讲道理都不知道从哪讲。因为你的认知的差距太大，跟你说什么事你都不知道，劝你都没法劝。所以最有效的办法是赶紧先读书，多读点书以后，最后就会产生一个化学反应。\n你看我们在卖书的时候，有很多人留言：“樊老师多卖点有用的书”。我说：“啥叫有用的书？”如何演讲？如何提高情商？然后如何谈判？他们认为这些是有用的书。你多卖点这种书，别老卖历史、哲学什么的。然后我就经常讲，历史这个玩意有一个最大的特点就是你不知道它啥时候起作用，你就读就好了，读多了，有一天你会突然把它和一个哲学问题联系在一起。然后发现这历史上不就是这样吗？\n而如果一个人脑子里面完全没有那些知识，没有那些历史、地理、政治、哲学这样的常识，老想通过一些工具手册告诉你，只要做好这三步，你就能够怎么怎么样，你就永远都在低水平地跟别人博弈。我们很多人喜欢读那些走捷径的书，都是教你怎么跟别人博弈的，你花了大量的力气跟别人博弈，并不能够给你带来太多的进步。因为层次没有提高，就在这个层次上今天我赢了一点，明天我输了一点，我改善点技术就能够变得更好，那它只是在同一个平面上让你优化。\n但是读那些不知道起什么作用的知识，甚至读了一本小说，读了一本宗教的书，它可能会让你突然之间到达另外一个层面。到达另外一个层面以后，你会发现之前所纠结的那个事不再是个事了。解决一个问题最有效的方法是使得这个问题不再是一个问题，而不是真的解决它。这是特别有意思的一个观点。\n你看传呼台的优化，怎么把一个传呼台干得更好？那些问题在今天毫无价值了，因为传呼台没有了，我们让它不再是一个问题了，这才是彻底地解决了问题。所以孔子告诉大家说别整天瞎琢磨，别一天到晚那么痛苦，像个哲学家一样这样沉思，有功夫多读书，读着读着可能就豁然开朗了。所以，子曰：“吾尝终日不食，终夜不寝，以思，无益，不如学也。”\n接下来这句话是我的座右铭，帮助我度过了人生最缺钱的时候。那时候在电视台打工，很焦虑，还房贷老还不上，压力很大。然后就老觉得万一这个节目没有了，这房贷可就还不上了，就紧张，压力很大。子曰：“君子谋道不谋食。耕也，馁在其中矣；学也，禄在其中矣。君子忧道不忧贫。”你如果立志想要成为一个仁人君子，你想成为一个追求形而上的人，对自己有道德要求的人，你应该谋求的是“道”。什么“道”呢？你是不是在努力地接近宇宙的真相？你是不是在努力地了解这个世界是怎么运转的？你所做的这些行为是不是对这个时代有意义，在帮助这个时代前进？这些事都是很大的问题。\n但是这些大的问题能够解决我们生活当中的痛苦。好多人觉得哲学没有用，觉得哲学不如赚钱来得有效。但是赚钱越多痛苦越多，如果你一天到晚只想着赚钱这件事，你发现很多人很有钱，但是照样很痛苦。大家都见过吧，很多很有钱的人过得很痛苦，思考那些大而无当的，跟“道”有关系的话题，读《庄子》《老子》《论语》《亚里士多德》《牛顿》这样的书，对你的生活看起来没什么用，但它能够安慰你的灵魂，它能够让你突然之间觉得好安静，觉得那点钱不是什么大问题。因为你的格局和视野放大了。\n所以孔子讲：“君子谋道不谋食”，君子每天要努力探索的是“道”而不是“食”。 “食”代表物质，代表吃的这个东西，为什么呢？如果你就耕地，我为了挣钱、安全感选择天天耕地，“馁在其中矣”，就是你照样会饿肚子。最勤奋的那些农夫，在饥荒发生的时候也一样吃不饱饭。因为“耕也，馁在其中矣”，你看起来是天天都在努力地工作，天天在努力地挣钱，你该受穷的时候你还是会受穷。然后”学也，禄在其中矣”，看起来这个人整天钻研什么事，不知道在干吗呢？他该赚钱的时候照样会赚钱，他一样能够获得报酬。\n在孔子的那个时候，一个人想要靠学问获得报酬不是一件容易的事。因为那个时候主要还是靠耕地。但是今天你会发现，大部分人都是靠学问在赚钱。靠体力劳动在赚钱的只能够拿到这个市场的平均价格，不会特别高。靠认知水平赚钱的人，可以拿到十倍、百倍于别人的收入，这就是现在这个社会的特点。因为全部都是知识经济，谁的认知水平跟别人不一样，有差距，谁赚钱多，就是这样。所以孔子说你别整天光想着钱，光去耕地，该挨饿的时候照样挨饿，你每天努力地学习也有赚钱的机会。\n最后一句叫“君子忧道不忧贫”。所以你也不用为还不上房贷这件事太过担忧，担忧也是分散精力、损伤元气的东西，过度的担忧会使得你生病，搞不好会得重病。那“忧道”的时候你就开心了，因为想不明白的时候都挺开心，想明白了更开心，有一点小得就开心得不得了。\n所以你看牛顿在算那些他的数学原理的时候，好多人看牛顿的工作量觉得不可思议，咱们现在求对数都是拿计算器求对数，“啪”地一下出来了。牛顿是拿手求对数，求几十上百个不同的对数，用手算一个一个地算出来。然后牛顿自己跟别人讲说，我都不好意思说我算了多少遍，因为它实在太好玩了。他实在是太喜欢算这些东西了。\n你就想想看一个“忧道”的人是多么快乐。孙悟空在他师傅那儿听讲的时候，突然之间手舞足蹈跳了起来。然后师傅问：“你干什么呢？这个泼猴。”这个孙悟空说：“法喜充满。”就是听得高兴了，就突然之间意解心开，就受不了了。所以如果一个人能够“忧道”，你每天想一些规律、大事、哲理、历史，就很开心，不要为房贷这样的事太焦虑。\n因为那个东西确实有时候是有运气的成分，当然你要努力做事，要负责任，这个是要做的。但是你也得知道，运气的成分也会造成收入的波动，反过来你心态如果变得更好，你不断地通过学习提高自己的认知水平，你赚钱的能力反而会变得越来越强。所以子曰：“君子谋道不谋食。耕也，馁在其中矣；学也，禄在其中矣。君子忧道不忧贫。”\n好了，接下来这一篇叫《季氏》。这一篇的第一句话我选的是叫“益者三友”。孔子曰：“益者三友，损者三友。友直，友谅，友多闻，益矣。友便辟，友善柔，友便佞，损矣。”孔子说，好的朋友、有益的朋友有三种，然后有损害的朋友有三种。“损友”，\n我们现在经常讲“最佳损友”，这个人是个“损友”，就是他是给你捣乱的，他是会给你带来伤害的。\n哪三种人是好的朋友呢？“友直，友谅，友多闻”，“友直”就是他有事直说，他看到你的问题，缺点和错误，他可以告诉你。“友谅”就是这个人说话算数、靠谱，“谅”这个词的意思就是诚信。然后“友多闻”，这个人喜欢学习，掌握的知识很多，一个人正直、诚信又好学，这样的人是好朋友。\n然后这个“损友”，“友便辟，友善柔，友便佞”。”、“便辟”是谄媚，这个人跟你老说好话，在你面前整天拍你的马屁，让你高兴。我们确实也见过这样的朋友，他就是有一种讨好型的那种趋势。\n然后，“善柔”就是心不对口、口是心非。他想的东西他不说，他老把自己的想法都隐藏起来，老觉得自己好像不应该表示。所以你不知道这个人在干吗，这人城府很深，想什么东西也不知道。\n然后“友便佞”，花言巧语、巧言令色、喜欢抬杠。然后为一些没有意义的事不断地辩论，这叫作“便佞”。所以孔子说，如果一个人谄媚，口是心非，同时喜欢没事干瞎抬杠，那这些人有害，损矣。为什么损呢？他会误导你对自己的判断，他会浪费你大量的时间，他会激发你好面子、好斗的这个心。\n而“益者三友”的特点，我们讲过一本书叫作《他人的力量》，专门讲第四种人际关系的。那本书很多人看完了以后，就立刻发给自己身边的朋友看，说我们应该成为“第四种人际关系”。 “第四种人际关系”的特点是我能够看到你的优点，我能够看到你的长处，该鼓励的时候我一定会鼓励。但是如果你有问题，我也会非常直接地讲出来。这时候你发现你跟朋友之间才能够不断地互动，才能够共同进步。\n大家筛选朋友的时候，因为孔子讲“无友不如己者”，我们在上篇当中曾经讲过有些朋友是我们可以选择的。“友”是个动词，就是你愿意跟谁交往，这个是我们可以选择的。你应该努力地去跟那些能够给你带来帮助的人交往，未必是他的财富比你高，未必是他的名气比你大。但是，你要看他是不是“友直，友谅，友多闻”。然后你要远离的人呢？就是“友便辟，友善柔，友便佞”这样的人。所以孔子曰：“益者三友，损者三友。友直，友谅，友多闻，益矣。友便辟，友善柔，友便佞，损矣。”\n接下来这一段是孔子对人群做的一个分类，做教育工作的人经常会引用。孔子曰：“生而知之者，上也；学而知之者，次也；困而学之，又其次也；困而不学，民斯为下矣。”孔子说学习的人分四类，第一类人，“生而知之”，最上层的，这种人不用教，生下来就会了。\n我不知道孔子有没有见过这样的人，孔子有可能说的是老子。因为孔子见过老子，在洛阳向老子问道。他说老子“其犹龙邪”，老子像龙一样。老子他为什么会突然之间冒出那五千言，然后写下来。到今天每个字至少都有几万字在做注解。大家在玩命地研究老子，他怎么就那么智慧，他是一个研究复杂问题的大师。然后甚至能够说中很多东西，跟今天物理学研究的宇宙的发端都是一样的。那这种人你说是谁教出来的呢？当然我们不知道老子的求学经历。所以孔子可能认为这样的人叫生而知之。\n然后“学而知之者次也”，就是一个人好学，生下来就有一颗好学的心，保持着好奇心，一直到老一直学一直学，这个叫作“次也”。这种人，是第二等的。\n你看牛顿就是这样的人，牛顿生下来他肯定不是“生而知之”。牛顿是一个不怎么爱学习的人，上学的时候都瞎混，然后老师的评语对他并不好。但是后来慢慢地整天学，变成这样。我们说爱因斯坦是天才，你看了《爱因斯坦传》就会发现，爱因斯坦也是天天学，学了很多东西，最后变成了爱因斯坦。\n孔子也是，孔子说自己肯定就是第二等。因为孔子说我这个人别的没有，我就是好学。“十室之邑”这附近的小村子，没有比我更好学的人，这是孔子很自信的说法。所以一个人如果愿意主动地学习，这个最起码第二等，叫“学而知之者次也”。\n第三等是什么呢？叫“困而学之，又其次也”。什么叫“困而学之”？就是不学不行，这事放在这儿，你不学，你就很痛苦。你比如说我为什么去学亲子教育的东西？就是因为要当爸爸了。要当爸爸了，突然发现自己很恐慌，什么都不会，完全不知道怎么当爸爸。我就把当爸爸的书全都找来读了一遍，读完了以后，学会了，解决了问题。这个叫作“困而学之”。有的人说我要找工作，我要当个律师，当律师你得考试，这就是“困而学之”。因为司法考试而开始学习，然后学上了。这个是第三种，“又其次也”。社会上大部分的人，你困了能够去学就不错。\n最后一种人最可怜，孔子讲“困而不学，民斯为下矣”。这些真正最后混得最惨的人是怎么回事呢？“困而不学”，已经困住了还不学习。你比如说大量的家长觉得跟孩子互动已经是一个非常痛苦的事。但是你说你去读两本书吧，读那玩意有什么用？没用。他认为就是做得不够，或者他总结出来“就这个孩子怪，我们家这孩子不好管”。你看，好多人喜欢把责任推到外在，推在别人身上。最后导致的结果就是你被困住了。\n因为“困而不学，民斯为下矣”。他被困住了还不愿意通过努力去改变自己。所以，孔子曰：“生而知之者上也，学而知之者次也；困而学之，又其次也，困而不学，民斯为下矣。”大家可以对照一下。\n然后到《阳货》篇。《阳货》篇的第一句：“子曰：‘唯上知与下愚不移。’”这句话我觉得是孔子受挫以后说的话。因为孔子整天教人，教这个、教那个，有人能教，有人教不了。遇到那些教不了的人，孔子教育无效的这部分人，孔子就总结说为什么无效呢？“上知与下愚不移。”“上知”是什么呢？顶级聪明的那些人。“生而知之”那批人，我们把两句连在一起看，你就会发现特别有意思。\n孔子要想教老子不容易，孔子跟老子一对话，孔子说我在学理，问周朝的理能不能跟我讲讲。老子说，你说的那些理，讲理的人都腐烂掉了，那些人都早死了，你还学那玩意干吗？张开嘴看看，你看我嘴里边什么情况。孔子一看，嘴里边有舌头，牙齿没有了。“刚强者死，柔弱者生”，牙齿很刚强，早早就死了，舌头很柔软，活了这么长时间。所以你别搞那些东西。孔子教不了老子，这种人叫“上知”。就是已经特明白、特通透的人，孔子说这教不了。不改，他改不了。因为他已经达到那个境界了，他不需要改了。\n我有时候经常就想说咱今天读了这么多的书，现代的这么多书，除去微积分，除去科学这部分东西之外，就现在的一些哲学道理，咱们如果见了孔子，咱能教他点什么呢？咱能不能教孔子说，你应该这样，你应该那样，你发现没用。因为他已经到了“上知”的地方，他已经找到那个东西了，这种人不会改变，也不需要改变。然后“下愚”，最下面那层人，不改变，你跟他说什么没有用，都不听。因为他的全副精力都在应付那些最基本的生存问题，这其实也是一个相当让人感慨的事情。\n我们讲过《贫穷的本质》那本书，那本书里面就讨论是不是真的有一个东西叫作“贫穷的陷阱”。当一个人身处在贫穷的陷阱当中的时候，你劝他读书、你劝他学习是没用的。因为他爬不出来，他每天从头到尾不停地工作，都食不果腹，这就是“贫穷的陷阱”。所以，这时候需要我们伸把手拉他一下，把他从“贫穷的陷阱”里边拉出来。这时候才有可能走上致富之路，这就是为什么要扶贫的原因。所以，“扶贫先扶志”也是这个道理，如果你把他拉上来了以后，你应该首先让他改变认知。认知改变了，他才能够自己去努力。否则如果养成了一个被别人救济的习惯，那这个人依然不会带来人生的变化。\n所以孔子讲“唯上知与下愚不移”。人生经常会有这样的分段，你看《世说新语》里边的王戎，王戎有一个孩子死了，死了以后他就痛哭，哭得特别难过，你知道魏晋时期大家都讲究雅量与放旷吗？所以旁边朋友就问：“你是哭得也太过分了，你作为一个名士，孩子死了哭成这个样子，不至于吧，别这样。”王戎说了一句话，我觉得就是从孔子这句话里出来的。王戎说：“圣人忘情，最下不及情，情之所钟，正在我辈。”\n你看，“圣人忘情”，庄子老婆死了，“鼓盆而歌”，他已经忘记这个情了，无所谓，都行，生不带来，死不带去。她来的时候，她来之前她都不知道在哪儿，现在她回到她去的那个地方了。所以看透生死了。“圣人忘情，最下不及情”。\n苏东坡到黄州的时候，黄州的老百姓生了孩子，就扔到城墙外头就不养，生下来往城墙外边一扔，因为养不起。所以，苏东坡专门写一篇文章，劝大家不要扔孩子，“最下不及情”，他根本没精力思考这个事。“情之所钟，正在我辈”，最容易动感情，最容易难过的就是我们这些稍微读了点书、有点文化的，就会特别容易投入感情，特别容易难过，就跟孔子讲的一样，“唯上知与下愚不移”。\n《阳货》的第二句话我选的是：“子曰：‘道听而途说，德之弃也。’”这个话是我自省的话，我其实过去特别喜欢道听而途说。道听而途说的特点是什么呢？走在道上听到了别人说一个事，还没回家就跟别人讲了。那为什么很多人喜欢道听途说？包括我们现在网上很多这种新闻、假消息不断地流传。我们太渴望获得他人的认可，太渴望获得社交货币。\n你看到了一个惊悚的消息，你只要把它发布出来，就会有人点赞，就会有人看。所以你就觉得自己的价值感好像又提高了一点，这个都跟我们原始社会的时候对于集体的那种安全感的追求是有关系的。所以你才会忍不住“道听而途说”，贩卖这些不知所谓的消息，为了能够让别人多看你一眼。最起码你回到家冷静下来，消化一下，判断一下真假，让子弹先飞一会儿，然后你再参与讨论，甚至有些话题想想看就不需要讨论。\n所以，中国古人经常讲说你少说点话，为什么呢？说一句话之前，问自己三个问题。第一个问题问自己：“这事真的还是假的？”如果是假的，你就别说了，如果是真的，你可以说。是真的，再问自己第二个问题：“你说这个话是出于善意？还是恶意？你说这话是为了别人好？还是为了看别人笑话？”想想看，如果是为了别人好，你说，如果是为了看别人笑话，你就别说了。好了，这事是真的，也是为了别人好。再问自己第三个问题：“你说这个话有没有用？”有用你再说，没有用你就不用说了。\n所以基本上一段闲话，你把这三个问题问完，大部分都不用说了。所以孔子有一天都感慨：“予欲无言”，我以后打算不说话了，没什么好说的，说“天何言哉”，你看老天爷啥时候说过话，但是四季分明，周转得这么有规律。所以我们有时候真的未必要获得那么多的社交货币，未必要获得那么多别人的点赞和关注。所以子曰：“道听而途说，德之弃也。”这是在互联网时代特别需要我们每一个人去警醒的话题，很多是非就是道听而途说产生的。\n接下来《微子》最后这三篇都有它的特点，像《微子》这一篇主要讲的都是那些隐士。桀溺、长庚、荷蓧丈人，都是那些在乡野当中的隐士。所以很多都是故事，读起来很有意思。但是跟大家的生活当中的联系没有前面那么多，所以我在这里边只选了一句。在《微子》这一篇，我选了一句是柳下惠的。柳下惠为士师，三黜。人曰：“子未可以去乎？”曰:”直道而事人，焉往而不三黜？枉道而事人，何必去父母之邦？”柳下惠是个很明白的人，柳下惠大家都知道坐怀不乱，就是一个女人坐在他腿上，他照样一本正经。柳下惠曾经当过典狱长，“为士师”， “士师”就是典狱长，管监狱。\n“三黜”，三次都被罢免了。各位你知道监狱这个事不好管。因为监狱是一个政治斗争集中的地方。这个人关进来，你不要以为都是小偷才会关进来，很多关进来的是大官。所以他作为一个监狱长，其实是一个非常关键的岗位。但是，他在这个岗位上被人罢免了三次。\n后来有一个人劝他说：“子未可以去乎？”你干吗不走呢？你去别的国家待着，你这鲁国不行去卫国，卫国不行去齐国，总能够找到一口饭吃的地儿。\n你看柳下惠怎么说的，柳下惠说：“直道而事人，焉往而不三黜？”如果保持这样的正直，我用这样正直的方法来跟别人相处，我去哪儿不会遇到这样被罢黜的机会呢？天下乌鸦一般黑，这个体制就是这样。所以我在这儿管监狱会被罢黜，到卫国管监狱一样会被罢黜。\n然后“枉道而事人”，如果你让我学得灵活一点，你让我八面玲珑，什么样的要求我都能够接待，都能够满足，“何必去父母之邦？”我干吗要走呢？你看，两头堵。如果我真的是那么八面玲珑的一个人，我根本就不需要离开这个地方，如果我就保持现在这个正直，离开这个地方也没用，所以不去，我就等着四黜、五黜。说明柳下惠真是个人才，否则的话一黜就结束了。他黜下去又提拔上来，再下去又提拔上来，无怨无悔，接着“直道以事人”。当然我们也可以反思一下柳下惠的这个态度。\n孔子讲像柳下惠这种人不是“中道”。如果是“中道”的话，那是孔子讲“君子哉蘧伯玉”，叫“中道”。柳下惠这种人属于“狂狷之士”，他的特点是什么呢？他有点奇怪的原则，你看他这个话里面的逻辑漏洞在哪儿，逻辑漏洞就在于柳下惠认为全世界都一样。我们中国古人讲叫“树挪死，人挪活”，啥道理呀？“树挪死，人挪活”就意味着你去到了一个合适的地方，你是可以发挥作用的。\n但是柳下惠不认为这个世界上有合适的地方，他认为哪儿都一样。所以我就这儿也不去，那儿也不去。这话听起来很痛快，实际上逻辑上有缺陷。我们劝大家不要学柳下惠。如果你发现这个地方不能够发挥你的作用，你可以尝试找到一个更合适的地方。你想想看达·芬奇那个时候，如果不是在佛罗伦萨怎么可能推起文艺复兴？这就是不同的地方是完全不一样的。所以没事出去多走走是有好处的，这是《微子》这一篇，我们只选了这一章。\n然后《子张》这一篇主要记录的是子张、子夏，包括曾子这些孔子的学生的言论。因为他们也有学生，《论语》是孔子的学生和学生的学生编辑出来的。这里边我选了子夏的一句话。因为子夏这句话讲的是他所看到的孔子，让我们从第三者的角度看看孔子是一个什么样的人。子夏曰：“君子有三变：望之俨然，即之也温，听其言也厉。”这个话我很喜欢。他把孔子的形象给刻画出来了。\n他说孔子有三个不同的变化，“君子三变”，三个状况不一样。第一个叫”望之俨然”，就是远远看过去觉得好严肃啊这个人，这个人好像不太好接近，一股凛然正气的那种气场远远地走过来。然后“即之也温”，你真的跟他一打交道一聊天，发现很温和、挺和蔼可亲的这么一个人。然后”听其言也厉”，你听他一说话发现这人厉害，这个”厉”是什么呢？就是直接切中要害。\n为什么孔子会成为这样的一个人？其实“望之俨然”是端庄，就这个人很端庄，这个人他已经养成了这样的习惯。然后坐得直、走得正。他的气质决定了“望之俨然”，他不会一边走路一边嘻嘻哈哈，勾肩搭背。然后“即之也温”，修养好。无论是跟上位的人，还是跟下位的人说话，我都能够保持一个温和的态度，我不会傲慢。因为“君子泰而不骄，小人骄而不泰”就是这个道理，“泰而不骄”就是他很舒服，他不需要骄慢，“骄而不泰”就这人使劲地骄慢，但你知道这个人内在不稳定。\n所以“望之俨然”是外在的，“即之也温”是内在的。然后“听其言也厉”没什么废话，说话切中要害。因为他真的有智慧。一个人内外兼修，还有智慧、有知识，这就是孔子在子夏心中的形象。希望大家能够沿着这个方向去打造自己的人设。子夏曰：“君子有三变：望之俨然，即之也温，听其言也厉。”\n最后一篇叫《尧曰》。《尧曰》这一篇往往是被大家不太重视的。因为它里边有很多大家听不懂的，我在这本书里边也都逐字逐句地进行了解释，我在这一篇里边选了最后一句话，整个《论语》的最后一句话。我觉得这个跟第一句话是呼应的。孔子曰：“不知命，无以为君子也；不知礼，无以立也；不知言，无以知人也。”\n你看孔子的第一句，叫作：“学而时习之，不亦说乎？有朋自远方来，不亦乐乎？人不知而不愠，不亦君子乎？”就是告诉大家学习的重要性。然后自修、共修，最后修成的那个境界，到最后一句孔子曰：“不知命无以为君子。”你说你学了那么多，到最后怎么突然变成了一个虚无主义的“不知命无以为君子”呢？一个人必须得知道命。实际上如果你读书，真的读了特别多特别多以后，你要学会接纳不确定性。“不知命无以为君子”讲的就是不确定性这件事。我们当然可以努力，我们可以做正向的、积极的尝试，我们可以不断地去学习、探索、进步。\n但是不确定性是永恒的。永远都会有很多东西是出乎你意料之外的，“出师未捷身先死”这样的事总是会发生，“长使英雄泪满襟”也是一样。所以如果一个人不知命，不接受不确定性，不知道复杂体系，不知道生物态，这个人“无以为君子”。为什么？小人相信刚性，他认为不存在不确定性，“刚性”只是我自己不会、面子不够等等，做很多的自责或者责备他人的行为。所以，古人说得特别好，叫“君子居易以俟命，小人行险而徼幸”。 “君子居易以俟命”，君子每天活得很从容，他相信不确定性，他在努力地工作，你放心，君子不可能浪费自己的时间，他在努力地工作。\n但是他接受命运的安排，什么叫命运？命运就是不确定性，他接受不确定性的发生。然后接着往前走，“小人行险而徼幸”，小人不相信命运，不相信不确定性。所以做什么事，都要尽量地钻营。如果得不到，他会憎恨社会，、憎恨自己、憎恨他人。\n然后“不知礼无以立”，就是你接纳了不确定性之后，你要能够学会跟社会上的人合作，礼是干吗的？“礼者”，理也。“礼”就是道理，看起来是礼仪，但其实是道理，为什么要有这样的礼仪呢？因为它符合道理。你比如说我们大家出门都靠右走，为什么靠右走？“道者”，道也。中国古人造字就很好玩。我们都靠右走就各自都能到达目的地。假如我靠右走，你非得靠左走，那咱俩就撞，咱俩就过不去。所以“礼者”，理也。\n我们为什么要做那么多礼？周公开始做那么多的礼，一直到春秋形成了整个中华民族的文化。因为它符合道理，这个道理就是能够让绝大多数人团结在一起的一个东西。所以，孔子说你不光是要接纳不确定性，你能够活得很坦然。同时你要知道你不要孤独，你要跟大家一起合作。然后“不知礼，无以立。”没法在社会上立足，最后“不知言，无以知人也”。你得会沟通，沟通怎么来的？学来的。从“学而时习之”开始，你要不断地听、不断地讲，能听懂别人的话，善于倾听，这时候你才能够了解别人。\n我们经常会觉得别人不了解我们，我们老觉得自己怀才不遇。但是孔子曾经说：“不患人之不己知，患不知人也”。我们不要担心别人不知道我们，我们要担心的是我们不了解他人，你多了解他人，你才能够找到更多的“第四种人际关系”，才能够找到更多的帮手，才能够把你的事干好。被别人了解是关注圈的事，了解别人是影响圈的事。所以，努力在影响圈里边做事，你的影响圈才会变得越来越大。\n因此到这儿你发现首尾呼应，从一开始倡导你学习，到最后告诉我们说学习的方向，是要能够做到这样的境界，这就是我从下半部《论语》当中为大家摘出来的二十句我觉得跟每个人的生活、工作都有关系的经典名言，希望大家能够喜欢！\n如果大家能够喜欢这其中的某一句，把它应用在我们的生活当中，我相信就一定会带来特别大的改变。谢谢大家，我们下周再见！\n","categories":["科普","樊登读书"],"tags":["论语","樊登"]},{"title":"SQL语法——SQL USE 语法","url":"https://lujw666.github.io/2021/03/10/sql-use/","content":"当SQL中有多个数据库时，在开始操作之前，需要选择一个执行所有操作的数据库。SQL USE语句用于选择SQL架构中的任何现有数据库。\nUSE语句的基本语法如下所示 :\nUSE DatabaseName;\n数据库名称在RDBMS中必须是唯一的。\n\n\n实例可以查看可用的数据库，如下所示：\nSQL&gt; SHOW DATABASES;+--------------------+| Database           |+--------------------+| information_schema || AMROOD             || TUTORIALSPOINT     || mysql              || orig               || test               |+--------------------+6 rows in set (0.00 sec)\n如果想使用AMROOD数据库，那么可以执行以下SQL命令并开始使用AMROOD数据库。\nSQL&gt; USE AMROOD;","categories":["SQL","基础"],"tags":["sql"]},{"title":"SQL语法——SQL UPDATE 语法","url":"https://lujw666.github.io/2021/03/10/sql-update/","content":"UPDATE 语句用于更新表中已存在的记录。\n可以使用AND或OR运算符组合多个条件。\n具有WHERE子句的UPDATE查询的基本语法如下所示：\nUPDATE table_nameSET column1 = value1, column2 = value2, ...WHERE condition;\n注意：更新表中的记录时要小心！要注意SQL UPDATE 语句中的 WHERE 子句！WHERE子句指定哪些记录需要更新。如果省略WHERE子句，所有记录都将更新！\n\n\nSQL UPDATE 实例以下SQL语句为第一个客户（CustomerID = 1）更新了“CustomerName”和“City”：\nUPDATE CustomersSET ContactName = &#x27;Alfred Schmidt&#x27;, City= &#x27;Frankfurt&#x27;WHERE CustomerID = 1;\n\n\n更新多个记录WHERE子句决定了将要更新的记录数量。\n以下SQL语句将把国家/地区为”Mexico”的所有记录的联系人姓名更新为“Juan”：\nUPDATE CustomersSET ContactName=&#x27;Juan&#x27;WHERE Country=&#x27;Mexico&#x27;;","categories":["SQL","基础"],"tags":["sql"]},{"title":"SQL语法——SQL DELETE 语法","url":"https://lujw666.github.io/2021/03/10/sql-delete/","content":"DELETE语句用于删除表中现有记录。\nSQL DELETE 语法:\nDELETE FROM table_nameWHERE condition;\n注意:删除表格中的记录时要小心！注意SQL DELETE 语句中的 WHERE 子句！WHERE子句指定需要删除哪些记录。如果省略了WHERE子句，表中所有记录都将被删除！\n\n\nSQL DELETE 实例假设我们想从”Customers” 表中删除客户“Alfreds Futterkiste”:\nDELETE FROM CustomersWHERE CustomerName=&#x27;Alfreds Futterkiste&#x27;;\n\n\n删除所有数据可以删除表中的所有行，而不需要删除该表。这意味着表的结构、属性和索引将保持不变：\nDELETE FROM table_name;\n或者\nDELETE * FROM table_name;\n注意：在没有备份的情况下，删除记录要格外小心！因为你删除了不能重复！\n","categories":["SQL","基础"],"tags":["sql"]},{"title":"SQL语法——SQL INSERT INTO 语法","url":"https://lujw666.github.io/2021/03/09/sql-insert-into/","content":"INSERT INTO 语句用于向表中插入新的数据行。\nSQL INSERT INTO 语法：\nINSERT INTO 语句可以用两种形式编写。\n第一种形式无需指定要插入数据的列名，只需提供被插入的值即可：\nINSERT INTO table_nameVALUES (value1,value2,value3,...);\n第二种形式需要指定列名及被插入的值：\nINSERT INTO table_name (column1,column2,column3,...)VALUES (value1,value2,value3,...);\n\n\nINSERT INTO 实例在”Customers”表中插入一个新行：\nINSERT INTO Customers (CustomerName, ContactName, Address, City, PostalCode, Country)VALUES (&#x27;Cardinal&#x27;,&#x27;Tom B. Erichsen&#x27;,&#x27;Skagen 21&#x27;,&#x27;Stavanger&#x27;,&#x27;4006&#x27;,&#x27;Norway&#x27;);\n插入一个新行，但只在“CustomerName”、“City”和“Country”列中插入数据:\nINSERT INTO Customers (CustomerName, City, Country)VALUES (&#x27;Cardinal&#x27;, &#x27;Stavanger&#x27;, &#x27;Norway&#x27;);\n\n\n使用另一个表填充一个表可以通过另一个表上的SELECT语句查询出来的字段值，然后将数据填充到本表中，条件是另一个表所查询的字段与本表要插入数据的字段是一一对应的。\nINSERT INTO first_table_name [(column1, column2, ... columnN)] SELECT column1, column2, ...columnN FROM second_table_name[WHERE condition];\n","categories":["SQL","基础"],"tags":["sql"]},{"title":"SQL语法——SQL HAVING 语法","url":"https://lujw666.github.io/2021/03/08/sql-having/","content":"HAVING 子句能够指定过滤条件，从而控制查询结果中哪些组可以出现在最终结果里面。\nWHERE 子句对被选择的列施加条件，而 HAVING 子句则对 GROUP BY 子句所产生的组施加条件。\nSQL HAVING 语法:\nSELECT column_name(s)FROM table_nameWHERE conditionGROUP BY column_name(s)HAVING conditionORDER BY column_name(s);\n在 SELECT 查询中，HAVING 子句必须紧随 GROUP BY 子句，并出现在 ORDER BY 子句（如果有的话）之前。\n\n\nSQL HAVING示例以下SQL语句列出了每个国家/地区的客户数量。只包括超过5位客户的国家/地区：\nSELECT COUNT(CustomerID), CountryFROM CustomersGROUP BY CountryHAVING COUNT(CustomerID) &gt; 5;\n\n\n以下SQL语句列出每个国家的客户数量，从高到低排序（仅包括拥有超过5名客户的国家/地区）：\nSELECT COUNT(CustomerID), CountryFROM CustomersGROUP BY CountryHAVING COUNT(CustomerID) &gt; 5ORDER BY COUNT(CustomerID) DESC;\n\n\n以下SQL语句列出已注册超过10个订单的员工：\nSELECT Employees.LastName, COUNT(Orders.OrderID) AS NumberOfOrdersFROM OrdersINNER JOIN Employees ON Orders.EmployeeID = Employees.EmployeeID)GROUP BY LastNameHAVING COUNT(Orders.OrderID) &gt; 10;\n \n\n以下SQL语句列出员工“Davolio”或“Fuller”是否已注册超过25个订单：\nSELECT Employees.LastName, COUNT(Orders.OrderID) AS NumberOfOrdersFROM OrdersINNER JOIN Employees ON Orders.EmployeeID = Employees.EmployeeIDWHERE LastName = &#x27;Davolio&#x27; OR LastName = &#x27;Fuller&#x27;GROUP BY LastNameHAVING COUNT(Orders.OrderID) &gt; 25;","categories":["SQL","基础"],"tags":["sql"]},{"title":"知乎一小时 056 如何高效地管理团队：年轻管理者手册","url":"https://lujw666.github.io/2021/03/07/ZhihuOneHour056/","content":"第一章 管理新人初长成一、为人还是为己大多数人其实既不是 Giver，也不是 Taker，而是 Matcher，为人和为己之心都有，我们会不自觉地衡量自己的付出和索取，争取一种平衡。\n当你成为管理者之后，为人和为己的天平自然需要一个调整。你需要更多地服务你的下属，尽力帮助他们的成长，为他们谋得福利。\n你的下属将为你工作，他们的努力如果获得回报，你毫无疑问会成为最大的受益者；而如果团队失败，你也必然遭受最大的挑战。所以无论成败，你都应该尽力帮助和给予他们。\n需要开始做这些观察和思考：\n\n你的下属在工作上遇到的困难和阻碍；\n搜罗或者争取哪些资源来帮助他们；\n怎样不吝啬赞美来激励他们；\n他们在学习、生活和情感上是否遇到困惑和低潮？\n\n\n\n「吃亏是福」同样适用于职场在企业中，短期的绩效会是一个无形的压力，它会影响成员的观念和行为。我们有时候并非不愿意帮助他人，而是由于现实的经营压力不得不多考虑一下自己。部门存在隔阂、上级与下属相侵大多缘于这样的绩效之争。\n更多愿意帮助他人的基层员工往往花费了太多的精力，影响了自己的短期绩效，尤其是被 Taker 利用的时候，但一旦走上管理岗位，Giver 的利他行为往往很快能够赢得更多的尊重和下属背书，从而在职场发展中处于更有利的位置。\n\n\n最有价值的帮助和给予是精神当我们说给予他人的时候，并不限于经济和物质方面，当你走上管理岗位，更加有价值的给予在于知识和精神层面。\n需要知道做出利他行为的动机并不是企图未来的回报，而是以下这些：\n\n个人对他人福祉的关切感\n责任感\n社会公正感\n同情心\n\n此刻，你可以分析你的动机，也可以培育你的动机，至少开始体验这些内心感受和自己本能行动上的联系。\n\n\n二、成员们最厌恶和最偏爱的三件事当你走上管理岗位，欲加影响于他人之前，首先要了解自我的局限。\n了解自我的第一步不是去解剖自己的灵魂，而是了解自我认知的规律。这未必需要你去深究心理学，但有几项普通而又重要的规律对你能否驾驭管理工作至关重要。\n\n\n你不可能真正了解和改变他人你和你的下属之间可能经历了面试、工作沟通、生活谈话。你们也可能从早到晚相处了很多的时间。但如果你的管理预设是充分了解一个人，然后有针对性地改变一个人，请小心制定这样的目标。\n管理者主观判断出下属的问题，试图指出问题，以求直接改变，这几乎是最糟糕的管理路径，因为它不仅成效低下，而且容易导致成员的抗拒。\n这种抗拒并不会发展成明面上的争吵，它要么让你的下属丧失自信、感觉委屈，要么无法从个人发展中感到满足，这样一来，他选择离开或者被迫离开团队的概率是非常高的。\n所以，当你走上管理岗位时，难免会本能地开始分析自己的下属，也许你会很认真地在笔记本上写下每个人的名字、评语及改进办法。如果你开始这样做了，请转念想一下这个问题：如果你的老板也在同一个夜晚，在笔记本上做了同样的笔记，其中提到了你本人，你会希望他写下什么样的评语？\n\n\n人最厌恶的三件事你的评语与改进计划无法奏效还有一个与人性有关的原因，即每个人都厌恶的三件事：被说不、被忽视、被指出缺陷。\n被说不就是被拒绝，被忽视就是缺乏关注。如果你的生活充满这两件事，基本就是悲惨的生活，这你不会有什么异议。但是「被指出缺陷」是人最讨厌的事情吗？ 你可能觉得不至于，对这五个字感受并不强烈。这是为什么呢？\n\n我并未指出你本人的缺陷；\n你也许并不觉得自己有什么明显的缺陷。\n\n如果是这样，当我直接指出你的问题，而这个问题你感觉很委屈的时候，我们就进入了沟通中最糟糕的局面。我们彼此之间必将封闭，所有的沟通不仅无效，而且彼此伤害。\n由此带来的沟通失败并不会显性表现出来，它不会引发争吵，相反，它从表面上看一点问题都没有，彼此继续和和气气，但不信任、不认同的关系就此固定下来。\n所以，无依据地根据个人判断指出他人的缺陷（即使你的判断是对的）是一个高风险的管理行为，即使对你的下属也是一样。\n那你肯定要问，如果明明知道下属有问题，还不能指出，那么我们怎么进步呢？\n别着急，我们现在要构筑的是管理的心理准备，你要对与此相关的人性规律有了解。改变他人是一件说难很难、说简单也简单的事情，因为只有一个途径，那就是改变你自己。\n\n\n赞扬是影响他人的最好办法人有最偏爱的三件事：被认同、被关注、被赞扬。\n要记得在人际沟通中，赞扬是启动有效沟通的进气阀，如果这个阀门没有打开，沟通要么是浪费时间，要么就起到相反的效果。\n这里的逻辑是这样的：你知道赞扬能够给人愉悦的感受，从而维护或者激发他的工作状态，于是你要关注赞扬的机会；因为你要找到赞扬的机会，又不能让赞扬显得随意和普遍，所以要更加关注下属的进步和变化；因为你要着眼于变化，所以你需要持续关注。\n\n\n无需把成功的 CEO 当榜样影响我们遵循人性的规律做出正确的管理假设，还包括一个有趣的原因，那就是其他管理者的示范。新晋管理者受到的最大影响是他本人的前老板，尤其是生意上比较成功的老板。\n但你要知道这么几个事实：\n\n对你的前老板，你根本没有那么了解，你对他们的人格判断仅仅是来自他人的总结或者你的观察。你也不知道他们在管理过程中是否有所变化，往哪个方向变。\n即使你的判断是对的，你也不知道，如果他们更加懂得关注和赞扬他人，会不会更成功？\n每个成功的管理者的确都有综合的能力，管理成功的结果来自很多要素，甚至包括外界的环境。但从长期的角度看，每位管理者都会在他的下属身上留下印记，这决定了企业的长期命运。\n\n更重要的是，更多的成功管理者是有完善的自我认知，会洞察人性，懂得通过关注和赞扬成员来激发热情，从而帮助企业获得成功，只不过媒体和舆论较少提到他们的名字而已。\n\n\n三、如何帮助你的成员？约翰米勒有一本著名的畅销书，名字就叫《问题背后的问题》，英文简称 QBQ。它给职场人士提供了一个怎样提升个人责任感的思维模式指南。简单说，就是在遇到问题的时候，改变问问题的方式，着眼于改变自己和当下，不要试图改变他人。\n不要试图改变他人，你根本改变不了，唯一能够改变依然是你自己。按照 QBQ 的精神，你同样应该围绕这个问题着眼于自己和当下。\n\n\n帮助成员提出 QBQ 问题给自己一个承诺，永远不要直接指出下属缺乏责任感、不够 QBQ，而是要建立具体问题具体沟通的习惯。\n如果你发现成员开始抱怨（首先要理解这是人之常情），你要帮助他开始用 QBQ 的模式提出新的问题。\n你不仅可以帮助下属提出这个问题，而且可以让他拥有这个问题。这时，尽管是被动的，但你的下属至少拥有了一个 QBQ 模式的问题去解决。当他要着手去解决这个问题时，他成了问题的主人。\n如果他能够从解决这个问题的过程中领悟到更多，也不再是你改变了他，而是他改变了他自己。他也许能够开始意识到问题背后的问题该怎么问，每个问题背后都有一个当下和自己能够执行的解决方案。\n\n\n帮助成员建立逻辑有很多不够 QBQ 的问题本身就有很大的逻辑漏洞。\n比如销售可能会抱怨产品价格过低，导致销售额上不去；营销部门可能会抱怨产品缺乏卖点，所以点击率很低；质量部门抱怨研发管理太弱，导致测试工作量过大；研发部门抱怨需求经常变动，所以常常做无用功。这些都是办公室内常见的躲避责任的问题。\n商业的结果几乎总是多因的：销售的成功来自产品的优秀、渠道的通畅、定价的合理、品牌的口碑；员工的成长来自本人的努力、有效的引导、有挑战的目标；利润的构成来自收入的提成和成本的控制；研发的质量来自设计的合理、有经验的团队和有效的质量控制；项目的准时交付来自清晰的进度、资源的到位、变更的把控、及时的沟通。\n当员工提出了与此相关的抱怨，无非是因为着眼于狭窄的角度，没有从完整的视角来看待问题。\n所以，当遇到这种情况时，我们无需责怨和试图让成员直接变得 QBQ，而是首先要让他看到因果全貌。富有逻辑的沟通总是能够有很强的说服力，试图直接改变他人的沟通总是两败俱伤。\n\n\n帮助成员提升自我我们无法直接改变他人，但是每个人都可能自我改变。同样的道理，你的下属的个人成长和你的说教无关，只和他自己改变的意愿有关。\n企业文化当然能够影响每一位成员，但是按照 QBQ 的精神，你永远都不能等待企业从上至下的文化影响，而是应该随时落实在你周边的成员。\n多阅读、多分享，寻找机会帮助他人，建立不评价他人的团队习惯。物以类聚，人以群分，作为团队领导，你的影响力是客观存在的。我们未必需要多谈表率和榜样，只要着眼于「帮助」你的下属提升自我的目标即可。\n实际上，当你下定决心这样去做，不用多久，你就会发现你的团队与众不同：他们不仅减少了抱怨，而且会越来越多地 QBQ 地解决问题。这正是你作为管理者的幸福感源泉。\n相反，如果你还没有感受到团队的足够进步，请坚持做下去。抱怨团队是管理的天敌，是你失望、焦虑、混乱和管理失败的起源。\n\n\n第二章 如何高效管理管理的首要任务并非「管事」，而是「理事」。\n管理者的工作应该以能够达成公司目标的任务为基础，是实质工作。\n\n\n一、企业的任务从何而来企业任务大体有两种性质：常规和关键。如果我们理解了企业的常规任务和关键任务，有助于厘清管理工作的核心内容。\n企业的战略决定了企业的任务来源，而竞争环境则决定了关键任务的多寡。\n\n\n从战略到目标在确定任务之前，我们先回到本源：怎样确定企业的战略和目标？\n我们日常的所有沟通都可能随时需要来和战略比对，所以，如果我们只谈工作目标、不谈战略反倒是不可能完成的任务。\n任何企业都会从某种模糊的战略愿景出发，不管你是不是用「愿景」来称谓它。\n没有战略愿景是足够清晰的，至于正确还是错误则是未来才能验证的事情。所以，更重要的是要有这么一个愿景存在。\n至于对未来愿景判断的时间周期，大体取决于行业的竞争变化的速度。但不同行业用来勾勒战略愿景的时间尺度大体上有章可循。比如农业、医疗、教育、汽车行业通常需要展开五到十年的周期；而互联网、金融、媒体这些行业则要短得多，在极端的情况下，两到三年的周期有时候都会显得过于遥远。\n一个企业可以自主制定自己的长期战略，但是永远需要根据市场环境和竞争来建立中短期的战略目标。而这个目标将用来帮助企业团队确定这段周期的关键任务。反过来说，如果这些关键任务不能被有效识别和完成，中短期战略目标就难以实现；这个目标如果不能实现，长期战略愿景就流于空想。\n在我们进入下一环节之前，还需要多花一点时间来审视目标。\n每个团队都面临过目标分解的时刻，要记住，在时间维度上进行目标的切分永远是一件好事。但我们实际的管理行为往往着眼于从另外一个维度进行目标分解。\n\n\n二、识别并执行关键任务从目标到关键任务任何一个企业的目标和任务都不可能这么简单。那么，企业的关键任务是如何从目标中分解出来的呢？\n当你成为一名管理者，每天都将面临目标和任务，即使你情商很高、通达人性、受到下属尊重，但在任务分解的过程中没有建立正确的认知，一样会遭受挫败。\n\n\n企业的短期目标由某一个关键因素驱动在理解关键任务的过程中，我们先要看到一个事实：企业长期目标的达成取决于竞争优势和整体能力的完备，两者缺一不可，但中短期目标达成的驱动因素会比较单一 。在更短的周期内，例如一个季度的目标，则基本取决于一两项关键事务的完成。\n无论是观察成功还是失败企业的案例，都会发现这个普遍规律：在特定周期内，如果企业无法识别出关键任务，就一定会在竞争中落败。\n\n\n不同阶段的企业的关键任务逻辑首先，不同阶段的企业大致会存在一些普遍规律：\n\n初创型企业\n\n初创型企业通常面临两类关键任务。\n第一类是有关于生存。\n第二类关键任务是试错。\n\n成长型企业\n\n当你的团队有幸能够迈过初创期，研发出基本适销对路的产品，理顺了供应链，发展出有效的营销方法和渠道，拥有了第一批顾客，恭喜你进入了成长型企业阶段。\n成长型企业的关键任务也可以大致分为两种。\n第一种我们称为消除瓶颈。\n比较常见的增长瓶颈包括：\n\n在量产阶段的质量挑战。 对于制造业而言是工艺可靠性和良品率，对于服务业是流程和团队扩展过程中的服务意识保证，即使对于互联网服务和软件行业，也有在大规模用户情况下的服务可靠性。\n短板凸显。 在早期的低销量和试错期，我们很难聚焦去解决短板问题，但进入增长阶段后，如果有明显的能力缺失，就会导致业务循环无法完整进行。\n跨越主流市场鸿沟。 因为初创企业获得早期用户时不可避免会带有两种特征，一种来自先锋性用户，愿意尝试新鲜的产品和服务，另一种来自社交推广的内圈红利。这两种用户特征和主流市场必然有很大的差异。中庸的主流用户大多不愿意尝试过于新颖的产品和服务，他们会观望和模仿其他用户；通过社交营销实现了首批客户获得后，因为缺乏后继的话题和注意力在主流市场难有作为，或者面临越来越高的营销成本。\n\n第二类关键任务通常是增强成长动因。 意思是在大多数瓶颈消除后，利用市场出现的机会快速突破，达到令竞争对手望而却步的规模标准。\n\n成熟型企业\n\n首先是「发现增效机会」。成熟企业依然可以通过降低成本和提高效率来提升经营绩效，无论是研发、生产还是销售部门均有这样的机会。\n成熟型企业还要警惕另外一种假象。有的时候，你所在的行业其实并非成熟行业，而是夕阳行业。这意味着市场并非稳定，而是需求开始下降、供给开始过剩。实质上，企业已经进入下降通道。\n这个时候，增效也许已经不是关键任务。开拓新的市场，进行大力的业务转型才是企业的生命线。\n当成熟企业需要转型到新的领域时，它的关键任务逻辑其实和初创型企业比较接近，只是在关键任务中生存类的任务要少于试错类。\n\n\n三、管理常规任务最核心的办法除了关键任务以外，每个企业都会有大量的常规任务。\n管理好常规任务的最核心办法是什么呢？\n\n流程标准\n监督管控\n绩效考核\n\nA，B，C 大概是一个逻辑的先后关系，所以你也可以认为每一项都是需要做好的。但是，如果你的资源非常有限，假设你只剩下最后一点精力，选择 A，而不是大多数人直觉上选择的 C。\n\n\n盯住流程标准会抹杀创造性吗？流程标准会不会抹杀员工的创造性呢？实际上真正伤害创造性的是 B 和 C（强硬的监督和试图用奖惩来控制结果）。\n实时监督和控制让执行者失去思考和判断的机会；而仅仅着眼于结果考核，并不能保证一个企业的运营质量，很多的常规任务执行并没有事后补救的机会。\n当我们有了完善的流程标准后，我们依然可以鼓励员工在执行过程中进行比较和思考，找到改进方法和流程的机会。\n所以，在关键任务以外，管理者的任务还包括通过设计和维护流程标准来完成企业的常规任务。\n\n\n四、不要重复发明轮子常规任务所对应的流程标准就像企业的轮子，它的转动能够推进企业。但是你的团队不可能一成不变，新成员加入的时候会不小心重新发明一个轮子。\n比如一家制造企业在交付货物给客人时制定了一个质量控制的流程，但是随着业务量的发展，新的员工加入时不知道有这么一个流程存在，于是他按照自己的理解来执行，结果可想而知，必然错漏百出。\n重复发明轮子，不仅成本高昂，而且质量低下。那我们怎样防范重复发明轮子？这要求管理者懂得策展（curate）知识。\n你也许听说过日本知识管理专家野中郁次郎的 SECI 模型，他把知识的形成过程描述为群化（Socialization）、外化（Externalization）、融合（Combination）和内化（Internalization）的循环。\n我们所说的知识策展就是他所描述的 Externalization（外化）的过程，这也是各层级管理者的管理任务之一。\n以下是一些有用的策展知识的形式：\n文章（Article）这是最基础的内容整理形式，之所以特称为「文章」，是因为整理者有义务围绕一个主题完整成文，交代上下文背景，构筑相对完整的写作结构，呈现明确的写作目标，最终都是为了方便读者建立理解。因此，它显然地区别于日常工作中的一般性沟通和分享。\n单篇文章所涉及的主题不需要过于宏大，越具体越好。文章累积到一定程度，我们就可以编排辑录，说白了就是可以依据文章的主题逻辑关系，编撰成册。\n这个过程目前已经可以高度数字化，有些企业使用 Wiki 工具来进行写作，不仅方便内部协同编辑，还可以随时保持内容的更新。Wiki 条目也可以通过章节关系和互链功能建立连接。\n检查清单（Checklist）这是一种简洁有效的知识整理形式，主要用于质量控制要求较高的流程性工作指南。\n检查清单同时还是一个重要的主动质量管理工具，但凡严格使用检查清单的企业，运营差错率更低，客户满意度更高。检查清单需要在实践中不断优化，通常在运营中产生的问题，经过成因分析，都能够通过检查清单来巩固未来的运作质量。\n检查清单可以用文章的形式来体现，如果足够重要，可以印刷成执行人随身或者案头张贴的卡片。\n有别于一般的知识整理，检查清单通常需要设计得非常简洁，专注在检查列表上，而不是再事无巨细地罗列每个检查项目的执行方法。\n流程图（Flow chart)和检查清单类似，流程图也是一种针对特定知识传递需求的形式设计。顾名思义，它既能够帮助读者了解一个复杂商业流程的全貌，也能够按图索骥，了解特定环节的处理规范。\n问题（Issue）文章、检查清单和流程图都是基于正常或理想状态下的企业运营知识整理形式。还有一种形式对于处理具体和例外状态更加恰当，那就是问题和案例。\n问题（Issue）一般可以分为常见和偶发两种类型。前者可以形成《常见问题与解答》，这是性价比很高的知识整理形式，因为少部分的内容可以用来反映大部分的知识传递需求。\n但偶发性的问题与解决方案同样重要，它也被称为「预案」（Contigency Plan），因为一旦发生，可能带来较大的损失。\n模版与表单（Template and Form）针对企业运营中不断重复的个性化流程，也可整理为「模版」或者「表单」，它能够帮助新人用最少的培训获得基本作业能力。\n例如广告公司针对消费品牌的营销服务中，常常根据客户需求的类型预先准备好提案的模版，虽然这不可避免地会降低原创程度，但对于需要通过重复来扩张规模的企业来说，是必须的选择。\n范式订单也是一种模版，它通常设计为可以直接填写的表格，通过罗列的单元格，让销售人员对订单执行中的诸多要素进行理解。\n所以，模版本身也是一种通过纲要来学习细节的工具。当我们要指导新员工如何评估客户满意度时，千言万语不如一张「客户满意度调查表」来得清晰有效。\n样例和案例（Example and Case）总有一些复杂的流程和技能是无法模版化的，这时候，我们可以通过另外一种整理形式来实现沉淀和利用——样例和案例。\n如果项目性质演变为营销或管理咨询，服务的流程大概就不可能依靠范式的文档来实现重复，此时，需要富有经验的服务人员将过往的执行整理为样本或者案例：前者是一个具体的工作成果展现（例如：项目策划建议书）；后者则是包括更加完整的背景描述、执行过程和结果评估的报告。无论何种详尽程度，它们起到的作用是类似的。\n样例和案例的整理通常需要花费更多的精力，因此，企业不必追求数量多，而是应该精益求精，力求通过最少的数量覆盖多元的场景类型。\n专家名录（Expert Directory）专家名录或者专家网络就是将运营环节中的难点和主题挖掘出来，依据每一个难点定位企业内部的专家。\n他们往往是这些难点问题的深度参与对象，具有丰富的经验，善于解决具体问题，同时，还要具备突出的分享精神。总之，这些员工往往是团队中德才兼备的明星成员。\n形成了问题和专家的对应关系后，就要把这组信息有效地传递给全员，让员工在遇到特定问题的时候，有一个明确的求助目标。\n\n\n第三章 管理的首要途径——沟通一、沟通的边界无论是规章制度，还是绩效考核方法，其实施都不会自动发挥作用；即使成员都百般顺从，也不可能一定会带来有价值的成果。但我们总是急于完成这些从上至下的简单沟通任务，认为规章和指令只要传达到位，就能够让它们生效。\n实际的情况并非这样，否则我们为什么还要开动员会，为什么还要有总经理意见箱，为什么还要有一对一？\n在企业组织中，沟通的挑战主要来自于这些边界：\n层级的边界除了管理者和直接下属之间心理上的隔阂之外，更严重的是跨越层级的边界，例如 CEO 和一线员工之间。\n部门的边界因为角色和目标的差异，不同职能部门容易站在本部门的角度看待问题，急于完成本部门的目标，导致沟通的成效极低。更加不要说两个不同部门的基层员工，他们之间的沟通很大程度上无法直接进行，而是要通过各自的上司进行。我们称这种沟通为倒 U 型沟通，或者深井式沟通。\n地理的边界因为成员不在一起，只能依靠远程协作工具，缺乏口头的当面交流，难以体察情绪反馈。地理的边界不一定是北京和上海这种异地距离，楼上楼下、相隔几个办公位就已经存在地理边界了。真正在地理上相对畅通的沟通几乎只能发生在一室之内。\n社会心理的边界当然，更多困扰我们的沟通屏障是来自职场中约定俗成的社会心理定势。担心多管闲事，少说多看，不敢冒犯上司，不愿打扰同事，虚伪奉承，担心越级越位，生怕招惹是非，包括部分成员的社交恐惧和社交泛滥，都会影响一个企业组织内部的沟通成效。\n\n\n在企业的早期阶段，规章制度、绩效考核这些管理工具几乎都很薄弱，但小企业之所以能够拥有生存和发展的可能，全有赖于它在层级扁平、边界淡薄阶段突出的沟通优势。也就是说，你的团队可以暂时没有明确的规章制度，但绝对不能没有顺畅的沟通。\n\n\n二、如何打造流畅的沟通？沟通的首要原则是透明描述沟通质量有很多维度，比如及时性、准确性、简洁性、完整性，但这些标准是否满足沟通的需要都会因时而异。在管理沟通中，唯有透明度是首要的通行要求。\n在你组织内部沟通工作时，除了极少数需要权衡保密的信息以外，大多数的沟通都应该尽可能让参与者周知的。反过来，形成团队效率制约的主要原因也在于沟通的不透明。\n它可能造成成员对企业目标的不清晰和不一致，对资源和条件的不了解，对团队其他成员的努力不知情，无视已经达成的阶段性成果，从而产生战略失焦、战术莽撞、成员误解、重复投入的问题。\n开放领导力华人咨询师 Charlene Li 在 2010 年出版的畅销书 Open Leadership 一书中首次提出了开放领导力的概念。\n和传统的领导力理论不同，她指出管理者的领导力不仅可以从提升情商中获得，也可以从推动开放沟通行为中增强。她还为企业内部的开放沟通行为作出了显性的定义，把管理者应该推动的透明沟通模式概括为以下六点：\n\n解释说明（Explaining）\n\n管理者从上至下的沟通常常包括战略决策、公告命令、任务指派。\n这些沟通大多都是单向的，而且往往容易被简化为公文，缺乏对参与者的解释说明。例如战略决策信息，我们需要说明这个决策的原因，如果我们不执行这个战略会导致什么后果？如果我们执行这个战略还会遇到什么挑战？\n当我们增加这些从上至下沟通内容的解释说明成分时，参与者可以获得更多的上下文，加深对决策理解和支持的程度，同时也有机会了解到可能存在的疑问和反对意见。\n\n\n知会（Updating）\n\n知会讲的是全员工作沟通的基本模式。有别于传统的管道式工作汇报（A 向 B 汇报，B 向 C 汇报），知会着眼于尽可能多和直接地让同事了解工作进度、问题和计划。\n在社交网络中，最常用的缺省提示是「你在想什么？」这正是一个绝佳的知会动作提示。通过知会，可以及时让同事了解你的工作状态、计划和可能遇到的问题，而如果采用传统的管道汇报、整理和再沟通，不仅效率低，而且会伤害沟通的准确性。\n\n\n自由对话（Conversing）\n\n自由对话讲的是允许和鼓励组织内任何成员之间直接沟通和协作，而不需要经过部门和层级的路由。\nA 部门的基层员工无需通过 A 部门的领导就能够直接和 B 部门需要进行协作的基层员工对话，基层员工在需要的情况下可以直接和跨越层级的领导协作。\n只要保持沟通在透明环境中进行，准确地说，就是充分使用知会的沟通模式来让相关人员都周知。\n\n\n开放发言（Open Mic）\n\n开放发言指的是允许和鼓励任何成员发起集体沟通，无论他（她）提出的是什么性质的话题。这个原则着眼于让团队在沟通层面建立无话不可说的氛围。\n常见的开放发言着眼于头脑风暴式的集体创意（ideation），集思广益，鼓励提出想法和点子。\n除此之外，更大的挑战在于允许和鼓励公开谈论企业问题，比如产品质量问题、需求适配度问题、竞争对手的优势、市场前景不佳，甚至包括对管理制度文化的意见。\n公开谈论企业问题是始终要实现的目标，尤其在发展速度很快的行业中，正视问题才是迅速解决问题的最大动力。\n在集体会议中，太多的意见，不符合当下聚焦点的建议需要一个分类梳理的模式，但更重要的是不要武断地打断好不容易发生的公开发言。无论对方讲的是什么内容，都应该允许被提出来，而不要当场压制。\n否则，不但发言的人备受打击，其他成员也会因此而更多地顾忌自己的发言内容。下图是一个简单易行的沟通讨论控制模式，它不仅能够让开放发言更加有针对性，而且能够促进参与者发言的意愿。\n\n\n众包（Crowdsourcing）\n\n众包并非外包的一种形式，而是指企业内部任务分配的模式。传统的任务大多是指派给特定成员的，而众包式任务分配则是指公开征求愿意负责任务的人、主动愿意来承担的成员成为任务的负责人。\n对于重要和关键的任务，如果有了主动承担的意愿度保证，则会大大提高任务完成的质量。当然，一个组织如果能够实现很多的众包式任务分配，它的前提是已经初步建立了开放沟通的文化氛围。\n\n\n使用统一平台（Platform）\n\n为了实现开放沟通的目标，组织还应该对沟通的方式和平台有约定和要求。如果不同成员使用不同的沟通平台，那么我们所要达成的透明度目标在物理上也实现不了。所以，在沟通方式的约定上，并不依赖民主和自治，它要求大家达成一致意见。\n除了平台和工具的选择，沟通的内容和形式也应该约定。如果我们要求每天知会工作，那么知会内容应该包含哪些方面，也应该作出要求。\n\n\n\n\n\n三、什么是管理沟通的真正挑战在本书的最后，我们进入管理沟通的最大挑战——倾听和教练。这也是管理者成长到一个阶段后必然遭遇的困境和反思时刻。\n倾听是沟通的一部分沟通才是管理真正有效的途径，那么我们自然应该理解倾听就是沟通的一部分。\n通过一些管理技术，的确也可以根据绩效数据来判断员工的问题所在。比如销售漏斗中，根据逐段的转化率差异分析，可以有针对性地帮助提高。\n但是这些来自数据的分析只能起到提升员工绩效的教练目标，而并非着眼于员工的发展。所以在培训领域，我们需要区分的是为「绩效」（performance）的培训，还是为「发展」（development）的教练：前者能够提供员工的局部技能，后者能够帮助你构筑有长期竞争力的团队。\n学会问好的问题想要让成员讲述有价值的内容，你需要学会问好的问题。\n提问是最好的教练方式，因为在个人发展方面，任何的直接说教不仅不能改变人，而且也无法启发思考。当我们听到一个提问时大脑运行的模式和听到一段说教时的运行模式是不一样的。\n前者会让对方快速开启搜索模式，寻求答案，后者会让对方的思考停止，接受和记忆度也随之降低。况且，在很多情况下，管理者未必能够有足够的信息和知识来指导员工。\nMichael Bungay Stanier 在 The Coaching Habit 一书中提供了管理者提问的最佳选择。他建议了七个好问题，或者提问模式，分别有不同的目的，但总体上都是为了让提问的你能够更有效地倾听，启发被问者自发找到更完善的答案。\n\n开启谈话的开放问题：「最近在思考什么？」\n持续深挖的问题：「还有什么吗？」\n帮助聚焦的问题：「在这里，你真正的挑战是什么？」\n帮助找到基石和根源的问题：「你真正想要的是什么？」\n提示让成员自主思考和承担的问题：「这些事情中哪些是需要我来帮你做的？」\n促进战略思考的问题：「如果我们选择做这个，那么你会选择放弃哪一个？」\n促进学习的提问：「今天你觉得什么对你最有用？」\n\n你不必呆板地引用这些提问例句，更重要的是理解为什么要用提问来开启倾听。只有你真正听到了成员的表达，才明白自己所处的管理环境，才能进一步通过沟通和协调来达到你的目标。\n","categories":["科普","知乎一小时"],"tags":["管理"]},{"title":"python笔记（02）——解释器","url":"https://lujw666.github.io/2021/03/07/python-02/","content":"解释器Linux/Unix 的系统上，Python 解释器通常被安装在 /usr/local/python3 这样的有效路径（目录）里。\n可以将路径 /usr/local/python3/bin 添加到您的 Linux/Unix 操作系统的环境变量中，这样您就可以通过 shell 终端输入下面的命令来启动 Python 。\n$ PATH=$PATH:/user/local/python3/bin/python #设置环境变量$ python3 --vesionPython 3.7.6\n在 Window 系统下你可以通过以下命令来设置 Python 的环境变量，假设你的 Python 安装在 C:\\Python37 下:\nset path=%path%;C:\\python37\n\n\n解释器的调用\n#!/usr/bin/python ：指定用什么解释器运行脚本以及解释器所在的位置，如果解释器没有装在/usr/bin/目录，改成其所在目录就行了，或者更通用的方法是：#!/usr/bin/env python。\n\n#!/usr/bin/python3\n\n保存在XXX.py 文件中并使用python命令执行该脚本文件\n\npython XXX.py","categories":["Python","基础"],"tags":["python","解释器"]},{"title":"python笔记（01）——安装","url":"https://lujw666.github.io/2021/03/07/python-01/","content":"Python是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。\n\n解释型语言：开发过程中没有了编译这个环节。类似于PHP和Perl语言。\n交互式语言：可以在一个Python提示符，直接互动执行写你的程序。\n面向对象语言: 支持面向对象的风格或代码封装在对象的编程技术。\n初学者的语言：对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。\n\n\n\npython安装linux &amp; unix1.适用于 Unix/Linux 的源码压缩包下载：https://www.python.org/downloads/source/2.解压及安装\ntar -zxvf Python-3.8.5.tgzcd Python-3.8.5./configuremake &amp;&amp; make install\n3.检查Python3是否正常可用\npython3 -V\n\n\nwinodws\n打开WEB浏览器访问https://www.python.org/downloads/windows/\n在下载列表中选择 Windows 平台安装包，包格式为：python-3.8.5-amd64.exe 文件 ， -3.8.5 为你要安装的版本号，-amd64为你系统的版本。\n下载后，双击下载包，进入 Python 安装向导，安装非常简单，你只需要使用默认的设置一直点击”下一步”直到安装完成即可。\n\n\n\nMacMAC系统一般都自带有 Python2.7 版本的环境，也可以在链接https://www.python.org/downloads/mac-osx/上下载最新版安装。\n","categories":["Python","基础"],"tags":["简介","安装","python"]},{"title":"SQL语法——SQL GROUP BY 语法","url":"https://lujw666.github.io/2021/03/07/sql-groupby/","content":"Aggregate 函数常常需要添加 GROUP BY 语句。\nGROUP BY语句通常与集合函数（COUNT，MAX，MIN，SUM，AVG）一起使用，以按一个或多个列对结果集进行分组。\nSQL GROUP BY 语法:\nSELECT column_name(s)FROM table_nameWHERE conditionGROUP BY column_name(s)ORDER BY column_name(s);\n\n\nSQL GROUP BY示例下面的 SQL 语句从 “Customers” 表中列出了每个国家/地区的客户数量：\nSELECT COUNT(CustomerID), CountryFROM CustomersGROUP BY Country;\n下面的 SQL 语句从 “Customers” 表中列出每个国家的客户数量，从高到低排序：\nSELECT COUNT(CustomerID), CountryFROM CustomersGROUP BY CountryORDER BY COUNT(CustomerID) DESC;\n\n\nGROUP BY使用JOIN示例下面的 SQL 语句从 “Orders” 和”Shippers”表中列出了每个发货人发送的订单数量：\nSELECT Shippers.ShipperName, COUNT(Orders.OrderID) AS NumberOfOrders FROM OrdersLEFT JOIN Shippers ON Orders.ShipperID = Shippers.ShipperIDGROUP BY ShipperName;","categories":["SQL","基础"],"tags":["sql"]},{"title":"SQL语法——SQL ORDER BY 语法","url":"https://lujw666.github.io/2021/03/07/sql-orderby/","content":"ORDER BY 关键字用于按升序或降序对结果集进行排序。\nORDER BY 关键字默认情况下按升序排序记录。\n如果需要按降序对记录进行排序，可以使用DESC关键字。\nSQL ORDER BY 语法:\nSELECT column1, column2, ...FROM table_nameORDER BY column1, column2, ... ASC|DESC;\n在ORDER BY子句中使用多个列，但要确保用于对该列进行排序的列应该在列表中。\n\n\nORDER BY 实例下面的 SQL 语句从 “Customers” 表中选取所有客户，并按照 “Country” 列排序：\nSELECT * FROM CustomersORDER BY Country;\n\n\nORDER BY DESC 实例下面的 SQL 语句从 “Customers” 表中选取所有客户，并按照 “Country” 列降序排序：\nSELECT * FROM CustomersORDER BY Country DESC;\n\n\nORDER BY 多列 实例1下面的 SQL 语句从 “Customers” 表中选取所有客户，并按照 “Country” 和 “CustomerName” 列排序：\nSELECT * FROM CustomersORDER BY Country, CustomerName;\n\n\nORDER BY 多列 实例2以下SQL语句从”Customers” 表中选择所有客户，按 “Country” 升序排列，并按 “CustomerName” 列降序排列：\nSELECT * FROM CustomersORDER BY Country ASC, CustomerName DESC;","categories":["SQL","基础"],"tags":["sql"]},{"title":"SQL语法——SQL WHERE 语法","url":"https://lujw666.github.io/2021/03/04/sql-where/","content":"WHERE 子句用于过滤记录，提取满足指定标准的记录。\nSQL WHERE 语法：\nSELECT column1, column2, ... FROM table_name WHERE condition;\n\n注意： WHERE子句不仅用于SELECT语法，还用于UPDATE，DELETE语法等！\n\nWHERE子句可以与以下类型的SQL语句一起使用：\n\nUPDATE\nDELETE\n\nUPDATE语句：\nUPDATE &quot;table_name&quot;SET &quot;column_1&quot; &#x3D; [new value]WHERE &quot;condition&quot;;\nDELETE语句：\nDELETE FROM &quot;table_name&quot;WHERE &quot;condition&quot;;\n\n\nSQL 运算符运算符是保留字或主要用于 SQL 语句的 WHERE 子句中的字符，用于执行操作，例如：比较和算术运算。 这些运算符用于指定 SQL 语句中的条件，并用作语句中多个条件的连词。\n常见运算符有以下几种：\n\n算术运算符\n比较运算符\n逻辑运算符\n否定条件运算符\n\n\n\nSQL 算术运算符\n假设变量 a 的值是：10，变量 b 的值是：20，以下为各运算符执行结果：\n\n\n\n运算符\n描述\n例子\n\n\n\n+\n加法，执行加法运算。\na + b 得到 30\n\n\n-\n减法，执行减法运算。\na - b 得到 -10\n\n\n*\n乘法，执行乘法运算。\na * b 得到 200\n\n\n/\n用左操作数除以右操作数。\nb / a 得到 2\n\n\n%\n用左操作数除以右操作数并返回余数。\nb % a 得到 0\n\n\n\n\nSQL 比较运算符假设变量 a 的值是：10，变量 b 的值是：20，以下为各运算符执行结果：\n\n\n\n运算符\n描述\n例子\n\n\n\n=\n检查两个操作数的值是否相等，如果是，则条件为真(true)。\n(a = b) is false.\n\n\n!=\n检查两个操作数的值是否相等，如果值不相等则条件为真(true)。\n(a != b) is true.\n\n\n&lt;&gt;\n检查两个操作数的值是否相等，如果值不相等则条件为真(true)。\n(a &lt;&gt; b) is true.\n\n\n&gt;\n检查左操作数的值是否大于右操作数的值，如果是，则条件为真(true)。\n(a &gt; b) is false.\n\n\n&lt;\n检查左操作数的值是否小于右操作数的值，如果是，则条件为真(true)。\n(a &lt; b) is true.\n\n\n&gt;=\n检查左操作数的值是否大于或等于右操作数的值，如果是，则条件为真(true)。\n(a &gt;= b) is false\n\n\n&lt;=\n检查左操作数的值是否小于或等于右操作数的值，如果是，则条件为真(true)。\n(a &lt;= b) is true.\n\n\n!&lt;\n检查左操作数的值是否不小于右操作数的值，如果是，则条件变为真(true)。\n(a !&lt; b) is false.\n\n\n!&gt;\n检查左操作数的值是否不大于右操作数的值，如果是，则条件变为真(true)。\n(a !&gt; b) is true.\n\n\n\n\nSQL 逻辑运算符：这是在 SQL 所有的逻辑运算符的列表。\n\n\n\n运算符\n描述\n\n\n\nALL\nALL运算符用于将值与另一个值集中的所有值进行比较。\n\n\nAND\nAND运算符允许在SQL语句的WHERE子句中指定多个条件。\n\n\nANY\nANY运算符用于根据条件将值与列表中的任何适用值进行比较。\n\n\nBETWEEN\nBETWEEN运算符用于搜索在给定最小值和最大值内的值。\n\n\nEXISTS\nEXISTS运算符用于搜索指定表中是否存在满足特定条件的行。\n\n\nIN\nIN运算符用于将值与已指定的文字值列表进行比较。\n\n\nLIKE\nLIKE运算符用于使用通配符运算符将值与类似值进行比较。\n\n\nNOT\nNOT运算符反转使用它的逻辑运算符的含义。 例如：NOT EXISTS, NOT BETWEEN, NOT IN等等，这是一个否定运算符。\n\n\nOR\nOR运算符用于组合SQL语句的WHERE子句中的多个条件。\n\n\nIS NULL\nIS NULL运算符用于将值与NULL值进行比较。\n\n\nUNIQUE\nUNIQUE运算符搜索指定表的每一行的唯一性(无重复项)。\n\n\n","categories":["SQL","基础"],"tags":["sql"]},{"title":"SQL语法——SQL SELECT DISTINCT 语法","url":"https://lujw666.github.io/2021/03/03/sql-select-distinct/","content":"SELECT DISTINCT语法用于仅返回不同的值。\n在一张表内，一列通常包含许多重复的值; 有时只想列出不同的值。\nSQL SELECT DISTINCT语法：\nSELECT DISTINCT column1, column2, ... FROM table_name;\n\n\nSELECT DISTINCT 实例以下SQL语句仅从”Customers” 表中的 “Country” 列中选择DISTINCT值：\nSELECT DISTINCT Country FROM Customers;\n查询结果：\nCountryGermanyMexicoUKSweden\n","categories":["SQL","基础"],"tags":["sql"]},{"title":"SQL语法——SQL SELECT 语法","url":"https://lujw666.github.io/2021/03/03/sql-select/","content":"SELECT 语法用于从数据库中选择数据。\n返回的数据存储在结果表中，称为结果集。\nSQL SELECT 语法：\nSELECT column1, column2FROM table_name;\n与\nSELECT * FROM table_name;\n\n\n\nSELECT  检索一列下面的 SQL 语句从 “Customers” 表中选取 “City” 列：\nSELECT City FROM Customers; \n查询结果：\nCountry GermanyMexico Mexico UKSweden\nSELECT  检索多列下面的 SQL 语句从 “Customers” 表中选取 “CustomerName” 和 “City” 列：\nSELECT CustomerName, City FROM Customers;\n 注意：这两个列名在查询中用逗号分隔。每当您选择多个列时，它们必须用逗号分隔，但最后一列名称之后不能添加逗号。\nSELECT  检索所有列下面的 SQL 语句从 “Customers” 表中选取所有列：\nSELECT * FROM Customers;","categories":["SQL","基础"],"tags":["sql"]},{"title":"SQL笔记（02）——SQL 语法","url":"https://lujw666.github.io/2021/03/03/sql-02/","content":"SQL 语法规则\nSQL语句总是以关键字开始\nSQL语句以分号结尾\nSQL不区分大小写\n\n\n\nSQL语句结构结构化查询语言包含6个部分：\n\n数据查询语言（DQL:Data Query Language）：用以从表中获得数据，确定数据怎样在应用程序给出。保留字SELECT是DQL（也是所有SQL）用得最多的动词，其他DQL常用的保留字有WHERE，ORDER BY，GROUP BY和HAVING。这些DQL保留字常与其他类型的SQL语句一起使用。\n\nSELECT 语句用于从数据库中选择数据。返回的数据存储在结果表中，称为结果集。\nSELECT DISTINCT 语句用于返回唯一不同的值。\nWHERE 子句用于提取那些满足指定条件的记录。\n算术运算符\n比较运算符\n逻辑运算符\nAND &amp; OR  运算符用于基于一个以上的条件对记录进行过滤。\nLIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。\nIN &amp;NOT IN操作符允许在 WHERE 子句中规定多个值。\nBETWEEN 操作符用于选取介于两个值之间的数据范围内的值。\nALL 用于将值与另一个值集中的所有值进行比较\nEXISTS 用于搜索指定表中是否存在满足特定条件的行\nIS NULL &amp; IS NOT NULL 用于将值与NULL值进行比较\nUNIQUE 搜索指定表的每一行的唯一性\nNOT 反转使用它的逻辑运算符的含义\n\n\n\n\nORDER BY 关键字用于对结果集进行排序。\nGROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。\nHAVING 子用于返回筛选分组后的各组数据。\n\n\n数据操作语言（DML：Data Manipulation Language）：其语句包括动词INSERT，UPDATE和DELETE。它们分别用于添加，修改和删除表中的行。也称为动作查询语言。\n\nINSERT INTO 语句用于向表中插入新记录。\nUPDATE 语句用于更新表中的记录。\nDELETE 语句用于删除表中的记录。\n\n\n事务处理语言（TPL）：它的语句能确保被DML语句影响的表的所有行及时得以更新。TPL语句包括BEGIN TRANSACTION，COMMIT和ROLLBACK。\n\nCOMMIT 提交更改\nROLLBACK 回滚更改\nSAVEPOINT 在事务内部创建一系列可以 ROLLBACK 的还原点\nRELEASE SAVEPOINT 命令用于删除先前创建的保存点\nSET TRANSACTION 命名事务\n\n\n数据控制语言（DCL）：它的语句通过GRANT或REVOKE获得许可，确定单个用户和用户组对数据库对象的访问。某些RDBMS可用GRANT或REVOKE控制对表单个列的访问。\n\nGRANT 授予权限\nREVOKE 撤销已授予的权限\n\n\n数据定义语言（DDL）：其语句包括动词CREATE和DROP。在数据库中创建新表或删除表（CREAT TABLE 或 DROP TABLE）；为表加入索引等。DDL包括许多与人数据库目录中获得数据有关的保留字。它也是动作查询的一部分。\n\nCREATE DATABASE 创建新数据库\nALTER DATABASE 修改数据库\nCREATE TABLE 创建新表\nALTER TABLE 变更（改变）数据库表\nDROP TABLE 删除表\nCREATE INDEX 创建索引（搜索键）\nDROP INDEX 删除索引\n\n\n指针控制语言（CCL）：它的语句，像DECLARE CURSOR，FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作。\n\n\n","categories":["SQL","基础"],"tags":["sql"]},{"title":"SQL笔记（01）——什么是 SQL","url":"https://lujw666.github.io/2021/03/01/sql-01/","content":"结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。\n结构化查询语言是高级的非过程化编程语言，允许用户在高层数据结构上工作。它不要求用户指定对数据的存放方法，也不需要用户了解具体的数据存放方式，所以具有完全不同底层结构的不同数据库系统, 可以使用相同的结构化查询语言作为数据输入与管理的接口。结构化查询语言语句可以嵌套，这使它具有极大的灵活性和强大的功能。\n\n\nRDBMSRDBMS 指关系型数据库管理系统，全称 Relational Database Management System。\nRDBMS 是 SQL 的基础，同样也是所有现代数据库系统的基础。SQL是关系数据库系统的标准语言。所有关系数据库管理系统(RDMS)，如MySQL、MS Access、Oracle、Sybase、Informix、Postgres和SQL Server都使用SQL作为它们的标准数据库语言。\nRDBMS 中的数据存储在被称为表的数据库对象中。\n\n表是相关的数据项的集合，它由列和行组成。\n每个表都被分解成称为字段的更小的实体。字段是表中的一列，用于维护表中每条记录的特定信息。\n记录（也称为行）是表中存在的每个单独条目。\n列是表中的垂直实体，其包含与表中的特定字段相关联的所有信息。\n\n","categories":["SQL","基础"],"tags":["简介","sql"]},{"title":"知乎一小时 015 土豆驯化记","url":"https://lujw666.github.io/2021/03/01/ZhihuOneHour015/","content":"土豆到底叫啥？土豆的中国学名叫马铃薯，它还有很多的别名。广东叫薯仔/荷兰豆，山东叫地蛋，陕北叫山叶，安徽叫地瓜/地豆，云南和四川叫洋芋，湖北叫洋芋，绍兴叫洋番薯，河北叫山药，内蒙叫山药蛋，湖南叫芋头，苏北叫地豆子……\n土豆在国外也有很多好玩的名称，比如地苹果、地梨等等。\n它的拉丁学名叫做 Solanum tuberosum L.，这是在国内最常见的栽培马铃薯种名，在南美其实还有其他的栽培土豆物种，比如 Solanum ajanhuiri, Solanum curtilobum 和 Solanum juzepczukii。\n植物学小提示：在每种语言里，对同一个生物可能有很多不同的叫法，为了能让所有生物都有一个通用的学名，最常用的命名系统叫做二名法，由瑞典植物学家林奈（Linnaeus）于 1753 年推广开来。简单来说，就是植物的属名加上种名，最后再加上命名者的名字。\n茄科植物土豆的属名是 Solanum, 中文是茄属，茄子和番茄也是茄科茄属，它们的拉丁名分别叫 Solanum melongena 和 Sola-num lycopersicum，而番茄是作物里和土豆亲缘关系最近的，这也是为什么科学家多年来一直想培育出地上长番茄、地下长土豆的「番茄土豆」。再往前推一点，茄科（Solanaceae）的物种可就更多了，比如烟草、辣椒、枸杞、酸浆，还有一些有毒的植物，比如颠茄、曼陀罗等等……\n也正是因为不少茄科植物都有毒，所以茄科还有一个很酷的名字叫做「Nightshades」, 翻译过来是「夜影」。\n\n\n土豆的起源和驯化土豆起源于南美的安第斯山脉(陆地上最长的山脉，约有 7000 公里长，平均高度为 4000 米。横穿 8 个南美国家，由北到南依次是委内瑞拉、哥伦比亚、厄瓜多尔、秘鲁、玻利维亚、智利及阿根廷。美洲的第一高峰阿空加瓜山也属于安第斯山脉，它在阿根廷境内，高达 6962 米，是亚洲以外最高的山峰)。\n根据分子生物学的证据，大概 1400 万年前，茄子和番茄土豆的祖先分化；之后在 700 万年前，番茄和土豆分化。而距今大约是在 1 万年前，南美安第斯山脉当地的农民开始驯化土豆作为食物。\n\n\n土豆传入欧洲土豆起源于南美安第斯山脉，当地的印加人称之为「papas」, 而当那些西班牙的探险家们将土豆带回本土的时候，也沿用了这个名字。但后来也许是因为 papa 和「爸爸」的发音很相似，西班牙人将土豆称为 patata。随后传播到了意大利，同样沿用了 patata 这个称呼。在英国，人们习惯称呼土豆为「白土豆」(white potato)，到了西欧，土豆又变成了「地苹果」或者「地梨」，比如法国、荷兰、芬兰甚至希腊都是这么称呼土豆的。后来，随着欧洲殖民活动的展开，土豆的各种外号也传到了不同的殖民地，比如印度的有些地方由于被葡萄牙殖民过，所以叫土豆 batata。而在中国，那些「洋」字头的名字也是因为土豆是西方舶来品。\n土豆刚刚传播到欧洲的时候，名声可并不好。人们通常都是本能地惧怕和排斥新事物，其他作物都是靠种子繁殖，而种土豆一般都是靠一小块种薯，大家觉得这种从地里挖出来的脏兮兮的东西是「魔鬼的食物」，所以那个时候，土豆主要是用来喂猪或者给监狱里的囚犯吃。\n在 17-18 世纪的欧洲，饥饿是个很普遍的现象。从 1500 到 1800 年间，有过 40 场全国范围内的饥荒；平均每十年就发生超过一场。简而言之，欧洲大陆依赖小麦的农业系统不能喂饱自己的人民。\n但土豆改变了这一切。每年农民都会休耕超过一半的谷物田地，一方面为了恢复土壤肥力，同时还要去除杂草。而有了土豆后，农民就可以在这段时间种上土豆。由于土豆产量极高，所以从卡路里的角度来看，它使欧洲的食物供给翻了一倍。\n在 18 世纪末，土豆在欧洲的大部分地方都成为了主食。在爱尔兰，有大概 40% 的人除了土豆吃不到任何固体食物，而在荷兰，比利时，普鲁士和波兰，大概有 10%-30% 的人同样只有土豆吃。在吃土豆的国家，频繁的饥荒从此消失。终于，欧洲这片土地上的人民能吃饱了。    \n\n\n土豆晚疫病土豆晚疫病，这种病害的罪魁祸首——Phytophthora in-festans, 中文学名是致病疫霉。这东西属于卵菌，它主要的宿主是番茄和土豆。致病疫霉是一种半活体寄生的病原菌，它会释放游动孢子，当孢子附着到植物上就会开始萌发，长出菌丝插入植物的细胞吸取养分，在生长的后期杀死植物细胞。它还能全方位的侵染植物，一般是从叶子开始，能看到明显的病斑，之后会快速传播到其他组织，所以即使得病的植株能长出土豆，很可能也是被晚疫病菌侵染过的。 \n土豆的种植方式主要是依靠薯块本身进行无性繁殖，这是因为土豆的基因组高度杂合，且有着自交不亲和或者自交衰退的现象，而通过杂交生产出来的种子，后代的所有性状都会疯狂地分离，导致一块田里的土豆可能长得形状各异。正因为依靠薯块进行的无性繁殖，导致了欧洲的土豆没有任何遗传多样性；好处是人们喜欢的性状都将得以保留，比如大薯块、低茄碱等等。但同时，这也导致了如果它们对某种病原菌缺乏抗性，如果这种病原菌有足够的传播能力，那么所有的土豆都将毁于一旦。\n1845 年 9 月，爱尔兰农民发现土豆遭受了一种以前没见过的病害，这就是晚疫病。在 1845 年晚疫病刚刚传播到爱尔兰的时候，它摧毁了当年 40% 左右的土豆。\n由于当时对于晚疫病缺乏了解，那些被感染的烂土豆都被留在了田里，这就导致了晚疫病菌可以继续存活。到了 1846 年，这些潜伏的晚疫病菌一下子摧毁了 90% 的土豆。而在那个时代，人们对于植物的病害根本束手无策。\n1845 到 1852，由于土豆晚疫病造成的大饥荒，导致超过一百万人饿死，又有超过两百万爱尔兰人移民到其他国家，其中大部分都去了美国。因此爱尔兰的人口几乎下降了一半，至今还没有恢复到大饥荒前的数量。晚疫病可能是爱尔兰人民心中永远的痛，在当地有这么一句爱尔兰谚语：\n\n这个世界上只有两件事绝对不能开玩笑：婚姻和土豆。\n\n\n\n晚疫病后的欧洲土豆晚疫病促进了化学农药的发展。当时土豆瘟疫后，人们想方设法去寻找晚疫病的解决方案。最终有一个人偶然发现用剩下的绿色颜料竟然能杀死晚疫病菌——这种绿色颜料是由砒霜和铜等成分组成——所以开始将这种绿色颜料稀释，然后喷洒到得病的土豆田里。\n对于农民来说，巴黎绿就像是上天的礼物，而化学家们也从中得到启发——如果砒霜能杀死土豆甲虫，那为什么不试试是否能杀死其他害虫呢？如果巴黎绿能杀死晚疫病菌，那其他化学试剂是否能解决别的农业问题？就这样，现代农药产业慢慢开始发展了。\n同时，植物育种家也在努力。他们开始尝试培育出具有晚疫病抗性的土豆，最开始的策略是将野生土豆里的抗性转入栽培土豆。\n这场瘟疫并不能浇灭欧洲人民对土豆的热情，很多文艺作品也在这之后被创作出来，不仅有法国画家米勒于 1861 年创作的「种土豆的」，更有梵高 1885 年创作的「吃土豆的人」。\n同时，土豆也随着欧洲的殖民而流传到全球，比如印度、中国、新西兰、非洲等地。\n土豆到中国中国现在的土豆种植面积和土豆消费量是世界第一，但产量并不高，大概只有荷兰产量的三分之一。2015 年，农业部宣布，将要启动土豆主粮化战略。\n在南方，早在 1603 年，荷兰人就在中国台湾的澎湖岛上种上了土豆，后来在 1623 年到 1662 年，荷兰占领台湾期间，也在台湾岛上开始栽种土豆。之后荷兰人开始和中国东南沿海的省份进行贸易，就在这个时候将土豆引入到东南沿海一带。那里的很多地方，至今还将土豆称为「荷兰薯」。\n和土豆开始在欧洲的冷遇不同，在中国，土豆一上来就是高级货。明朝的时候，土豆被传到北京，作为皇家特供食品，由专门的皇家菜户供应。在清朝取消了明朝的蔬菜供应系统，土豆这才传入民间，登上了百姓的餐桌。\n而西部的土豆可能先是通过印度、缅甸等地传入云南，后来又传到四川、贵州。在当地，现在还有很多人称土豆为洋芋。\n还有一些可能的传入途径，比如是通过俄国传教士，在十七世纪早期由西伯利亚传入山西、陕西，之后又传到东北一代。\n\n\n土豆的育种植物育种可以说是科学和艺术的结合，所以植物育种家不仅仅要有丰富的植物学、遗传学、统计的背景，有时候还需要玩一些花招。为了让作物更好地满足人们的需求，就要靠植物育种家们通过各种手段去改善植物的各种性状。在育种上，有一些性状普遍很重要，比如高产量、抗虫抗病、低龙葵碱、耐旱、耐储藏等等。还有一些性状就完全是为了满足不同的需求或者不同地方人的喜好了。\n按照功能来分类，可以简单地将土豆分为餐用、加工用（薯条、薯片等等）、饲料用和工业用途，每种都要满足不同的标准。工业用途要特殊的支链淀粉，从而更好地应用于造纸业和黏合剂等；加工用的，就需要耐低温储藏，外形适合机器加工，炸出来的薯条、薯片得颜色漂亮；餐用土豆还要考虑不同的加工方法，比如烘烤、油炸、水煮、沙拉用等等。每种用途的土豆都需要特定的性状。\n传统育种通过杂交，从后代中选择出最满意的那个，再通过反复的回交，留下需要的性状，同时去除那些不利的。\n概念：基因池 (gene pool）比如一个人有两万个基因，但是每个基因都可能有不同的等位基因（allels），把几十亿人所有可能的所有等位基因都堆到一起，就是人类的基因池了。\n土豆育种的过程可能非常漫长，短则十几年，慢则几十年。不过借助现代分子生物学工具，可以很大地提高传统育种的速度。\n分子标记辅助育种知道土豆的基因组已经测序，一共有 12 条染色体，图中蓝色的方块就代表这些分子标记，红色代表我们需要的晚疫病抗性基因，灰色方块代表和抗性基因离得很近的「不好的」基因。我们的育种目标是只保留抗病基因，避免高毒素或者容易变黑等不好的性状。现在有了分子标记，我们不需要再像传统育种项目那样进行大规模的表型测试，只需要提取杂交后代的 DNA，然后利用已有的分子标记对这些材料进行基因型筛选就好。\n\n还是以我们的晚疫病抗性育种项目为例，我们需要保留红色的「晚疫病抗性基因」，但同时要去掉茄碱和褐化基因。我们要做的就是寻找带有标记 1 和标记 2，同时不带有标记 3 和标记 4 的个体。当然，受限于群体数量，我们还是要反复进行几轮回交，从而筛选掉大部分野生型的基因组。\n\n有了分子标记这个工具，可以大大加速植物育种，同时让育种项目的目标和结果都变得更加容易掌控。\n分子标记育种的不足\n分子标记从哪儿来？如果需要进行分子标记育种，我们首先要获得分子标记的连锁图谱，这个任务的工作量巨大，需要大量的时间和经费去开发这些分子标记。\n如果我们想要的性状来自不可杂交的材料里怎么办？\n如果我们需要的性状来自动物、细菌，甚至病毒呢？这时候分子标记育种就完全无计可施了。\n\n\n\n土豆基因组的测序随着近几年基因组测序技术的发展，很多植物的基因组都已经完成测序，这对于植物育种有着非常大的帮助。土豆的基因组于 2011 年发表于《 Nature 》杂志。\n2005 年，荷兰的瓦赫尼根大学（Wageningen University and Research Cen-ter）组织了国际上很多高校和科研院所，一起组成了「土豆基因组测序国际协作组」（The Potato Genome Sequencing Consortium ，PGSC），共同发起土豆基因组的测序工作。\n当时，现任中国农科院蔬菜花卉研究所的生物技术室主任黄三文刚刚在瓦赫尼根大学的植物育种组拿到博士学位，他联系了当时农科院副院长屈冬玉（现任农业部副部长，也是瓦大育种组毕业的博士），决定参与这个测序项目。中国农科院负责土豆十二条染色体中两条的测序工作，黄三文作为首席科学家。\n当时二代测序技术正好刚刚兴起，于是黄三文先是和华大基因合作将黄瓜的基因组完成，而那时土豆基因组仍然没有克服瓶颈。于是在积累了二代测序的经验以及各种软件开发后，在 2008 年通过二代测序直接将纯合的双单倍体土豆进行测序。\n\n\n中国的「土豆主粮化」战略2015 年 1 月，农业部宣布中国将启动马铃薯主粮化战略：据农业部消息，我国将启动马铃薯主粮化战略，推进把马铃薯加工成馒头、面条、米粉等主食，马铃薯将成稻米、小麦、玉米外又一主粮。预计 2020 年 50% 以上的马铃薯将作为主粮消费。\n2016 年 1 月，农业部正式发布了文件「关于推进马铃薯产业开发的指导意见」，将马铃薯作为主粮产品进行产业化开发。\n\n\n番茄土豆和火星土豆番茄土豆在驯化土豆的道路上，人们还在发挥着想象力去探索更多的可能性。\n比如土豆只能收获地下的块茎，而地上部分毫无用处；番茄则正好相反。如果能把这俩结合到一起，岂不是能最大化地利用空间？科学家也一直在进行努力和尝试，比如通过传统的杂交手段，由于番茄和土豆都属于茄科茄属，亲缘关系很近，所以如果人工将其杂交，是可以产生种子的，但因为土豆基因组高度杂合，所以后代会出现大量分离，但并没有植株能做到上半部分长番茄而地下部分长土豆。\n还有科学家尝试过体细胞杂交技术，把番茄和土豆的细胞融合到一起。虽然这些融合细胞可以再生出新的植物，但结果同样让人失望。\n最后成功的案例是靠着一个传统的技术——「嫁接」。其售价高达每株 9.99 英镑，从价格来看，目前还是太高，并不适合大规模商业化生产。\n火星土豆看过电影《火星救援》的朋友一定都对在火星种土豆那段故事印象深刻。这并不是什么想象出来的桥段，事实上，在太空种植蔬菜已经开始进入应用阶段了，至少是在空间站上。\n比起其他作物，土豆的最大好处是其既能充当主食提供大量碳水化合物，同时又能起到蔬菜的作用，提供其他所需营养物质。目前 NASA 已经在和国际马铃薯中心（CIP）合作开始在研发火星土豆。\n\n\n后记一万年前的南美安第斯山脉；大航海时代的西班牙探险家；靠着土豆终于能够吃饱的欧洲人民；爱尔兰的土豆瘟疫；伟大的土豆育种家；新一代的植物育种技术以及未来的火星土豆。\n土豆就这样一步步从不起眼的埋在地下脏兮兮的块茎，被人类驯服从而成为世界上第四大粮食作物。\n如今，中国也要进入土豆主粮化时代，希望本文能让更多人了解土豆的故事。\n","categories":["科普","知乎一小时"],"tags":["土豆"]},{"title":"GitHub 命令行 hub","url":"https://lujw666.github.io/2021/02/27/hub/","content":"Hub 是对 git 的一层封装，以便和 GitHub 完美结合，而且对 git 完全兼容，推荐直接将 hub 设置为 git 的别名，所以在执行 git 的时候实际上是在执行 hub。\n\n\nHub安装# 在Debian/Ubuntu中安装apt-get install hub# 在Centos/RedHat中安装yum install hub# 在Mac下的安装brew install hub\n\n\nHub功能\n\n\n命令\n参数\n填写内容\n功能\n等同\n\n\n\nhub clone\n\n仓库名or其他用户名/仓库名\n获取Github远程仓库\ngit clone &#x67;&#105;&#116;&#64;&#103;&#x69;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;/用户名/仓库名.git\n\n\nhub remote add\n\n用户名\n添加Github远程仓库\ngit remote add 标识符 git://github.com/用户名/当前操作仓库的名称.git\n\n\nhub fork\n\n仓库名\nfork仓库\n=（在GitHub上对仓库做Fork处理）git remote add -f 用户名 &#103;&#105;&#x74;&#x40;&#103;&#x69;&#116;&#104;&#117;&#98;&#x2e;&#99;&#111;&#109;:仓库名.git\n\n\nhub pull-request\n-i Issue编号 -b 用户名:接收分支 -h 用户名:发送分支\n\nGithub的pull-request推送\n\n\n\nhub checkout\n\nURL\n在本地检查pull-request分支的运行状况\n\n\n\nhub create\n\n仓库名\n在Github上创建库\n\n\n\nhub push\n\n标识符 分支\n推送至Github远程仓库\n\n\n\nhub browse\n\n\n打开当前操作的仓库在 GitHub 上对应的仓库页面\n\n\n\nhub compare\n\n\n打开 GitHub 上对应的查看差别的页面\n\n\n\n","categories":["Git","扩展"],"tags":["git","github"]},{"title":"GitHub Pages 部署静态网页","url":"https://lujw666.github.io/2021/02/27/githubpages/","content":"Github Page 是 Github 提供的一种免费的静态网页托管服务，可以用来托管博客、项目官网等静态网页。支持 Jekyll、Hugo、Hexo 编译静态资源。\n点击查看如何将 Hexo 博客部署到 GitHub Pages 上\n","categories":["Git","扩展"],"tags":["git","github"]},{"title":"Git Flow 工作流程","url":"https://lujw666.github.io/2021/02/27/gitflow/","content":"Git Flow安装及初始化# 在Debian/Ubuntu中安装apt-get install gitflow# 在Centos/RedHat中安装yum install gitflow# 在Mac下的安装brew install git-flow# 初始化仓库git flow init\n\n\nGit Flow工作流程\n\n\n\n分支\n说明\n\n\n\nmaster\n时常保持着软件可以正常运行的状态。由于要维持这一 状态，所以不允许开发者直接对 master 分支的代码进行修改和提交。其他分支的开发工作进展到可以发布的程度后，将会与 master分支进行合并，而且这一合并只在发布成品时进行。发布时会附加包含版本编号的Git标签（Tag）。\n\n\ndevelop\n开发过程中的代码中心分支。与master分支一样，这个分支也不允许开发者直接进行修改和提交。程序员要以develop分支为起点新建feature分支，在feature分支中进行新功能的开发或者代码的修正。也就是说，develop分支维持着开发过程中的最新源代码，以便程序员创建feature分支进行自己的工作。\n\n\nfeature\n以develop分支为起点，是开发者直接更改代码发送提交的分支。与develop分支合并后，已经完成工作的feature分支就失去了作用，可以在适当的时候删除。\n\n\nrelease\n基于最新develop分支创建，当新功能足够发布一个新版本，从develop分支创建一个release分支作为新版本的起点，用于测试，所有的测试bug在这个分支改。测试完成后合并到master并打上版本号，同时也合并到develop，更新最新开发分支。\n\n\nhotfix\n并不是预期中计划出现的分支。它是一个紧急应对措施，只有当前发布的版本中出现BUG或漏洞，而且其严重程度要求开发方必须立刻处理，无法等到下一个版本发布时，hotfix分支才会 被创建。 因此，hotfix 分支都是以发布版本的标签或master分支为起点。借助hotfix分支，可以在不影响develop分支正常开发的情况下，由其他开发者处理成品的修正工作。\n\n\n\n\nMaster/Devlop分支所有在Master分支上的Commit应该打上Tag，一般情况下Master不存在Commit，Devlop分支基于Master分支创建。\n\n\n\nFeature分支Feature分支做完后，必须合并回Develop分支, 合并完分支后一般会删点这个Feature分支，毕竟保留下来意义也不大。\n\ngit checkout developgit pull origin developgit flow feature start xxx# 在feature/xxx分支中实现目标功能并进行提交git commit -am &quot;&quot;git flow feature finish xxxgit push origin develop\n\n\nRelease分支Release分支基于Develop分支创建，打完Release分支之后，我们可以在这个Release分支上测试，修改Bug等。同时，其它开发人员可以基于Develop分支新建Feature (记住：一旦打了Release分支之后不要从Develop分支上合并新的改动到Release分支)发布Release分支时，合并Release到Master和Develop， 同时在Master分支上打个Tag记住Release版本号，然后可以删除Release分支了。\n\ngit checkout developgit pull origin developgit flow release start &#x27;1.0.0&#x27;# 在release /1.0.0分支中实现目标功能并进行提交git commit -am &quot;&quot;git flow release finish &#x27;1.0.0&#x27;git checkout developgit push origin developgit push origin mastergit push --tags\n\n\nHotfix分支hotfix分支基于Master分支创建，开发完后需要合并回Master和Develop分支，同时在Master上打一个tag。\n\ngit checkout mastergit pull origin mastergit flow hotfix start &#x27;1.0.1&#x27; &#x27;1.0.0&#x27;# 在hotfix /1.0.1分支中实现目标功能并进行提交git commit -am &quot;&quot;git flow hotfix finish 1.0.1git checkout developgit push origin developgit push origin mastergit push --tags","categories":["Git","扩展"],"tags":["git","gitflow"]},{"title":"Git笔记（07）——忽略文件","url":"https://lujw666.github.io/2021/02/27/git-07/","content":"项目中经常会生成一些Git系统不需要追踪(track)的文件。典型的是在编译生成过程中产生的文件或是编程器生成的临时备份文件。\n当然，你不追踪(track)这些文件，可以不用”git add”去把它们加到索引中。 但是这样会很快变成一件烦人的事，会发现项目中到处有未追踪(untracked)的文件。\n可以在你的顶层工作目录中添加一个叫”.gitignore”的文件，来告诉Git系统要忽略掉哪些文件，下面是文件内容的示例:\n# 以&#39;#&#39; 开始的行，被视为注释.# 忽略掉所有文件名是 foo.txt 的文件.foo.txt# 忽略所有生成的 html 文件,*.html# foo.html是手工维护的，所以例外.!foo.html#  忽略所有.o 和 .a文件.*.[oa]\n可以把 .gitignore 文件放到工作树 (working tree) 里的其它目录中，这就会在它和它的子目录起忽略 (ignore) 指定文件的作用。.gitignore 文件同样可以像其它文件一样加到项目仓库里( 直接用 git add .gitignore 和 git commit 等命令), 这样项目里的其它开发者也能共享同一套忽略文件规则。\n如果想忽略规则只对特定的仓库起作用,可以把这些忽略规则写到仓库下 .git/info/exclude文件中，或是写在Git配置变量core.excludesfile中指定的文件里。\n","categories":["Git","进阶"],"tags":["git"]},{"title":"Git笔记（06）——目录","url":"https://lujw666.github.io/2021/02/27/git-06/","content":"Git 目录是为你的项目存储所有历史和元信息的目录 - 包括所有的对象(commits,trees,blobs,tags), 这些对象指向不同的分支。\n.git|-- HEAD         # 这个git项目当前处在哪个分支里|-- config       # 项目的配置信息，git config命令会改动它|-- description  # 项目的描述信息|-- hooks/       # 系统默认钩子脚本目录|-- index        # 索引文件|-- logs/        # 各个refs的历史信息|-- objects/     # Git本地仓库的所有对象 (commits, trees, blobs, tags)|-- refs/        # 标识你项目里的每个分支指向了哪个提交(commit)。","categories":["Git","进阶"],"tags":["git"]},{"title":"Git笔记（05）——基本操作","url":"https://lujw666.github.io/2021/02/27/git-05/","content":"链接：https://lujw666.gitbook.io/learn/git/00-basic/05-ji-ben-cao-zuo\nGit 常用的是以下 6 个命令：git clone、git push、git add 、git commit、git checkout、git pull。\n\n说明：\n\nworkspace：工作区\nstaging area：暂存区/缓存区\nlocal repository：或本地仓库\nremote repository：远程仓库\n\n\n\n创建仓库\n\n\n命令\n说明\n\n\n\ngit init\n初始化仓库\n\n\ngit clone\n拷贝一份远程仓库，也就是下载一个项目\n\n\n\n\n提交与修改\n\n\n命令\n说明\n\n\n\ngit add\n添加文件到仓库\n\n\ngit status\n查看仓库当前的状态，显示有变更的文件\n\n\ngit diff\n比较文件的不同，即暂存区和工作区的差异\n\n\ngit commit\n提交暂存区到本地仓库\n\n\ngit reset\n回退版本\n\n\ngit rm\n删除工作区文件\n\n\ngit mv\n移动或重命名工作区文件\n\n\n\n\n分支管理\n\n\n命令\n说明\n\n\n\ngit branch\n显示或创建分支命令\n\n\ngit checkout\n切换分支命令\n\n\ngit merge\n合并分支命令\n\n\n\n\n远程操作\n\n\n命令\n说明\n\n\n\ngit remote\n远程仓库操作\n\n\ngit fetch\n从远程获取代码库\n\n\ngit pull\n下载远程代码并合并\n\n\ngit push\n上传远程代码并合并\n\n\n\n\n标签\n\n\n命令\n说明\n\n\n\ngit tag\n给提交打上标签\n\n\n\n\n提交日志\n\n\n命令\n说明\n\n\n\ngit log\n查看历史提交记录\n\n\ngit blame\n以列表形式查看指定文件的历史修改记录\n\n\n","categories":["Git","基础"],"tags":["git"]},{"title":"Git笔记（04）——工作流程","url":"https://lujw666.github.io/2021/02/27/git-04/","content":"\n克隆 Git 资源作为工作目录。\n在克隆的资源上添加或修改文件。\n如果其他人修改了，你可以更新资源。\n在提交前查看修改。\n提交修改。\n在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。\n\n\n\n\n基本概念\n工作区：能看到的目录\n版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。\n暂存区：一般存放在 .git 目录下的 index 文件（.git/index）中，所以把暂存区有时也叫作索引（index）。\n\n\n\n图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage/index），标记为 “master” 的是 master 分支所代表的目录树。\n图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。\n图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。\n当对工作区修改（或新增）的文件执行 git add 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。\n当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。\n当执行 git reset HEAD 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。\n当执行 git rm –cached [file] 命令时，会直接从暂存区删除文件，工作区则不做出改变。\n当执行 git checkout . 或者 git checkout – [file] 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。\n当执行 git checkout HEAD . 或者 git checkout HEAD [file] 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。\n\n","categories":["Git","基础"],"tags":["git"]},{"title":"Git笔记（03）——配置","url":"https://lujw666.github.io/2021/02/27/git-03/","content":"Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。\n这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量存放在以下三个不同的地方：\n\n/etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 –system 选项，读写的就是这个文件。\n~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 –global 选项，读写的就是这个文件。\n当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。\n\n在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\\Documents and Settings$USER。\n此外，Git 还会尝试找寻 /etc/gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。\n\n\n用户信息配置个人的用户名称和电子邮件地址：\ngit config --global user.name &quot;用户名&quot;git config --global user.email &quot;邮箱&quot;\n如果用了 –global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。\n如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。\n\n\n查看配置信息要检查已有的配置信息，可以使用 git config –list 命令。\n有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 /etc/gitconfig 和 ~/.gitconfig），不过最终 Git 实际采用的是最后一个。\n配置也可以在 ~/.gitconfig 或 /etc/gitconfig 看到，也可以直接查阅某个环境变量的设定，只要把特定的名字跟在 git config 后面即可。\n","categories":["Git","基础"],"tags":["git"]},{"title":"Git笔记（02）——安装","url":"https://lujw666.github.io/2021/02/27/git-02/","content":"Linux 平台上安装Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。\n\n\nDebian/UbuntuDebian/Ubuntu Git 安装命令为：\napt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-devapt-get install git\n\n\nCentos/RedHat如果你使用的系统是 Centos/RedHat 安装命令为：\nyum install curl-devel expat-devel gettext-devel openssl-devel zlib-develyum -y install git-core\n\n\nWindows 平台上安装安装包下载地址：https://gitforwindows.org/\n官网慢，可以用国内的镜像：https://npm.taobao.org/mirrors/git-for-windows/\n完成安装之后，就可以使用命令行的 git 工具（自带 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。在开始菜单里找到”Git”-&gt;”Git Bash”，会弹出 Git 命令窗口，你可以在该窗口进行 Git 操作。\n\n\nMac 平台上安装在 Mac 平台上安装 Git 最容易的当属使用图形化的 Git 安装工具，下载地址为：http://sourceforge.net/projects/git-osx-installer/\n","categories":["Git","基础"],"tags":["git","安装"]},{"title":"Git笔记（01）——简介","url":"https://lujw666.github.io/2021/02/27/git-01/","content":"Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。\n\n\nGit 与 SVN 区别Git 不仅仅是个版本控制系统，它也是个内容管理系统(CMS)，工作管理系统等。\nGit 与 SVN 区别点：\n\nGit 是分布式的，SVN 不是：这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。\nGit 把内容按元数据方式存储，而 SVN 是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。\nGit 分支和 SVN 的分支不同：分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。\nGit 没有一个全局的版本号，而 SVN 有：目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。\nGit 的内容完整性要优于 SVN：Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。\n\n\n\n\nGit 快速入门Git 简明指南: https://www.runoob.com/manual/git-guide/\nGit 完整命令手册地址：http://git-scm.com/docs\nGit Community book 中文版：http://gitbook.liuhui998.com/\nPDF 版命令手册：github-git-cheat-sheet.pdf\n","categories":["Git","基础"],"tags":["简介","git"]},{"title":"空间代谢组分析（3）——质谱数据处理","url":"https://lujw666.github.io/2021/02/25/spatialmeta-03/","content":"raw to mzml（弃用）使用ProteoWizard的msconvert软件可将质谱数据（.raw、.wiff格式数据）转格式为mzML格式。\nProteoWizard官网:http://proteowizard.sourceforge.net/\nMSConvertWindows操作msconvert提供了 Windows 平台和 Linux 平台。\n在 Windows 上使用也比较简单：\n\n入文件位置和输出文件位置；\n选择输出格式和编码精度；\n添加（add）所需要的功能 （Peak Picking）。\n点击右下角的开始（Start）\n\n\n\n\nLinux操作msconvert在linux系统安装较为复杂，可直接调用docker image进行使用。\ndocker hub:https://hub.docker.com/r/chambm/pwiz-skyline-i-agree-to-the-vendor-licenses\n也可使用https://hub.docker.com/r/lujiawei/msconvert，image相同仅修改tag名。\n对于msconvert命令行查看帮助：\ndocker run -it --rm \\chambm/pwiz-skyline-i-agree-to-the-vendor-licenses \\wine msconvert --help\n对于msconvert命令行使用：\ndocker run -it --rm \\-e WINEDEBUG=-all \\-v /your/data:/data \\chambm/pwiz-skyline-i-agree-to-the-vendor-licenses \\wine msconvert /data/file.raw\n\n\nmzML to imzML（弃用）imzMLConverter 允许将mzML质谱中间数据转化为imzML质谱成像数据，还允许将多个imzML文件组合成一个单一的imzML文件进行比较和数据处理。\nimzMLConverter官网:https://www.cs.bham.ac.uk/~ibs/imzMLConverter/\n\n\n\nraw to imzMLjimzMLConverterjimzMLConverter软件可以直接将质谱数据转化为imzML格式。\njimzMLConverter:https://github.com/AlanRace/imzMLConverter\njimzMLConverter Dockerfile:https://github.com/AlanRace/imzmlconverter-docker\njimzMLConverter docker image:https://hub.docker.com/r/alanrace/imzmlconverter\ndocker run -it --rm -v /path/to/mydata:/mydata \\alanrace/imzmlconverter:latest \\jimzMLConverter imzML /mydata/data.RAW\n\njimzMLConverter优势：\n\n可直接对质谱数据（.raw、.wiff）处理。\n能通过脚本直接调用。\n\n\n\njimzMLConverter问题：\n\n脚本调用要循环调用，一次调用仅能对一个数据进行处理，多文件处理是会以第一个文件覆盖处理不能合并。\n不能将多个imzML合并为一个imzML，但后续流程可实现此操作。\n\n\n\n\n格式转化R脚本-RawToImzML.R（弃用）R语言调用alanrace/imzmlconverter镜像使用jimzMLConverter脚本：\n#!/opt/conda/bin/Rscript  # 弃用，效率低# 文件名RawToImzML.R# 保存路径:/public/LM-database/script/SpatialMetaboAnalysis# 调用:/public/LM-database/script/SpatialMetaboAnalysis/RawToImzML.R# jimzMLConvert函数RawToImzML &lt;- function(filepath,                       format = &quot;raw&quot;,                       intern= FALSE,                       ignore.stdout = FALSE,                       ignore.stderr = FALSE,                       wait = TRUE)&#123;    # 获取路径下format格式文件信息  dirname &lt;- list.files(path = filepath,                        pattern = paste0(format,&quot;$&quot;),                        full.names = F,                        recursive = T)    # 循环调用docker image:alanrace/imzmlconverter  for ( i in 1:length(dirname)) &#123;        system(paste0(&quot;docker run -i --rm &quot;,                  &quot;-v &quot;,filepath,&quot;:/mydata &quot;,                  &quot;alanrace/imzmlconverter:latest &quot;,                  &quot;jimzMLConverter imzML &quot;,                  &quot;/mydata/&quot;,dirname[i]),           intern = intern,           ignore.stdout = ignore.stdout,           ignore.stderr = ignore.stderr,           wait =wait)    # 为保证循环正常运行，每一次循环暂停docker调用5s    Sys.sleep(5)  &#125;  &#125;# 获取当前路径filepath &lt;- getwd()# 对当前路径下format格式文件转化为imzMLRawToImzML(filepath = filepath)\n\n\n格式转化sh脚本-RawToImzML.shalanrace/imzmlconverter镜像调用jimzMLConverter:\n#!/bin/bash# 文件名RawToImzML.sh# 保存路径:/public/LM-database/script/SpatialMetaboAnalysis# docker调用:docker run -it --rm -v /path:/mydata -v /public/LM-database/script/SpatialMetaboAnalysis:/script alanrace/imzmlconverter:latest /script/RawToImzML.sh# 寻找目录下.raw格式文件name=$(find /mydata -type f -name &quot;*.raw&quot;)# 由于jimzMLConverter不能批量转换，所以循环对raw文件进行imzml格式转换for i in $namedo   jimzMLConverter imzML $idone\n\n\n调用RawToImzML.R（弃用）shell中调用RawToImzML.R：\n# 弃用，效率低# 目录定位于处理目录cd /to/pathRscript /public/LM-database/script/SpatialMetaboAnalysis/RawToImzML.R\nR中调用RawToImzML.R：\n#!/opt/conda/bin/Rscript# 弃用，效率低# 文件名CallRawToImzML.R# 保存路径:/public/LM-database/script/SpatialMetaboAnalysis# 调用:/public/LM-database/script/SpatialMetaboAnalysis/CallRawToImzML.Rsetwd(&quot;raw&quot;)# 调用RawToImzML.Rsystem(&quot;/opt/conda/bin/Rscript /public/LM-database/script/SpatialMetaboAnalysis/RawToImzML.R&quot;,       ignore.stdout = F,       ignore.stderr = F,       wait = T)setwd(&quot;../&quot;)\n\n\n调用RawToImzML.shshell中调用RawToImzML.sh：\n#!/bin/bash# 文件名CallRawToImzML.sh# 保存路径:/public/LM-database/script/SpatialMetaboAnalysis# 调用:/public/LM-database/script/SpatialMetaboAnalysis/CallRawToImzML.sh# 工作目录移动到raw目录cd raw# 获取当前工作目录路径path=$(pwd)# 使用alanrace/imzmlconverter调用RawToImzML.sh脚本docker run -i --rm \\-v $path:/mydata \\-v /public/LM-database/script/SpatialMetaboAnalysis:/script \\alanrace/imzmlconverter:latest \\/script/RawToImzML.sh\n","categories":["代谢","扩展"],"tags":["空间代谢组"]},{"title":"空间代谢组分析（2）——分析流程","url":"https://lujw666.github.io/2021/02/25/spatialmeta-02/","content":"分析流程说明\n质谱数据处理，将raw格式转化为imzML格式\n\nimzML预处理\n\n\n多imzML文件合并\n参照样本选择(默认导入第一个imzML数据为参照样本，可选择)\n参照样本y轴(保留时间)对齐处理(处理方式)\n参照样本背景扣除\n参照样本峰对齐，导出mz数据\n其余样本y轴(保留时间)对齐处理\n其余样本背景扣除\n以mz数据对其余样本峰对齐\n\n\n\n样本分割\n\n\n玻片排样规则表格填写\n根据排样规则对imzML数据切割\n初始样本imzML数据,并绘制成像图\n根据成像图判断是否背景扣除准确，是否样本分给准确\n根据成像图修整将样本imzML人工修整\n样本数据聚类分析\n将聚类分析可视化结果给客户作为选区参考\n\n\n\n样本选区\n\n\n人工或聚类选区\n导出选区质谱成像图、选区信息数据、mean和all定量数据\n将选区、分组、比较组信息整理\n\n\n\n搜库定性(根据mz数据定性)\n\n比较分析\n\n\n\n\n\n分析脚本流程# 创建项目文件夹mkdir filenamecd filename# 将空间质谱数据放入raw文件夹中# raw文件格式，根据正负离子创建文件夹，后将根据玻片或样本创建文件夹.filename|── raw|\t|── neg|\t|\t|── sample1|\t|\t|\t|-- sample1-001.raw|\t|\t|\t|-- sample1-002.raw|\t|\t|\t|-- ···|\t|\t|── sample2|\t|\t|\t|-- sample2-001.raw|\t|\t|\t|-- sample2-002.raw|\t|\t|\t|-- ···|\t|\t|-- ···|\t|── pos|\t|\t|\t|-- sample1-001.raw|\t|\t|\t|-- sample1-002.raw|\t|\t|\t|-- ···|\t|\t|── sample2|\t|\t|\t|-- sample2-001.raw|\t|\t|\t|-- sample2-002.raw|\t|\t|\t|-- ···|\t|\t|-- ···# 将raw格式转化为imzML格式/public/LM-database/script/SpatialMetaboAnalysis/CallRawToImzML.sh# 多imzML文件合并/public/LM-database/script/SpatialMetaboAnalysis/MulImzMLToOne.sh# 上述脚本生成imzml目录后生成相应文件.filename|── imzml|\t|── neg|\t|\t|── sample1|\t|\t|\t|-- silde.imzML|\t|\t|── sample2|\t|\t|\t|-- silde.imzML|\t|\t|-- ···|\t|── pos|\t|\t|── sample1|\t|\t|\t|-- silde.imzML|\t|\t|── sample2|\t|\t|\t|-- silde.imzML|\t|\t|-- ···\n","categories":["代谢","扩展"],"tags":["空间代谢组"]},{"title":"空间代谢组分析（1）——分析环境","url":"https://lujw666.github.io/2021/02/25/spatialmeta-01/","content":"本分析会调用多套docker镜像。\n质谱数据处理环境可在常规分析环境中脚本调用质谱数据处理环境运行脚本\nalanrace/imzmlconverter:https://hub.docker.com/r/alanrace/imzmlconverter\n# 使用alanrace/imzmlconverter调用jimzMLConverter软件docker run -i --rm \\-v /path/to/mydata:/mydata \\alanrace/imzmlconverter:latest \\jimzMLConverter imzML /mydata/data.RAW# 使用alanrace/imzmlconverter调用脚本docker run -i --rm \\-v /path/to/mydata:/mydata \\-v /path/to/script:/script \\alanrace/imzmlconverter:latest \\/script/XXX.script# 使用alanrace/imzmlconverterdocker run -it --rm \\-v /path/to/mydata:/mydata \\-v /path/to/script:/script \\alanrace/imzmlconverter:latest \\bash\n\n\nimzML预处理环境可在常规分析环境中脚本调用预处理环境运行脚本\nlujiawei/cardinalenv:https://hub.docker.com/r/lujiawei/cardinalenv\n# 使用lujiawei/cardinalenv调用脚本docker run -i --rm \\-v /public:/public \\-v /etc/sysconfig/docker:/etc/sysconfig/docker \\-v /var/run/docker.sock:/var/run/docker.sock \\-v /usr/bin/docker:/usr/bin/docker \\lujiawei/cardinalenv \\/path/to/script/XXX.script# 使用lujiawei/cardinalenvdocker run -d --privileged \\-v /public:/public \\-v /etc/sysconfig/docker:/etc/sysconfig/docker \\-v /var/run/docker.sock:/var/run/docker.sock \\-v /usr/bin/docker:/usr/bin/docker \\-p 8082:22 -p 8789:8787 \\--name cardinalenv \\lujiawei/cardinalenv\n\n\n常规分析环境lujiawei/lumingos(加密，仅lujiawei账户可拉取，不对外使用):https://hub.docker.com/r/lujiawei/lumingos\n# 使用lujiawei/lumingos调用脚本docker run -i --rm \\-v /public:/public \\-v /etc/sysconfig/docker:/etc/sysconfig/docker \\-v /var/run/docker.sock:/var/run/docker.sock \\-v /usr/bin/docker:/usr/bin/docker \\lujiawei/lumingos \\/path/to/script/XXX.script# 使用lujiawei/lumingosdocker run -d --privileged \\-v /public:/public \\-v /data/mzdata:/data/mzdata \\-v /etc/sysconfig/docker:/etc/sysconfig/docker \\-v /var/run/docker.sock:/var/run/docker.sock \\-v /usr/bin/docker:/usr/bin/docker \\-p 8080:22 -p 8787:8787 -p 3838:3838\\--name ssh \\lujiawei/lumingos# 通过22端口进入容器后开启以下功能rstudio-server startnohup shiny-server &amp;# 可通过ip:8787链接使用rstudio-server\n","categories":["代谢","扩展"],"tags":["空间代谢组"]},{"title":"个人简历","url":"https://lujw666.github.io/2021/02/23/profile/","content":"陆嘉伟 / Jiawei Lu生物信息分析工程师 / Bioinformatics Analysis Engineer&nbsp;&#x6c;&#106;&#x77;&#x31;&#56;&#x37;&#x32;&#49;&#51;&#x32;&#55;&#52;&#x37;&#50;&#x40;&#x6f;&#117;&#116;&#x6c;&#111;&#x6f;&#107;&#x2e;&#x63;&#111;&#x6d;\nhttps://lujw666.gitbook.io/learn/\n\n关于我本人进取主动、独立性强、具有高度的职责感和敬业精神，待人真诚、诚实守信、团结协作意识强，能够吃苦耐劳，勇于挑战新事物，具有必须的开拓创新本事。具备丰富的工作经验，认真踏实负责，熟练掌握python/R/shell语言，熟悉git、gitlab等项目开发协作平台的使用，掌握SQL使用。\n\n工作经历上海鹿明生物科技有限公司&emsp;&emsp;&emsp;&emsp;2018/9-至今\n生物信息分析主管\n工作描述:\n\n负责管理生物信息分析部组日常分析工作；\n组织及负责生物信息分析平台搭建及维护;\n根据文献和客户需求完成个性化分析需求，并配合其他部门解决数据分析相关问题;\n负责达成公司生物信息开发、维护和升级已有生物信息分析流程，对数据分析流程进行优化；\n\n\n教育经历江苏大学&emsp;生物技术&emsp;本科&emsp;&emsp;2011/9-2015/7\n专业描述：\n本科阶段主修：生物化学，无机化学，有机化学，物理化学，细胞生物学，微生物学，植物学，动物学，生化分离工程，基因工程，发酵工程，酶工程，细胞工程，遗传学，分子生物学，生物信息学，蛋白质组学，食品生物技术。\n\n培训经历超级经理人&emsp;上海大企之道有限公司&emsp;&emsp;2019/10-2020/10\n培训描述：以企业中高层管理团队为培养对象的系统化训练模式，既是目前富有成效的团队素质提升系统，也是推动组织目标高效达成的支持体系\n\n技能特长\n","categories":[],"tags":["其他"]},{"title":"Markdown之reveal.js","url":"https://lujw666.github.io/2021/02/23/reveal-js/","content":"reveal.js是一个使用HTML和Markdown快速创建和演示幻灯片的工具。\nreveal.js的主要功能如下：\n\n可创建水平和垂直幻灯片，支持幻灯片链接，可在幻灯片之间跳转。\n可使用Markdown和HTML编写内容，也支持引用独立的Markdown文件。\n可使用颜色、图片、视频、网页做为背景。\n可添加演讲者注释，支持一键打开。\n可配置幻灯片的主题和过渡动画，有多种方案可供选择。\n可在手机或平板电脑上打开和演示幻灯片。\n可打印和导出PDF格式的文档。\n可以安装很多实用的插件来增强幻灯片的功能和演示效果。\n自由度大，可灵活定制。\n支持很多快捷键的使用，操作非常方便。\n\n\n\n相关链接reveal.js 官网：https://revealjs.com/reveal.js 教程:https://sspai.com/post/40657\n","categories":["Markdown","扩展"],"tags":["markdown","reveal.js"]},{"title":"Markdown之mermaid插件","url":"https://lujw666.github.io/2021/02/23/mermaid/","content":"mermaid插件画流程图、时序图(顺序图)、甘特图。\n官网说明:https://mermaid-js.github.io/mermaid/#/\n\n\n横向流程图graph LRA[方形] --&gt;B(圆角)    B --&gt; C&#123;条件a&#125;    C --&gt;|a&#x3D;1| D[结果1]    C --&gt;|a&#x3D;2| E[结果2]    F[横向流程图]\n\n\n\n竖向流程图graph TDA[方形] --&gt; B(圆角)    B --&gt; C&#123;条件a&#125;    C --&gt; |a&#x3D;1| D[结果1]    C --&gt; |a&#x3D;2| E[结果2]    F[竖向流程图]\n\n\n\nUML时序图%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头sequenceDiagram    participant 张三    participant 李四    张三-&gt;王五: 王五你好吗？    loop 健康检查        王五-&gt;王五: 与疾病战斗    end    Note right of 王五: 合理 食物 &lt;br&#x2F;&gt;看医生...    李四--&gt;&gt;张三: 很好!    王五-&gt;李四: 你怎么样?    李四--&gt;王五: 很好!\n\n\n\n甘特图gantt    dateFormat  YYYY-MM-DD    title 软件开发甘特图    section 设计    需求                      :done,    des1, 2014-01-06,2014-01-08    原型                      :active,  des2, 2014-01-09, 3d    UI设计                     :         des3, after des2, 5d    未来任务                     :         des4, after des3, 5d    section 开发    学习准备理解需求                      :crit, done, 2014-01-06,24h    设计框架                             :crit, done, after des2, 2d    开发                                 :crit, active, 3d    未来任务                              :crit, 5d    耍                                   :2d    section 测试    功能测试                              :active, a1, after des3, 3d    压力测试                               :after a1  , 20h    测试报告                               : 48h\n\n","categories":["Markdown","扩展"],"tags":["markdown","mermaid"]},{"title":"Swarm 集群管理","url":"https://lujw666.github.io/2021/02/23/docker-swarn/","content":"Docker Swarm 是 Docker 的集群管理工具。它将 Docker 主机池转变为单个虚拟 Docker 主机。 Docker Swarm 提供了标准的 Docker API，所有任何已经与 Docker 守护程序通信的工具都可以使用 Swarm 轻松地扩展到多个主机。\n支持的工具包括但不限于以下各项：\n\nDokku\nDocker Compose\nDocker Machine\nJenkins\n\n\n\n原理swarm 集群由管理节点（manager）和工作节点（work node）构成。\n\nswarm mananger：负责整个集群的管理工作包括集群配置、服务管理等所有跟集群有关的工作。\nwork node：即图中的 available node，主要负责运行相应的服务来执行任务（task）。\n\n\n\n\n使用1、创建 swarm 集群管理节点（manager）\n创建 docker 机器：\n$ docker-machine create -d virtualbox swarm-manager\n\n初始化 swarm 集群，进行初始化的这台机器，就是集群的管理节点。\n$ docker-machine ssh swarm-manager$ docker swarm init --advertise-addr 192.168.99.107 #这里的 IP 为创建机器时分配的 ip。\n\n以上输出，证明已经初始化成功。需要把以下这行复制出来，在增加工作节点时会用到：\ndocker swarm join --token SWMTKN-1-4oogo9qziq768dma0uh3j0z0m5twlm10iynvz7ixza96k6jh9p-ajkb6w7qd06y1e33yrgko64sk 192.168.99.107:2377\n2、创建 swarm 集群工作节点（worker）\n这里直接创建好俩台机器，swarm-worker1 和 swarm-worker2 。\n\n分别进入两个机器里，指定添加至上一步中创建的集群，这里会用到上一步复制的内容。\n\n以上数据输出说明已经添加成功。\n上图中，由于上一步复制的内容比较长，会被自动截断，实际上在图运行的命令如下：\n$ docker swarm join --token SWMTKN-1-4oogo9qziq768dma0uh3j0z0m5twlm10iynvz7ixza96k6jh9p-ajkb6w7qd06y1e33yrgko64sk 192.168.99.107:2377\n3、查看集群信息\n进入管理节点，执行：docker info 可以查看当前集群的信息。\n$ docker info\n\n通过画红圈的地方，可以知道当前运行的集群中，有三个节点，其中有一个是管理节点。\n4、部署服务到集群中\n注意：跟集群管理有关的任何操作，都是在管理节点上操作的。\n以下例子，在一个工作节点上创建一个名为 helloworld 的服务，这里是随机指派给一个工作节点：\ndocker@swarm-manager:~$ docker service create --replicas 1 --name helloworld alpine ping docker.com\n\n5、查看服务部署情况\n查看 helloworld 服务运行在哪个节点上，可以看到目前是在 swarm-worker1 节点：\ndocker@swarm-manager:~$ docker service ps helloworld\n\n查看 helloworld 部署的具体信息：\ndocker@swarm-manager:~$ docker service inspect --pretty helloworld\n\n6、扩展集群服务\n将上述的 helloworld 服务扩展到俩个节点。\ndocker@swarm-manager:~$ docker service scale helloworld=2\n可以看到已经从一个节点，扩展到两个节点。\n\n7、删除服务\ndocker@swarm-manager:~$ docker service rm helloworld\n查看是否已删除：\n\n8、滚动升级服务\n将介绍 redis 版本如何滚动升级至更高版本。\n创建一个 3.0.6 版本的 redis。\ndocker@swarm-manager:~$ docker service create --replicas 1 --name redis --update-delay 10s redis:3.0.6\n\n滚动升级 redis 。\ndocker@swarm-manager:~$ docker service update --image redis:3.0.7 redis\n\n看图可以知道 redis 的版本已经从 3.0.6 升级到了 3.0.7，说明服务已经升级成功。\n9、停止某个节点接收新的任务\n查看所有的节点：\ndocker@swarm-manager:~$ docker node ls\n\n可以看到目前所有的节点都是 Active, 可以接收新的任务分配。\n停止节点 swarm-worker1：\n\n注意：swarm-worker1 状态变为 Drain。不会影响到集群的服务，只是 swarm-worker1 节点不再接收新的任务，集群的负载能力有所下降。\n可以通过以下命令重新激活节点：\ndocker@swarm-manager:~$  docker node update --availability active swarm-worker1\n\n","categories":["Docker","扩展"],"tags":["docker","swarn"]},{"title":"Docker Machine","url":"https://lujw666.github.io/2021/02/23/docker-machine/","content":"Docker Machine 是一种可以让您在虚拟主机上安装 Docker 的工具，并可以使用 docker-machine 命令来管理主机。\n使用 docker-machine 命令，您可以启动，检查，停止和重新启动托管主机，也可以升级 Docker 客户端和守护程序，以及配置 Docker 客户端与您的主机进行通信。\n\n\n安装安装 Docker Machine 之前你需要先安装 Docker。\nDocker Machine 可以在多种平台上安装使用，包括 Linux 、MacOS 以及 windows。\n\n\nLinux 安装命令$ base=https://github.com/docker/machine/releases/download/v0.16.0 &amp;&amp;  curl -L $base/docker-machine-$(uname -s)-$(uname -m) &gt;/tmp/docker-machine &amp;&amp;  sudo mv /tmp/docker-machine /usr/local/bin/docker-machine &amp;&amp;  chmod +x /usr/local/bin/docker-machine\n\n\nmacOS 安装命令$ base=https://github.com/docker/machine/releases/download/v0.16.0 &amp;&amp;  curl -L $base/docker-machine-$(uname -s)-$(uname -m) &gt;/usr/local/bin/docker-machine &amp;&amp;  chmod +x /usr/local/bin/docker-machine\n\n\nWindows 安装命令如果是 Windows 平台，可以使用 Git BASH，并输入以下命令：\n$ base=https://github.com/docker/machine/releases/download/v0.16.0 &amp;&amp;  mkdir -p &quot;$HOME/bin&quot; &amp;&amp;  curl -L $base/docker-machine-Windows-x86_64.exe &gt; &quot;$HOME/bin/docker-machine.exe&quot; &amp;&amp;  chmod +x &quot;$HOME/bin/docker-machine.exe&quot;\n\n\n使用1、列出可用的机器\n$ docker-machine ls\n2、创建机器\n创建一台名为 test 的机器。\n$ docker-machine create --driver virtualbox test\n\n–driver：指定用来创建机器的驱动类型，这里是 virtualbox。\n\n3、查看机器的 ip\n$ docker-machine ip test\n4、停止机器\n$ docker-machine stop test\n5、启动机器\n$ docker-machine start test\n6、进入机器\n$ docker-machine ssh test\n\n\ndocker-machine 命令参数说明\nactive：查看当前激活状态的 Docker 主机。\nconfig：查看当前激活状态 Docker 主机的连接信息。\ncreat：创建 Docker 主机\nenv：显示连接到某个主机需要的环境变量\ninspect： 以 json 格式输出指定Docker的详细信息\nip： 获取指定 Docker 主机的地址\nkill： 直接杀死指定的 Docker 主机\nls： 列出所有的管理主机\nprovision： 重新配置指定主机\nregenerate-certs： 为某个主机重新生成 TLS 信息\nrestart： 重启指定的主机\nrm： 删除某台 Docker 主机，对应的虚拟机也会被删除\nssh： 通过 SSH 连接到主机上，执行命令\nscp： 在 Docker 主机之间以及 Docker 主机和本地主机之间通过 scp 远程复制数据\nmount： 使用 SSHFS 从计算机装载或卸载目录\nstart： 启动一个指定的 Docker 主机，如果对象是个虚拟机，该虚拟机将被启动\nstatus： 获取指定 Docker 主机的状态(包括：Running、Paused、Saved、Stopped、Stopping、Starting、Error)等\nstop： 停止一个指定的 Docker 主机\nupgrade： 将一个指定主机的 Docker 版本更新为最新\nurl： 获取指定 Docker 主机的监听 URL\nversion： 显示 Docker Machine 的版本或者主机 Docker 版本\nhelp： 显示帮助信息\n\n","categories":["Docker","扩展"],"tags":["docker"]},{"title":"Docker Compose","url":"https://lujw666.github.io/2021/02/23/docker-compose/","content":"docker compose 用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。\nCompose 使用的三个步骤：\n\n使用 Dockerfile 定义应用程序的环境。\n使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。\n最后，执行 docker-compose up 命令来启动并运行整个应用程序。\n\ndocker-compose.yml 的配置案例:\n# yaml 配置实例version: &#x27;3&#x27;services:  web:    build: .    ports:   - &quot;5000:5000&quot;    volumes:   - .:/code    - logvolume01:/var/log    links:   - redis  redis:    image: redisvolumes:  logvolume01: &#123;&#125;\n\n\nDocker-compose 安装Linux 平台上安装Debian/UbuntuDebian/Ubuntu 安装命令为：\napt-get install -y docker-compose\nCentos/RedHat如果你使用的系统是 Centos/RedHat 安装命令为：\npip install docker-compose\n\n\nWindows/macOS 平台上安装Windows/macOS 的 Docker 桌面版和 Docker Toolbox 已经包括 Compose 和其他 Docker 应用程序，因此用户不需要单独安装 Compose。\n\n\nDocker-compose 常用命令Docker-compose命令格式docker-compose [-f &lt;arg&gt;...] [options] [COMMAND] [ARGS...]\n\n-f –file FILE指定Compose模板文件，默认为docker-compose.yml\n-p –project-name NAME 指定项目名称，默认使用当前所在目录为项目名\n–verbose  输出更多调试信息\n-v，-version 打印版本并退出\n–log-level LEVEL 定义日志等级(DEBUG, INFO, WARNING, ERROR, CRITICAL)\n\n\n\ndocker-compose up启动应用程序\ndocker-compose up [options] [--scale SERVICE=NUM...] [SERVICE...]\n\n-d 在后台运行服务容器\n-no-color 不是有颜色来区分不同的服务的控制输出\n-no-deps 不启动服务所链接的容器\n–force-recreate 强制重新创建容器，不能与-no-recreate同时使用\n–no-recreate 如果容器已经存在，则不重新创建，不能与–force-recreate同时使用\n–no-build 不自动构建缺失的服务镜像\n–build 在启动容器前构建服务镜像\n–abort-on-container-exit 停止所有容器，如果任何一个容器被停止，不能与-d同时使用\n-t, –timeout TIMEOUT 停止容器时候的超时（默认为10秒）\n–remove-orphans 删除服务中没有在compose文件中定义的容器\n\n\n\ndocker-compose ps列出项目中所有的容器\ndocker-compose  ps [options] [SERVICE...]\n\n\ndocker-compose stop停止正在运行的容器\ndocker-compose stop [options] [SERVICE...]\n\n-t, –timeout TIMEOUT 停止容器时候的超时（默认为10秒）\n\n停止运行的容器，可以通过docker-compose start 再次启动\n\n\ndocker-compose -h查看帮助\n\n\ndocker-compose down停止和删除容器、网络、卷、镜像\ndocker-compose down [options]\n\n–rmi type，删除镜像，类型必须是：all，删除compose文件中定义的所有镜像；local，删除镜像名为空的镜像\n-v, –volumes，删除已经在compose文件中定义的和匿名的附在容器上的数据卷\n–remove-orphans，删除服务中没有在compose中定义的容器\n\n\n\ndocker-compose logs查看服务容器的输出\ndocker-compose logs [options] [SERVICE...]\n\n-f 跟踪日志输出\n\n默认情况下，docker-compose将对不同的服务输出使用不同的颜色来区分。可以通过–no-color来关闭颜色。\n\n\ndocker-compose bulid构建（重新构建）项目中的服务容器\ndocker-compose build [options] [--build-arg key=val...] [SERVICE...]\n\n–compress 通过gzip压缩构建上下环境\n–force-rm 删除构建过程中的临时容器\n–no-cache 构建镜像过程中不使用缓存\n–pull 始终尝试通过拉取操作来获取更新版本的镜像\n-m, –memory MEM为构建的容器设置内存大小\n–build-arg key=val为服务设置build-time变量\n服务容器一旦构建后，将会带上一个标记名。可以随时在项目目录下运行docker-compose build来重新构建服务\n\n\n\ndocker-compose pull拉取服务依赖的镜像\ndocker-compose pull [options] [SERVICE...]\n\n–ignore-pull-failures，忽略拉取镜像过程中的错误\n–parallel，多个镜像同时拉取\n–quiet，拉取镜像过程中不打印进度信息\n\n\n\ndocker-compose restart重启项目中的服务\ndocker-compose restart [options] [SERVICE...]\n\n-t, –timeout TIMEOUT，指定重启前停止容器的超时（默认为10秒）\n\n\n\ndocker-compose rm删除所有（停止状态的）服务容器,但推荐先执行docker-compose stop命令来停止容器。\ndocker-compose rm [options] [SERVICE...]\n\n–f, –force，强制直接删除，包括非停止状态的容器\n-v，删除容器所挂载的数据卷\n\n\n\ndocker-compose start启动已经存在的服务容器\ndocker-compose start [SERVICE...]\n\n\ndocker-compose run在指定服务上执行一个命令\ndocker-compose run [options] [-v VOLUME...] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]\n\n\ndocker-compose scale设置指定服务运行的容器个数。通过service=num的参数来设置数量\ndocker-compose scale web=3 db=2\n\n\ndocker-compose pause暂停一个服务容器\ndocker-compose pause [SERVICE...]\n\n\ndocker-compose kill通过发送SIGKILL信号来强制停止服务容器\ndocker-compose kill [options] [SERVICE...]\n\n\ndocker-compose config验证并查看compose文件配置\ndocker-compose config [options]\n\n–resolve-image-digests 将镜像标签标记为摘要\n-q, –quiet 只验证配置，不输出。 当配置正确时，不输出任何内容，当文件配置错误，输出错误信息\n–services 打印服务名，一行一个\n–volumes 打印数据卷名，一行一个\n\n\n\ndocker-compose create为服务创建容器\ndocker-compose create [options] [SERVICE...]\n\n–force-recreate：重新创建容器，即使配置和镜像没有改变，不兼容–no-recreate参数\n–no-recreate：如果容器已经存在，不需要重新创建，不兼容–force-recreate参数\n–no-build：不创建镜像，即使缺失\n–build：创建容器前，生成镜像\n\n\n\ndocker-compose exec在运行的容器中执行命令\ndocker-compose exec [options] SERVICE COMMAND [ARGS...]\n\n-d 分离模式，后台运行命令。\n–privileged 获取特权。\n–user USER 指定运行的用户。\n-T 禁用分配TTY，默认docker-compose exec分配TTY。\n–index=index，当一个服务拥有多个容器时，可通过该参数登陆到该服务下的任何服务，例如：docker-compose exec –index=1 web /bin/bash ，web服务中包含多个容器\n\n\n\ndocker-compose port显示某个容器端口所映射的公共端口\ndocker-compose port [options] SERVICE PRIVATE_PORT\n\n–protocol=proto，指定端口协议，TCP（默认值）或者UDP\n–index=index，如果同意服务存在多个容器，指定命令对象容器的序号（默认为1）\n\n\n\ndocker-compose push推送服务依的镜像\ndocker-compose push [options] [SERVICE...]\n\n–ignore-push-failures 忽略推送镜像过程中的错误\n\n\n\ndocker-compose uppause恢复处于暂停状态中的服务\ndocker-compose unpause [SERVICE...]\n\n\nyml 配置指令参考version指定本 yml 依从的 compose 哪个版本制定的。\n\n\nbuild指定为构建镜像上下文路径：\n例如 webapp 服务，指定为从上下文路径 ./dir/Dockerfile 所构建的镜像：\nversion: &quot;3.7&quot;services:  webapp:    build: ./dir\n或者，作为具有在上下文指定的路径的对象，以及可选的 Dockerfile 和 args：\nversion: &quot;3.7&quot;services:  webapp:    build:      context: ./dir      dockerfile: Dockerfile-alternate      args:        buildno: 1      labels:        - &quot;com.example.description=Accounting webapp&quot;        - &quot;com.example.department=Finance&quot;        - &quot;com.example.label-with-empty-value&quot;      target: prod\n\ncontext：上下文路径。\ndockerfile：指定构建镜像的 Dockerfile 文件名。\nargs：添加构建参数，这是只能在构建过程中访问的环境变量。\nlabels：设置构建镜像的标签。\ntarget：多层构建，可以指定构建哪一层。\n\n\n\ncap_add，cap_drop添加或删除容器拥有的宿主机的内核功能。\ncap_add:  - ALL # 开启全部权限cap_drop:  - SYS_PTRACE # 关闭 ptrace权限\n\n\ncgroup_parent为容器指定父 cgroup 组，意味着将继承该组的资源限制。\ncgroup_parent: m-executor-abcd\n\n\ncommand覆盖容器启动的默认命令。\ncommand: [&quot;bundle&quot;, &quot;exec&quot;, &quot;thin&quot;, &quot;-p&quot;, &quot;3000&quot;]\n\n\ncontainer_name指定自定义容器名称，而不是生成的默认名称。\ncontainer_name: my-web-container\n\n\ndepends_on设置依赖关系。\ndocker-compose up ：以依赖性顺序启动服务。在以下示例中，先启动 db 和 redis ，才会启动 web。docker-compose up SERVICE ：自动包含 SERVICE 的依赖项。在以下示例中，docker-compose up web 还将创建并启动 db 和 redis。docker-compose stop ：按依赖关系顺序停止服务。在以下示例中，web 在 db 和 redis 之前停止。\nversion: &quot;3.7&quot;services:  web:    build: .    depends_on:      - db      - redis  redis:    image: redis  db:    image: postgres\n注意：web 服务不会等待 redis db 完全启动 之后才启动。\n\n\ndeploy指定与服务的部署和运行有关的配置。只在 swarm 模式下才会有用。\nversion: &quot;3.7&quot;services:  redis:    image: redis:alpine    deploy:      mode：replicated      replicas: 6      endpoint_mode: dnsrr      labels:         description: &quot;This redis service label&quot;      resources:        limits:          cpus: &#x27;0.50&#x27;          memory: 50M        reservations:          cpus: &#x27;0.25&#x27;          memory: 20M      restart_policy:        condition: on-failure        delay: 5s        max_attempts: 3        window: 120s\n可以选参数：\n\nendpoint_mode：访问集群服务的方式。\n\nendpoint_mode: vip # Docker 集群服务一个对外的虚拟 ip。所有的请求都会通过这个虚拟 ip 到达集群服务内部的机器。endpoint_mode: dnsrr# DNS 轮询（DNSRR）。所有的请求会自动轮询获取到集群 ip 列表中的一个 ip 地址。\n\nlabels：在服务上设置标签。可以用容器上的 labels（跟 deploy 同级的配置） 覆盖 deploy 下的 labels。\nmode：指定服务提供的模式。\nreplicated：复制服务，复制指定服务到集群的机器上。\nglobal：全局服务，服务将部署至集群的每个节点。\n\n\nreplicas：mode 为 replicated 时，需要使用此参数配置具体运行的节点数量。\nresources：配置服务器资源使用的限制，例如上例子，配置 redis 集群运行需要的 cpu 的百分比 和 内存的占用。避免占用资源过高出现异常。\nrestart_policy：配置如何在退出容器时重新启动容器。\ncondition：可选 none，on-failure 或者 any（默认值：any）。\ndelay：设置多久之后重启（默认值：0）。\nmax_attempts：尝试重新启动容器的次数，超出次数，则不再尝试（默认值：一直重试）。\nwindow：设置容器重启超时时间（默认值：0）。\n\n\nrollback_config：配置在更新失败的情况下应如何回滚服务。\nparallelism：一次要回滚的容器数。如果设置为0，则所有容器将同时回滚。\ndelay：每个容器组回滚之间等待的时间（默认为0s）。\nfailure_action：如果回滚失败，该怎么办。其中一个 continue 或者 pause（默认pause）。\nmonitor：每个容器更新后，持续观察是否失败了的时间 (ns|us|ms|s|m|h)（默认为0s）。\nmax_failure_ratio：在回滚期间可以容忍的故障率（默认为0）。\norder：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者 start-first（并行回滚）（默认 stop-first ）。\n\n\nupdate_config：配置应如何更新服务，对于配置滚动更新很有用。\nparallelism：一次更新的容器数。\ndelay：在更新一组容器之间等待的时间。\nfailure_action：如果更新失败，该怎么办。其中一个 continue，rollback 或者pause （默认：pause）。\nmonitor：每个容器更新后，持续观察是否失败了的时间 (ns|us|ms|s|m|h)（默认为0s）。\nmax_failure_ratio：在更新过程中可以容忍的故障率。\norder：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者 start-first（并行回滚）（默认stop-first）。\n\n\n\n\n\ndevices指定设备映射列表。\ndevices:  - &quot;/dev/ttyUSB0:/dev/ttyUSB0&quot;\n\n\ndns自定义 DNS 服务器，可以是单个值或列表的多个值。\ndns: 8.8.8.8dns:  - 8.8.8.8  - 9.9.9.9\n\n\ndns_search自定义 DNS 搜索域。可以是单个值或列表。\ndns_search: example.comdns_search:  - dc1.example.com  - dc2.example.com\n\n\nentrypoint覆盖容器默认的 entrypoint。\nentrypoint: /code/entrypoint.shentrypoint:    - php    - -d    - zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so    - -d    - memory_limit=-1    - vendor/bin/phpunit\n\n\nenv_file从文件添加环境变量。可以是单个值或列表的多个值。\nenv_file: .envenv_file:  - ./common.env  - ./apps/web.env  - /opt/secrets.env\n\n\nenvironment添加环境变量。您可以使用数组或字典、任何布尔值，布尔值需要用引号引起来，以确保 YML 解析器不会将其转换为 True 或 False。\nenvironment:  RACK_ENV: development  SHOW: &#x27;true&#x27;\n\n\nexpose暴露端口，但不映射到宿主机，只被连接的服务访问。\n仅可以指定内部端口为参数：\nexpose: - &quot;3000&quot; - &quot;8000&quot;\n\n\nports对外暴露的端口定义，和 expose 对应\nports:   # 暴露端口信息  - &quot;宿主机端口:容器暴露端口&quot; - &quot;8763:8763&quot; - &quot;8763:8763&quot;\n\n\nextra_hosts添加主机名映射。类似 docker client –add-host。\nextra_hosts: - &quot;somehost:162.242.195.82&quot; - &quot;otherhost:50.31.209.229&quot;\n以上会在此服务的内部容器中 /etc/hosts 创建一个具有 ip 地址和主机名的映射关系：\n162.242.195.82  somehost50.31.209.229   otherhost\n\n\nhealthcheck用于检测 docker 服务是否健康运行。\nhealthcheck:  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;] # 设置检测程序  interval: 1m30s # 设置检测间隔  timeout: 10s # 设置检测超时时间  retries: 3 # 设置重试次数  start_period: 40s # 启动后，多少秒开始启动检测程序\n\n\nimage指定容器运行的镜像。以下格式都可以：\nimage: redisimage: ubuntu:14.04image: tutum/influxdbimage: example-registry.com:4000/postgresqlimage: a4bc65fd # 镜像id\n\n\nlogging服务的日志记录配置。\ndriver：指定服务容器的日志记录驱动程序，默认值为json-file。有以下三个选项\ndriver: &quot;json-file&quot;driver: &quot;syslog&quot;driver: &quot;none&quot;\n仅在 json-file 驱动程序下，可以使用以下参数，限制日志得数量和大小。\nlogging:  driver: json-file  options:    max-size: &quot;200k&quot; # 单个文件大小为200k    max-file: &quot;10&quot; # 最多10个文件\n当达到文件限制上限，会自动删除旧得文件。\nsyslog 驱动程序下，可以使用 syslog-address 指定日志接收地址。\nlogging:  driver: syslog  options:    syslog-address: &quot;tcp://192.168.0.42:123&quot;\n\n\nnetwork_mode设置网络模式。\nnetwork_mode: &quot;bridge&quot;network_mode: &quot;host&quot;network_mode: &quot;none&quot;network_mode: &quot;service:[service name]&quot;network_mode: &quot;container:[container name/id]&quot;\n\n\nnetworks配置容器连接的网络，引用顶级 networks 下的条目 。\nservices:  some-service:    networks:      some-network:        aliases:         - alias1      other-network:        aliases:         - alias2networks:  some-network:    # Use a custom driver    driver: custom-driver-1  other-network:    # Use a custom driver which takes special options    driver: custom-driver-2\naliases ：同一网络上的其他容器可以使用服务名称或此别名来连接到对应容器的服务。\n\n\nrestart\nno：是默认的重启策略，在任何情况下都不会重启容器。\nalways：容器总是重新启动。on-failure：在容器非正常退出时（退出状态非0），才会重启容器。unless-stopped：在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器\n\nrestart: &quot;no&quot;restart: alwaysrestart: on-failurerestart: unless-stopped\n注：swarm 集群模式，请改用restart_policy。\n\n\nsecrets存储敏感数据，例如密码：\nversion: &quot;3.1&quot;services:mysql:  image: mysql  environment:    MYSQL_ROOT_PASSWORD_FILE: /run/secrets/my_secret  secrets:    - my_secretsecrets:  my_secret:    file: ./my_secret.txt\n\n\nsecurity_opt修改容器默认的 schema 标签。\nsecurity-opt：  - label:user:USER   # 设置容器的用户标签  - label:role:ROLE   # 设置容器的角色标签  - label:type:TYPE   # 设置容器的安全策略标签  - label:level:LEVEL  # 设置容器的安全等级标签\n\n\nstop_grace_period指定在容器无法处理 SIGTERM (或者任何 stop_signal 的信号)，等待多久后发送 SIGKILL 信号关闭容器。\nstop_grace_period: 1s # 等待 1 秒stop_grace_period: 1m30s # 等待 1 分 30 秒\n默认的等待时间是 10 秒。\n\n\nstop_signal设置停止容器的替代信号。默认情况下使用 SIGTERM 。\n以下示例，使用 SIGUSR1 替代信号 SIGTERM 来停止容器。\nstop_signal: SIGUSR1\n\n\nsysctls设置容器中的内核参数，可以使用数组或字典格式。\nsysctls:  net.core.somaxconn: 1024  net.ipv4.tcp_syncookies: 0sysctls:  - net.core.somaxconn=1024  - net.ipv4.tcp_syncookies=0\n\n\ntmpfs在容器内安装一个临时文件系统。可以是单个值或列表的多个值。\ntmpfs: /runtmpfs:  - /run  - /tmp\n\n\nulimits覆盖容器默认的 ulimit。\nulimits:  nproc: 65535  nofile:    soft: 20000    hard: 40000\n\n\nvolumes将主机的数据卷或着文件挂载到容器里。\nversion: &quot;3.7&quot;services:  db:    image: postgres:latest    volumes:      - &quot;/localhost/postgres.sock:/var/run/postgres/postgres.sock&quot;      - &quot;/localhost/data:/var/lib/postgresql/data&quot;","categories":["Docker","扩展"],"tags":["docker"]},{"title":"Docker笔记（10）——技巧和秘诀","url":"https://lujw666.github.io/2021/02/23/docker-10/","content":"容器和镜像的关系无论容器里做什么操作，写文件，删文件。该容器的基本镜像都不会有任何改变。这是因为Docker从父镜像建立增量镜像，只存储每个容器的更改。因此，如果你有一个300MB的父镜像，如果你在容器中安装了50MB的额外应用或服务，你的容器只有50MB，父镜像还是300MB。 但是可以使用Dockfile或commit命令来，把增量镜像和父镜像一起生成一个新的镜像。\n#  显示容器中运行的进程docker top &lt;容器名orID&gt;# 查看容器的root用户名和密码docker logs &lt;容器名orID&gt; 2&gt;&amp;1 | grep &#x27;^User: &#x27; | tail -n1# 因为docker容器启动时的root用户的密码是随机分配的。所以，通过这种方式就可以得到redmine容器的root用户的密码了。# 实时查看容器日志docker logs -f &lt;容器名orID&gt;# 删除所有容器docker rm $(docker ps -a -q)# 停止、启动、杀死一个容器docker stop &lt;容器名orID&gt;docker start &lt;容器名orID&gt;docker kill &lt;容器名orID&gt;# 查看所有镜像docker images# 删除所有镜像docker rmi $(docker images | grep none | awk &#x27;&#123;print $3&#125;&#x27; | sort -r)# 移除所有的容器和镜像（大扫除）# 用一行命令大扫除：docker kill $(docker ps -q) ; docker rm $(docker ps -a -q) ; docker rmi $(docker images -q -a)# 注：shell 中的 $() 和command类似，会先执行这里面的内容，上面的脚本会出现如下 docker kill &quot;pids&quot; ; docker kill 在 docker 中用于停止容器，docker rm 删除容器， docker rmi 删除镜像# 当没有运行的容器或者是根本没有容器的时候，这只会提示一个警告信息。当你想尝试的时候，这就是个非常好的单行命令。如果你仅仅想删除所有的容器，你可以运行如下命令：docker kill $(docker ps -q) ; docker rm $(docker ps -a -q) # 不在 Shell 上运行命令# 如果你使用需要Shell 的扩展项的 docker run 命令处理某些事情，比如 docker run --rm busybox ls &#x27;/var/log/&#x27;, 这个命令将失败。原来没有 Shell ， 而 ``` 是 Shell 的扩展项，因此你需要一个能使用的 Shell 。正确方法为docker run --rm busybox sh -c &#x27;ls /var/log/*&#x27;# 多程序开机自动运行方法：# docker容器每次启动时，开机自启动的命令都要在启动容器前指定。如 docker run -I -t debian /bin/bash命令，只会运行/bin/bash程序，其它的程序都不会运行，对于要跑多个程序的容器特别纠结。可把前面所说的启动命令换成docker run -I -t debian /etc/rc.local# 在容器中把所有需要开机自的启动命令放在/etc/rc.local中，就可以达到多程序开机自启动了。# 后台运行则是：docker run -d -p 50001:22 debian /etc/rc.local# 退出时删除容器# 如果你仅仅想在一个容器中快速的运行一个命令，然后退出，并且不用担心容器状态，把 --rm 参数加入 run 命令后面,这将结束很多你保存了的容器，并且清理它们。docker run --rm -i -t busybox /bin/bash# 运行一个新容器，同时为它命名、端口映射、文件夹映射。以redmine镜像为例docker run --name redmine -p 9003:80 -p 9023:22 -d -v /var/redmine/files:/redmine/files -v /var/redmine/mysql:/var/lib/mysql sameersbn/redmine# 一个容器连接到另一个容器docker run -i -t --name sonar -d -link mmysql:db   tpires/sonar-serversonar# 容器连接到mmysql容器，并将mmysql容器重命名为db。这样，sonar容器就可以使用db的相关的环境变量了。\n\n\n镜像的保存与导入当需要把一台机器上的镜像迁移到另一台机器的时候，需要保存镜像与加载镜像。 \n机器a操作:\ndocker save busybox-1 &gt; /home/save.tar\n使用scp将save.tar拷到机器b上，然后：\ndocker load &lt; /home/save.tar# 构建自己的镜像docker build -t &lt;镜像名&gt; &lt;Dockerfile路径&gt;# 如Dockerfile在当前路径：docker build -t xx/gitlab .# 重新查看container的stdout# 启动top命令，后台运行ID=$(sudo docker run -d ubuntu /usr/bin/top -b)# 获取正在running的container的输出docker attach $IDtop - 02:05:52 up  3:05,  0 users,  load average: 0.01, 0.02, 0.05Tasks:   1 total,   1 running,   0 sleeping,   0 stopped,   0 zombieCpu(s):  0.1%us,  0.2%sy,  0.0%ni, 99.7%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%stMem:    373572k total,   355560k used,    18012k free,    27872k buffersSwap:   786428k total,        0k used,   786428k free,   221740k cached^C$sudo docker stop $ID# 后台运行(-d)、并暴露端口(-p)docker run -d -p 127.0.0.1:33301:22 centos6-ssh# 从container中拷贝文件出来sudo docker cp 7bb0e258aefe:/etc/debian_version .# 拷贝7bb0e258aefe中的/etc/debian_version到当前目录下。# 注意：只要7bb0e258aefe没有被删除，文件命名空间就还在，可以放心的把exit状态的container的文件拷贝出来\n","categories":["Docker","进阶"],"tags":["docker"]},{"title":"Docker笔记（09）——清理命令","url":"https://lujw666.github.io/2021/02/23/docker-09/","content":"杀死所有正在运行的容器docker kill $(docker ps -a -q)\n\n\n删除所有已经停止的容器docker rm $(docker ps -a -q)\n\n\n删除所有未打 dangling 标签的镜像docker rmi $(docker images -q -f dangling&#x3D;true)\n\n\n通过镜像的id来删除指定镜像docker rmi &lt;image id&gt;\n\n\n删除所有镜像docker rmi $(docker images -q)\n\n\n上述命令创建别名# ~/.bash_aliases# 杀死所有正在运行的容器.alias dockerkill=&#x27;docker kill $(docker ps -a -q)&#x27;# 删除所有已经停止的容器.alias dockercleanc=&#x27;docker rm $(docker ps -a -q)&#x27;# 删除所有未打标签的镜像.alias dockercleani=&#x27;docker rmi $(docker images -q -f dangling=true)&#x27;# 删除所有已经停止的容器和未打标签的镜像.alias dockerclean=&#x27;dockercleanc || true &amp;&amp; dockercleani&#x27;\n","categories":["Docker","进阶"],"tags":["docker"]},{"title":"Docker笔记（08）——命令大全","url":"https://lujw666.github.io/2021/02/23/docker-08/","content":"链接：https://lujw666.gitbook.io/learn/docker/00-basic/08-ming-ling\n\n\n\n\n\n容器生命周期管理\nrun 创建一个新的容器并运行一个命令\nstart/stop/restart   启动/停止/重启一个容器\nkill  杀掉一个运行中的容器\nrm  删除一个或多个容器\npause/unpause 暂停/恢复容器中所有的进程\ncreate   创建一个新的容器但不启动它\nexec   在运行的容器中执行命令\n\n\n\n容器操作\nps   列出容器\ninspect 获取容器/镜像的元数据\ntop 查看容器中运行的进程信息\nattach   连接到正在运行中的容器\nevents   从服务器获取实时事件\nlogs   获取容器的日志\nwait    阻塞运行直到容器停止，然后打印出它的退出代码\nexport   将文件系统作为一个tar归档文件导出到STDOUT\nport  列出指定的容器的端口映射\n\n\n\n容器rootfs命令\ncommit   从容器创建一个新的镜像\ncp   用于容器与主机之间的数据拷贝\ndiff   检查容器里文件结构的更改\n\n\n\n镜像仓库\nlogin/logout  登陆/登出Docker镜像仓库\npull   从镜像仓库中拉取或者更新指定镜像\npush   将本地的镜像上传到镜像仓库\nsearch   从Docker Hub查找镜像\n\n\n\n本地镜像管理\nimages   列出本地镜像\nrmi 删除本地一个或多少镜像\ntag 标记本地镜像，将其归入某一仓库\nbuild 用于使用 Dockerfile 创建镜像\nhistory 查看指定镜像的创建历史\nsave  将指定镜像保存成 tar 归档文件\nload  导入使用 docker save 命令导出的镜像\nimport   从归档文件中创建镜像\n\n","categories":["Docker","基础"],"tags":["docker"]},{"title":"Docker笔记（07）——dockerfile","url":"https://lujw666.github.io/2021/02/23/docker-07/","content":"Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。\n\n\n构建镜像\n在一个空目录下，新建一个名为 Dockerfile 文件，并在文件内添加内容；\n在 Dockerfile 文件的存放目录下，执行构建动作。\n\n以下示例，通过目录下的 Dockerfile 构建一个 nginx:v3（镜像名称:镜像标签）。\n$ docker build -t nginx:v3 .\n注：最后的 . 代表本次执行的上下文路径\n\n\n上下文路径指令最后一个 . 是上下文路径，那么什么是上下文路径呢？\n上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。\n解析：由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。\n如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置。\n注意：上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。\n\n\n指令详解FROM定制的镜像都是基于 FROM 的镜像。\nFROM nginxRUN echo &#x27;这是一个本地构建的nginx镜像&#x27; &gt; /usr/share/nginx/html/index.html\n上述 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。\n\n\nRUN用于执行后面跟着的命令行命令。\nRUN &lt;命令行命令&gt; # &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]# exec 格式\n注意：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。\nFROM centosRUN yum install wgetRUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;RUN tar -xvf redis.tar.gz以上执行会创建 3 层镜像。可简化为以下格式：FROM centosRUN yum install wget \\    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot; \\    &amp;&amp; tar -xvf redis.tar.gz\n如上，以 &amp;&amp; 符号连接命令，这样执行后，只会创建 1 层镜像。\n\n\nCOPY复制指令，从上下文目录中复制文件或者目录到容器里指定路径。\nCOPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,...  &quot;&lt;目标路径&gt;&quot;]\n\n–chown=&lt;user&gt;:&lt;group&gt;：可选参数，用户改变复制到容器内文件的拥有者和属组。\n&lt;源路径&gt;：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：\n\nCOPY hom* /mydir/COPY hom?.txt /mydir/\n\n&lt;目标路径&gt;：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。\n\n\n\nADDADD 指令和 COPY 的使用格式一致（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：\nADD 的优点：在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。\n\n\nCMD类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:\n\nCMD 在docker run 时运行。\nRUN 是在 docker build。\n\n作用：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。\n注意：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。\nCMD &lt;shell 命令&gt; CMD [&quot;&lt;可执行文件或命令&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]  # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数# 推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。\n\n\nENTRYPOINT类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。\n但是, 如果运行 docker run 时使用了 –entrypoint 选项，此选项的参数可当作要运行的程序覆盖 ENTRYPOINT 指令指定的程序。\n优点：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。\n注意：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。\nENTRYPOINT [&quot;&lt;executeable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]# 可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。\n示例：\n# 假设已通过 Dockerfile 构建了 nginx:test 镜像：FROM nginxENTRYPOINT [&quot;nginx&quot;, &quot;-c&quot;] # 定参CMD [&quot;/etc/nginx/nginx.conf&quot;] # 变参\n$ # 1、不传参运行$ docker run  nginx:test$ # 容器内会默认运行以下命令，启动主进程。nginx -c /etc/nginx/nginx.conf$ # 2、传参运行$ docker run  nginx:test -c /etc/nginx/new.conf$ # 容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件)nginx -c /etc/nginx/new.conf\n\n\nENV设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。\nENV &lt;key&gt; &lt;value&gt;ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...\n# 以下示例设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用：ENV NODE_VERSION 7.2.0RUN curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&quot; \\    &amp;&amp; curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot;\n\n\nARG构建参数，与 ENV 作用一至。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。\n构建命令 docker build 中可以用 –build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。\nARG &lt;参数名&gt;[=&lt;默认值&gt;]\n\n\nVOLUME定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。\n作用：\n\n避免重要的数据，因容器重启而丢失，这是非常致命的。\n避免容器不断变大。\n\nVOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]VOLUME &lt;路径&gt;\n在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。\n\n\nEXPOSE仅仅只是声明端口。\n作用：\n\n帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。\n在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。\n\nEXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]\n\n\nWORKDIR指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。\ndocker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。\nWORKDIR &lt;工作目录路径&gt;\n\n\nUSER用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。\nUSER &lt;用户名&gt;[:&lt;用户组&gt;]\n\n\nHEALTHCHECK用于指定某个程序或者指令来监控 docker 容器服务的运行状态。\nHEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令HEALTHCHECK [选项] CMD &lt;命令&gt; : 这边 CMD 后面跟随的命令使用，可以参考 CMD 的用法。\n\n\nONBUILD用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这是执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。\nONBUILD &lt;其它指令&gt;\n","categories":["Docker","基础"],"tags":["docker"]},{"title":"Docker笔记（06）——Docker 仓库管理","url":"https://lujw666.github.io/2021/02/23/docker-06/","content":"仓库（Repository）是集中存放镜像的地方。以下介绍一下 Docker Hub。当然不止 docker hub，只是远程的服务商不一样，操作都是一样的。\nDocker Hub目前 Docker 官方维护了一个公共仓库 Docker Hub。\n\n\n注册在 https://hub.docker.com 免费注册一个 Docker 账号。\n\n\n登录使用 docker login 命令登录需要输入用户名和密码，登录成功后，我们就可以从 docker hub 上拉取自己账号下的全部镜像。\n$ docker login\n\n\n退出使用 docker logout 命令退出 docker hub。\n$ docker logout\n\n\n拉取镜像通过 docker search 命令来查找官方仓库中的镜像，并利用 docker pull 命令来将它下载到本地。\n$ # 以 ubuntu 为关键词进行搜索$ docker search ubuntu$ # 使用 docker pull 将官方 ubuntu 镜像下载到本地$ docker pull ubuntu\n\n\n推送镜像用户登录后，可以通过 docker push 命令将自己的镜像推送到Docker Hub。\n$ #以下命令中的 username 请替换为你的 Docker 账号用户名。$ docker tag ubuntu:18.04 username/ubuntu:18.04$ docker image lsREPOSITORY      TAG        IMAGE ID            CREATED           ...  ubuntu          18.04      275d79972a86        6 days ago        ...  username/ubuntu 18.04      275d79972a86        6 days ago        ...  $ docker push username/ubuntu:18.04$ docker search username/ubuntuNAME             DESCRIPTION       STARS         OFFICIAL    AUTOMATEDusername/ubuntu","categories":["Docker","基础"],"tags":["docker"]},{"title":"Docker笔记（05）——Docker 容器操作","url":"https://lujw666.github.io/2021/02/23/docker-05/","content":"启动容器使用 docker run 命令使镜像启动一个容器。\n$ docker run -it ubuntu /bin/bashb750bbbcfd88 \n参数说明：\n\n-i: 交互式操作。\n-t: 终端。\nubuntu: ubuntu 镜像。\n/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。\n\ndocker run [OPTIONS] IMAGE [COMMAND] [ARG...]\nOPTIONS说明：\n\n-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；\n-d: 后台运行容器，并返回容器ID；\n-i: 以交互模式运行容器，通常与 -t 同时使用；\n-P: 随机端口映射，容器内部端口随机映射到主机的端口\n-p: 指定端口映射，格式为：主机(宿主)端口:容器端口\n-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；\n–name=”nginx-lb”: 为容器指定一个名称；\n–dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；\n–dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；\n-h “mars”: 指定容器的hostname；\n-e username=”ritchie”: 设置环境变量；\n–env-file=[]: 从指定文件读入环境变量；\n–cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行；\n-m :设置容器使用内存最大值；\n–net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；\n–link=[]: 添加链接到另一个容器；\n–expose=[]: 开放一个端口或一组端口；\n–volume , -v: 绑定一个卷\n\n\n\n网络端口映射容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射。\n\n-P :是容器内部端口随机映射到主机的高端口。\n-p : 是容器内部端口绑定到指定的主机端口\n\n$ docker run -d -p 5000:5000 training/webapp python app.py33e4523d30aaf0258915c368e66e03b49535de0ef20317d3f639d40222ba6bc0$ docker psCONTAINER ID        IMAGE               COMMAND           ...           PORTS                     NAMES33e4523d30aa        training/webapp     &quot;python app.py&quot;   ...   0.0.0.0:5000-&gt;5000/tcp    berserk_bartik\n可以指定容器绑定的网络地址。\n$ docker run -d -p 127.0.0.1:5001:5000 training/webapp python app.py95c6ceef88ca3e71eaf303c2833fd6701d8d1b2572b5613b5a932dfdfe8a857c$ docker psCONTAINER ID        IMAGE               COMMAND           ...     PORTS                                NAMES95c6ceef88ca        training/webapp     &quot;python app.py&quot;   ...  5000/tcp, 127.0.0.1:5001-&gt;5000/tcp   adoring_stonebraker\n默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 /udp。\n$ docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py6779686f06f6204579c1d655dd8b2b31e8e809b245a97b2d3a8e35abe9dcd22a$ docker psCONTAINER ID        IMAGE               COMMAND           ...   PORTS                                NAMES6779686f06f6        training/webapp     &quot;python app.py&quot;   ...   5000/tcp, 127.0.0.1:5000-&gt;5000/udp   drunk_visvesvaraya\n使用[docker port]命令可以让我们快捷地查看端口的绑定情况。\n$ docker port adoring_stonebraker 5000127.0.0.1:5001\n\n\n停止容器使用 docker stop 命令停止容器。\n$ docker stop &lt;容器 ID&gt;\n\n\n启动已停止运行的容器使用 docker start 或 restart 命令启动一个已停止的容器。\n$ docker start b750bbbcfd88 \n\n\n进入容器在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：\n\ndocker attach\ndocker exec：推荐使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。\n\n$ docker attach b750bbbcfd88$ docker exec -it b750bbbcfd88 /bin/bash\n\n\n导出和导入容器导出容器使用 docker export 命令导出本地容器。\n$ docker export b750bbbcfd88  &gt; ubuntu.tar\n\n\n导入容器快照使用 docker import 从容器快照文件中再导入为镜像。\n$ # 将快照文件 ubuntu.tar 导入到镜像 test/ubuntu:v1$ docker import ubuntu.tar test/ubuntu:v1$ # 通过指定 URL 或者某个目录来导入$ docker import http://example.com/exampleimage.tgz example/imagerepo\n\n\n删除容器使用 docker rm 命令删除容器。\n$ docker rm -f b750bbbcfd88\n\n\n清除容器使用 docker container prune 清理掉所有处于终止状态的容器。\n\n\n容器互联docker 有一个连接系统允许将多个容器连接在一起，共享连接信息。\ndocker 连接会创建一个父子关系，其中父容器可以看到子容器的信息。\n\n\n新建网络创建一个新的 Docker 网络。\n$ docker network create -d bridge test-net\n参数说明：\n\n-d：参数指定 Docker 网络类型，有 bridge、overlay。其中 overlay 网络类型用于 Swarm mode，在本小节中你可以忽略它。\n\n\n\n连接容器运行一个容器并连接到新建的 test-net 网络:\n$ docker run -itd --name test1 --network test-net ubuntu /bin/bash\n打开新的终端，再运行一个容器并加入到 test-net 网络:\n$ docker run -itd --name test2 --network test-net ubuntu /bin/bash\n可以通过 ping 来证明 test1 容器和 test2 容器建立了互联关系。\n如果你有多个容器之间需要互相连接，推荐使用 Docker Compose。\n","categories":["Docker","基础"],"tags":["docker"]},{"title":"Docker笔记（04）——Docker 镜像使用","url":"https://lujw666.github.io/2021/02/22/docker-04/","content":"列出镜像列表使用 docker images 来列出本地主机上的镜像。\n$ docker images          REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              14.04               90d5884b1ee0        5 days ago          188 MBphp                 5.6                 f40e9e0f10c8        9 days ago          444.8 MBnginx               latest              6f8d099c3adc        12 days ago         182.7 MBmysql               5.6                 f2e8d6c772c0        3 weeks ago         324.6 MBhttpd               latest              02ef73cf1bc0        3 weeks ago         194.4 MBubuntu              15.10               4e3b13c8a266        4 weeks ago         136.3 MBhello-world         latest              690ed74de00f        6 months ago        960 Btraining/webapp     latest              6fae60ef3446        11 months ago       348.8 MB\n各个选项说明:\n\nREPOSITORY：表示镜像的仓库源\nTAG：镜像的标签\nIMAGE ID：镜像ID\nCREATED：镜像创建时间\nSIZE：镜像大小\n\n同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，使用 REPOSITORY:TAG 来定义不同的镜像。\ndocker images [OPTIONS] [REPOSITORY[:TAG]]\nOPTIONS说明：\n\n-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；\n–digests :显示镜像的摘要信息；\n-f :显示满足条件的镜像；\n–format :指定返回值的模板文件；\n–no-trunc :显示完整的镜像信息；\n-q :只显示镜像ID。\n\n\n\n获取一个新的镜像使用 docker pull 命令下载镜像。当在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。\n$ docker pull ubuntu:13.1013.10: Pulling from library/ubuntu6599cadaf950: Pull complete 23eda618d451: Pull complete f0be3084efe9: Pull complete 52de432f084b: Pull complete a3ed95caeb02: Pull complete Digest: sha256:15b79a6654811c8d992ebacdfbd5152fcf3d165e374e264076aa435214a947a3Status: Downloaded newer image for ubuntu:13.10\ndocker pull [OPTIONS] NAME[:TAG|@DIGEST]\nOPTIONS说明：\n\n-a :拉取所有 tagged 镜像\n–disable-content-trust :忽略镜像的校验,默认开启\n\n\n\n查找镜像使用 docker search 命令来搜索镜像。\n比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。\n$  docker search httpdNAME                                    DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDhttpd                                   The Apache HTTP Server Project                  3339      [OK]centos/httpd-24-centos7                 Platform for running Apache httpd 2.4 or bui…   36centos/httpd                                                                            33                   [OK]arm32v7/httpd                           The Apache HTTP Server Project                  9polinux/httpd-php                       Apache with PHP in Docker (Supervisor, CentO…   4                    [OK]salim1983hoop/httpd24                   Dockerfile running apache config                2                    [OK]clearlinux/httpd                        httpd HyperText Transfer Protocol (HTTP) ser…   1\n各个选项说明:\n\nNAME: 镜像仓库源的名称\nDESCRIPTION: 镜像的描述\nOFFICIAL: 是否 docker 官方发布\nstars: 类似 Github 里面的 star，表示点赞、喜欢的意思。\nAUTOMATED: 自动构建。\n\ndocker search [OPTIONS] TERM\nOPTIONS说明：\n\n–automated :只列出 automated build类型的镜像；\n–no-trunc :显示完整的镜像描述；\n-f &lt;过滤条件&gt;:列出收藏数不小于指定值的镜像。\n\n\n\n删除镜像镜像删除使用 docker rmi 命令，比如删除 hello-world 镜像：\n$ docker rmi hello-world\ndocker rmi [OPTIONS] IMAGE [IMAGE...]\nOPTIONS说明：\n\n-f :强制删除；\n–no-prune :不移除该镜像的过程镜像，默认移除；\n\n\n\n创建镜像当从 docker 镜像仓库中下载的镜像不能满足我们的需求时，可以通过以下两种方式对镜像进行更改。\n\n从已经创建的容器中更新镜像，并且提交这个镜像\n使用 Dockerfile 指令来创建一个新的镜像\n\n\n\n更新镜像更新镜像之前，需要使用镜像来创建一个容器。\n在运行的容器内使用进行操作更新。在完成操作之后，输入 exit 命令来退出这个容器。\n此时 ID 为 e218edb10161 的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit 来提交容器副本。\n$ docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2sha256:70bf1840fd7c0d2d8ef0a42a817eb29f854c1af8f7c59fc03ac7bdee9545aff8\n各个参数说明：\n\n-m: 提交的描述信息\n-a: 指定镜像作者\ne218edb10161：容器 ID\nrunoob/ubuntu:v2: 指定要创建的目标镜像\n\n从容器创建一个新的镜像。\ndocker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]\nOPTIONS说明：\n\n-a :提交的镜像作者；\n-c :使用Dockerfile指令来创建镜像；\n-m :提交时的说明文字；\n-p :在commit时，将容器暂停。\n\n\n\n构建镜像使用命令 docker build， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。\n$ cat Dockerfile FROM    centos:6.7MAINTAINER      Fisher &quot;fisher@sudops.com&quot;RUN     /bin/echo &#x27;root:123456&#x27; |chpasswdRUN     useradd runoobRUN     /bin/echo &#x27;runoob:123456&#x27; |chpasswdRUN     /bin/echo -e &quot;LANG=\\&quot;en_US.UTF-8\\&quot;&quot; &gt;/etc/default/localEXPOSE  22EXPOSE  80CMD     /usr/sbin/sshd -D\n每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。第一条FROM，指定使用哪个镜像源。RUN 指令告诉docker 在镜像内执行命令，安装了什么。然后，我们使用 Dockerfile 文件，通过 docker build 命令来构建一个镜像。\n$ docker build -t runoob/centos:6.7 .Sending build context to Docker daemon 17.92 kBStep 1 : FROM centos:6.7 ---&amp;gt; d95b5ca17cc3Step 2 : MAINTAINER Fisher &quot;fisher@sudops.com&quot; ---&amp;gt; Using cache ---&amp;gt; 0c92299c6f03Step 3 : RUN /bin/echo &#x27;root:123456&#x27; |chpasswd ---&amp;gt; Using cache ---&amp;gt; 0397ce2fbd0aStep 4 : RUN useradd runoob......\n参数说明：\n\n-t ：指定要创建的目标镜像名\n. ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径\n\ndocker build [OPTIONS] PATH | URL | -\nOPTIONS说明：\n\n–build-arg=[] :设置镜像创建时的变量；\n–cpu-shares :设置 cpu 使用权重；\n–cpu-period :限制 CPU CFS周期；\n–cpu-quota :限制 CPU CFS配额；\n–cpuset-cpus :指定使用的CPU id；\n–cpuset-mems :指定使用的内存 id；\n–disable-content-trust :忽略校验，默认开启；\n-f :指定要使用的Dockerfile路径；\n–force-rm :设置镜像过程中删除中间容器；\n–isolation :使用容器隔离技术；\n–label=[] :设置镜像使用的元数据；\n-m :设置内存最大值；\n–memory-swap :设置Swap的最大值为内存+swap，”-1”表示不限swap；\n–no-cache :创建镜像的过程不使用缓存；\n–pull :尝试去更新镜像的新版本；\n–quiet, -q :安静模式，成功后只输出镜像 ID；\n–rm :设置镜像成功后删除中间容器；\n–shm-size :设置/dev/shm的大小，默认值是64M；\n–ulimit :Ulimit配置。\n–squash :将 Dockerfile 中所有的操作压缩为一层。\n–tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。\n–network: 默认 default。在构建期间设置RUN指令的网络模式\n\n\n\n设置镜像标签使用 docker tag 命令，为镜像添加一个新的标签。\n$ docker tag 860c279d2fec runoob/centos:dev\ndocker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]\ndocker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]\n","categories":["Docker","基础"],"tags":["docker"]},{"title":"Docker笔记（03）——Docker 架构","url":"https://lujw666.github.io/2021/02/22/docker-03/","content":"Docker 包括三个基本概念:\n\n镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。\n容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。\n仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。\n\n\n\n\n\n概念\n说明\n\n\n\nDocker 镜像(Images)\nDocker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。\n\n\nDocker 容器(Container)\n容器是独立运行的一个或一组应用，是镜像运行时的实体。\n\n\nDocker 客户端(Client)\nDocker 客户端通过命令行或者其他工具使用 Docker SDK https://docs.docker.com/develop/sdk/ 与 Docker 的守护进程通信。\n\n\nDocker 主机(Host)\n一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。\n\n\nDocker Registry\nDocker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub https://hub.docker.com 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。\n\n\nDocker Machine\nDocker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。\n\n\n","categories":["Docker","基础"],"tags":["docker"]},{"title":"Docker笔记（02）——Docker 安装","url":"https://lujw666.github.io/2021/02/22/docker-02/","content":"Linux 平台上安装Debian/UbuntuDebian/Ubuntu Docker 安装命令为：\n# 获取最新版本的 Docker 安装包apt-get updateapt-get install -y docker.io# 启动docker 后台服务service docker start\n\n\nCentos/RedHat如果你使用的系统是 Centos/RedHat 安装命令为：\nyum -y install dockerservice docker start\n\n\nWindows 平台上安装Docker Desktop 是 Docker 在 Windows 10 和 macOS 操作系统上的官方安装方式，这个方法依然属于先在虚拟机中安装 Linux 然后再安装 Docker 的方法。\nDocker Desktop 官方下载地址：https://hub.docker.com/editions/community/docker-ce-desktop-windows\n通过命令来启用 Hyper-V ，请右键开始菜单并以管理员身份运行 PowerShell，执行以下命令：\nEnable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All\n运行安装文件完成之后，Docker 会自动启动。通知栏上会出现个小鲸鱼的图标，这表示 Docker 正在运行。\n\n\nMac 平台上安装macOS 我们可以使用 Homebrew 来安装 Docker。\nHomebrew 的 Cask 已经支持 Docker for Mac。\n$ brew install --cask --appdir&#x3D;&#x2F;Applications docker&#x3D;&#x3D;&gt; Creating Caskroom at &#x2F;usr&#x2F;local&#x2F;Caskroom&#x3D;&#x3D;&gt; We&#39;ll set permissions properly so we won&#39;t need sudo in the futurePassword:          # 输入 macOS 密码&#x3D;&#x3D;&gt; Satisfying dependencies&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;download.docker.com&#x2F;mac&#x2F;stable&#x2F;21090&#x2F;Docker.dmg######################################################################## 100.0%&#x3D;&#x3D;&gt; Verifying checksum for Cask docker&#x3D;&#x3D;&gt; Installing Cask docker&#x3D;&#x3D;&gt; Moving App &#39;Docker.app&#39; to &#39;&#x2F;Applications&#x2F;Docker.app&#39;.&amp;#x1f37a;  docker was successfully installed!","categories":["Docker","基础"],"tags":["docker","安装"]},{"title":"Docker笔记（01）——什么是 Docker","url":"https://lujw666.github.io/2021/02/22/docker-01/","content":"Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。\nDocker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。\n容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。\n\n\nDocker和传统虚拟化方式\n\n\n特性\n容器\n虚拟机\n\n\n\n启动\n秒级\n分钟级\n\n\n硬盘使用\n一般为 MB\n一般为 GB\n\n\n性能\n接近原生\n弱于\n\n\n系统支持量\n单机支持上千个容器\n一般几十个\n\n\n\n\n\n\nDocker的优点Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。\n\n快速，一致地交付您的应用程序Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。容器非常适合持续集成和持续交付（CI / CD）工作流程，请考虑以下示例方案：\n您的开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。\n他们使用 Docker 将其应用程序推送到测试环境中，并执行自动或手动测试。\n当开发人员发现错误时，他们可以在开发环境中对其进行修复，然后将其重新部署到测试环境中，以进行测试和验证。\n测试完成后，将修补程序推送给生产环境，就像将更新的镜像推送到生产环境一样简单。\n\n\n响应式部署和扩展Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。Docker 的可移植性和轻量级的特性，还可以使您轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。\n在同一硬件上运行更多工作负载Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。Docker 非常适合于高密度环境以及中小型部署，而您可以用更少的资源做更多的事情。\n\n","categories":["Docker","基础"],"tags":["简介","docker"]},{"title":"Gitbook笔记（4）——配置","url":"https://lujw666.github.io/2021/02/18/gitbook-04/","content":"GitBook的项目结构如下：\n\n多语言的GitBook项目结构示例如下：\n\n\n\n配置项目结构book.json是全局配置文件，可以自定义项目的根目录、自述文件、摘要、词汇表、多语言等文件的文件名。\n在book.json中可配置的变量如下:\n\n\n\n变量\n描述\n\n\n\nroot\n配置书籍的根目录，默认时当前目录\n\n\nstructure\n配置自述文件、摘要、词汇表的文件名\n\n\ntitle\n配置书名、如果不配置，则默认从自述文件README文件第一段提取\n\n\ndescription\n配置书籍的描述，如果不配置则默认从自述文件中提取\n\n\nauthor\n配置作者姓名\n\n\nisbn\n配置本书的国际码 ISBN\n\n\nlanguage\n配置本书语言的ISO代码，默认值为en\n\n\ndirection\n配置本书的方向。可以是rtl或ltr,默认值取决于language的值\n\n\ngitbook\n指定GitBook版本，使用SemVer规范，几首”&gt;=3.0.0”这样的格式\n\n\n\n\n\n自定义根目录和文件名在GitBook项目中，默认所有文件都是从根目录开始查找的，如果想自定义根目录，需要在book.json中通过root指定根目录。例如，将docs指定为项目的根目录，如下所示:\n\n除root变量之外，还可以自定义GitBook的自述文件、摘要、词汇表和语言文件的名称，这些文件必须在书籍的根目录（或每种语言图书的根目录）下。自述文件、摘要、词汇表和语言文件的默认设置见下表。\n\n\n\n变量\n描述\n\n\n\nstructure.readme\n自述文件名（默认为README.md）\n\n\nstructure.summary\n摘要文件名（默认为SUMMARY.md）\n\n\nstructure.glossary\n词汇表文件名（默认为GLOSSARY）\n\n\nstructure.languages\n语言文件名（默认为LANGS.md）\n\n\n\n\n配置链接如果搭建的是内部文档，右上角的分享链接就没必要出现了，那该怎么关闭呢?\n关闭分享链接的示例代码如下：\n\n如果要在导航栏配置一些链接，其示例代码如下:\n\n\n\n配置插件在book.json中配置插件，与之相关的变量见下表:\n\n\n\n变量\n描述\n\n\n\nplugins\n配置插件列表\n\n\npluginsConfig\n配置插件属性\n\n\n配置插件的示例代码如下：\n\n\n\n插件的安装步骤\n找到插件:由于GitBook将重心放在了网站上，原来的插件页面已不存在，我们只能通过搜索引擎或一些推荐找到想要的插件。\n配置插件:在book.json中通过plugins和pluginsConfig字段配置插件名和插件属性。例如，可以配置插件名为“anotherPlugin”。\n如果想指定特定的插件版本，则可以将插件名配置为“&#x6d;&#121;&#x50;&#108;&#x75;&#x67;&#105;&#x6e;&#x40;&#50;&#46;&#49;&#x2e;&#49;”的样子；如果不指定版本，GitBook默认会使用最新的。\n\n\n安装插件:在项目根目录执行gitbook install来安装插件，仅供当前项目使用。\n禁用自带插件(在自带插件名前面加上-)。GitBook默认自带5个插件:\nhighlight：代码高亮\nsearch：搜索\nsharing：分享\nfont-settings：字体设置\nlivereload：实时加载\n\n\n\n\n\n功能插件\ngitbook-plugin-atoc是一款自动生成文章导航目录的插件\npage-treeview为每一个页面自动生成目录树\nanchor-navigation-ex为每篇文章自动生成目录\ntbfed-pagefooter用来定制每篇文章的页脚，可以添加版权信息和显示文件修改时间\nsearch-pro支持中文搜索\nimage-captions插件自动生成并显示图片标题\ngithub-button插件可以显示GitHub的Star和Fork的数量\nsplitter插件通过拖拽的方式自由调节侧边栏宽度\ndonate插件支持定义和显示支付宝和微信打赏\n\n相关链接:http://gitbook.zhangjikai.com/plugins.html\n\n\n自定义PDF文档的输出格式在book.json中定制输出PDF格式的文档，与之相关的变量见下表：\n\n\n\n变量\n描述\n\n\n\npdf.pageNumbers\n将页码添加到每个页面的底部\n\n\npdf.fontSize\n基本字体大小（默认为12）\n\n\npdf.fontFamily\n基本字体系列（默认为Arial）\n\n\npdf.paperSize\n纸张尺寸（默认为 a4）\n\n\npdf.margin.top\n上边距（默认是 56）\n\n\npdf.margin.botton\n下边距（默认是 56）\n\n\npdf.margin.right\n右边距（默认是 62）\n\n\npdf.margin.left\n左边距（默认是 62）\n\n\n\n\n配置全局变量GitBook的变量分为预定义变量和自定义变量，变量在GitBook构建时会被替换。自定义变量又分为全局变量和局部变量，全局变量在book.json中定义，局部变量在文件中定义。\nbook.json中自定义全局变量的格式如下：\n\n可以像下面这样引用全局变量：\n\n\n\n配置目录\n\n配置多语言GitBook支持用多种语言编写书籍，如果配置了多语言，在打开站点的首页后会看到一个选择语言的页面。\n目录结构按语言分类，每种语言都有一个独立的子目录，在目录中遵循单语言的配置规则，示例如下:\n\n在根目录中有一个book.json文件作为主配置，在每种语言的子目录中也可以有一个book.json来定义自己的配置，它们将作为主配置的扩展存在。\n\n\n配置词汇表在GLOSSARY.md中可以指定词汇及词汇的定义，GitBook会自动构建索引并在文中突出显示这些词汇。GLOSSARY.md的格式如下所示:\n\n注意：词汇不能是中文。\n配置后，在其他页面使用这两个词汇时，它们会被突出显示，如果把鼠标放到上面，则会显示词汇的定义。\n\n\n配置要忽略的文件GitBook是通过Git进行管理的，一般IDE自动产生的文件和编译时产生的文件都是没有必要纳入到版本控制的，因此需要忽略这些文件。\nGitBook会通过读取.gitignore（推荐）、.bookignore和.ignore中的配置来获取要忽略的文件。\n","categories":["Markdown","扩展"],"tags":["markdown","gitbook"]},{"title":"Gitbook笔记（3）——GitHub托管","url":"https://lujw666.github.io/2021/02/18/gitbook-03/","content":"GitBook.com 为每本书籍都创建了一个 Git 项目，并且使用这个 Git 项目来管理书籍源码。\n\n\n连接你的账号/权限在集成你的书本和GitHub前，你需要授予GitBook访问你的GitHub账号的权限。\n在你的 账号设置 里，使用正确的权限连接你的GitHub账号：\n\n默认的权限：仅仅在登陆的时候访问你的GitHub账号来验证你\n访问webhook：访问你的GitHub账号来在指定的仓库中创建webhook（查看webhooks）\n访问公开的仓库：从网页编辑器中访问你的GitHub仓库，你可以很容易的在GitBook中编辑你的书本（仅仅公共仓库）\n访问私有的仓库：和上面一项目一样，但是只能访问私有仓库\n\n\n\n从GitHub导入书创建一本新书的时候，GitHub 标签页让你选择一个 GitHub 仓库导入。\n新创建的书会使用你仓库的内容，webhook 也会自动添加。\n\n\nWebhooks当你的GitHub的仓库改变时，Webhooks会通知GitBook。\n如果你的GitHub仓库改变时，GitBook没有收到通知，这个问题的主要原因是webhook。你可以检查仓库设置中webhook的状态。\n","categories":["Markdown","扩展"],"tags":["markdown","gitbook"]},{"title":"Gitbook笔记（2）——使用","url":"https://lujw666.github.io/2021/02/18/gitbook-02/","content":"创建如下目录结构：\n$ tree book/book/├── README.md└── SUMMARY.md\nREADME.md 和 SUMMARY.md 是两个必须文件。\n\n\nREADME.mdREADME.md是对书籍的简单介绍。\n$ cat book/README.md # READMEThis is a book powered by [GitBook](https://github.com/GitbookIO/gitbook).\n\n\nSUMMARY.mdSUMMARY.md 是书籍的目录结构。\nSUMMARY.md文件中定义书籍的目录结构，格式为链接列表，链接的标题将被作为章节的标题，链接所指向的目标是该章节所对应的文件的路径；如果向父章节添加嵌套列表，则会创建子章节。\n$ cat book/SUMMARY.md # SUMMARY* [Chapter1](chapter1/README.md)  * [Section1.1](chapter1/section1.1.md)  * [Section1.2](chapter1/section1.2.md)* [Chapter2](chapter2/README.md)\n章节可以使用标题或水平线进行分隔,如下：\n$ cat book/SUMMARY.md # SUMMARY## 第一部分* [Chapter1](chapter1/README.md)  * [Section1.1](chapter1/section1.1.md)  * [Section1.2](chapter1/section1.2.md)## 第二部分* [Chapter2](chapter2/README.md)---* [Chapter3](chapter3/README.md)\n如果想要显示目录中章节的层级序号，需要在 book.json 中开启 showLevel 。\n","categories":["Markdown","扩展"],"tags":["markdown","gitbook"]},{"title":"Gitbook笔记（1）——简介及安装","url":"https://lujw666.github.io/2021/02/18/gitbook-01/","content":"GitBook 是一个基于 Node.js 的命令行工具，可使用Github/Git和 Markdown来制作精美的电子书。\nGitBook可以把你的书本生成为许多格式：PDF，ePub，mobi，或者成为一个网站。\n\n\n官方网站GitBook.com 是一个使用工具链来创建和托管书籍的在线平台 &lt;www.gitbook.com&gt;。\n\n\n其他文档开发文档 (API &amp; 插件) 地址：&lt;developer.gitbook.com&gt;\n企业版本的安装向导和手册的地址：&lt;help.enterprise.gitbook.com&gt;\n\n\n帮助和支持通过 &lt;gitbook.com/contact&gt; 来提问题或者报告一个错误\n\n\n系统要求系统需要满足以下两个要求：\n\nNodeJS (v4.0.0及以上)\nWindows, Linux, Unix, or Mac OS X\n\n\n\n使用npm安装安装GitBook的最佳方式是通过npm。在终端提示符下，只需运行以下命令即可安装GitBook：\nnpm install gitbook-cli -g\ngitbook-cli是在同一系统上安装和使用多个版本的GitBook的实用程序。它会自动安装所需的 GitBook 版本来构建书籍。\n","categories":["Markdown","扩展"],"tags":["markdown","gitbook"]},{"title":"Markdown笔记（10）——其他","url":"https://lujw666.github.io/2021/02/18/markdown-10/","content":"HTML不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。\nHTML知识点请参考https://www.runoob.com/html/html-tutorial.html\n\n\n公式在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。\n\n\n\n转义Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\\   反斜线`   反引号*   星号_   下划线&#123;&#125;  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号\n\n\n表情符号使用：包裹表情代码即可，语法如下。\n实例演示如下:\n\n:blush::blush:\n\n更多的表情符号请参考http://www.webpagefx.com/tools/emoji-cheat-sheet/\n","categories":["Markdown","进阶"],"tags":["markdown"]},{"title":"Markdown笔记（9）——排版优化","url":"https://lujw666.github.io/2021/02/18/markdown-09/","content":"关于空格建议中文和英文之间加空格，中文/英文和数字之间也要加空格，不过有些编辑器和输入法会自动添加空隙，就没必要手动添加了。\n\n需要加空格的情况\n英文标点符号（如，.；：？）与后面的字符之间需要加空格，与前面的字符之间不需要加空格。\n当在中文、英文中使用＞（半角）标识路径时，两边都需要加空格。\n\n\n不加空格的情况\n中文标点符号和数字、中文、英文之间不需要添加空格。\n数字和百分号之间不需要添加空格。\n数字和单位符号之间不需要添加空格。\n英文和数字组合成的名字之间不需要添加空格。\n当/（半角）表示“或”、“路径”时，与前后的字符之间均不加空格。\n货币符号后不加空格。\n负号后不加空格。\n\n\n\n\n\n全角和半角对于很多人来说，全角符号和半角符号可能是最熟悉的陌生人，虽然它们随处可见，但大部分人都没用对。\n全角：中文标点符号是全角，占两个字节。\n半角：英文标点符号和数字是半角，占1个字节。\n全角：，。；：!#\n半角：,.;:!#\n\n在中文排版中，要使用全角标点符号。\n在英文排版中，要使用半角标点符号。\n\n\n\n正确的英文大小写很多人在文章、邮件甚至简历中，会把专有名词写错，虽然这并不会影响人们对内容的理解，但有时的确会让人觉得你不太“专业”。\n专有名词要使用正确的大小写，请参考它们的官方文档。\n","categories":["Markdown","进阶"],"tags":["markdown"]},{"title":"Markdown笔记（8）——表格","url":"https://lujw666.github.io/2021/02/18/markdown-08/","content":"Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。\n语法格式如下：\n|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |\n以上代码显示结果如下：\n\n\n\n表头\n表头\n\n\n\n单元格\n单元格\n\n\n单元格\n单元格\n\n\n\n\n对齐方式\n-: 设置内容和标题栏居右对齐。\n:- 设置内容和标题栏居左对齐。\n:-: 设置内容和标题栏居中对齐。\n\n实例：\n| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |\n以上代码显示结果如下：\n\n\n\n左对齐\n右对齐\n居中对齐\n\n\n\n单元格\n单元格\n单元格\n\n\n单元格\n单元格\n单元格\n\n\n","categories":["Markdown","基础"],"tags":["markdown"]},{"title":"Markdown笔记（7）——图片","url":"https://lujw666.github.io/2021/02/18/markdown-07/","content":"Markdown 图片语法格式如下：\n![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)\n\n开头一个感叹号 !\n接着一个方括号，里面放上图片的替代文字\n接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。\n\nMarkdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。\n&lt;img src=&quot;http://static.runoob.com/images/runoob-logo.png&quot; width=&quot;50%&quot;&gt;\n","categories":["Markdown","基础"],"tags":["markdown"]},{"title":"Markdown笔记（6）——链接","url":"https://lujw666.github.io/2021/02/18/markdown-06/","content":"链接使用方法如下：\n[链接名称](链接地址)或者&lt;链接地址&gt;\n例如：\n这是一个链接 [learn](https://lujw666.gitbook.io/learn/)\n显示结果如下：\n这是一个链接 learn\n直接使用链接地址：\n&lt;https://lujw666.gitbook.io/learn/&gt;\n显示结果如下：\nhttps://lujw666.gitbook.io/learn/\n\n\n高级链接可以通过变量来设置一个链接，变量赋值在文档末尾进行：\n这个链接用 1 作为网址变量 [Google][1]这个链接用 learn 作为网址变量 [learn][learn]然后在文档的结尾为变量赋值（网址）[1]: http://www.google.com/[learn]: https://lujw666.gitbook.io/learn/\n显示结果如下：\n这个链接用 1 作为网址变量 Google\n这个链接用 learn 作为网址变量 learn\n然后在文档的结尾为变量赋值（网址）\n","categories":["Markdown","基础"],"tags":["markdown"]},{"title":"Markdown笔记（5）——代码","url":"https://lujw666.github.io/2021/02/18/markdown-05/","content":"如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：\n`printf()` 函数\n显示结果如下：\nprintf() 函数\n\n\n代码区块代码区块使用 4 个空格或者一个制表符（Tab 键）。\n&lt;?phpecho &#x27;learn&#x27;;function test() &#123;    echo &#x27;test&#x27;&#125;\n显示结果如下：\n&lt;?php\necho &#39;learn&#39;;\nfunction test() &#123;\n    echo &#39;test&#39;\n&#125;\n\n也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：\n$(document).ready(function () &#123;    alert(&#x27;learn&#x27;);&#125;);\n\n显示结果如下：\n$(document).ready(function () &#123;    alert(&#x27;learn&#x27;);&#125;);\n","categories":["Markdown","基础"],"tags":["markdown"]},{"title":"Markdown笔记（4）——区块","url":"https://lujw666.github.io/2021/02/18/markdown-04/","content":"区块Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：\n&gt; 区块引用&gt; 学的不仅是技术更是梦想\n\n区块引用学的不仅是技术更是梦想\n\n另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：\n&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套\n显示结果如下：\n\n最外层\n\n第一层嵌套\n\n第二层嵌套\n\n\n\n\n\n区块中使用列表区块中使用列表实例如下：\n&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项&gt; + 第三项\n显示结果如下：\n\n区块中使用列表\n\n第一项\n第二项\n\n\n第一项\n第二项\n第三项\n\n\n列表中使用区块如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。\n列表中使用区块实例如下：\n* 第一项    &gt; 学的不仅是技术更是梦想* 第二项\n显示结果如下：\n\n第一项\n\n学的不仅是技术更是梦想\n\n\n第二项\n\n\n","categories":["Markdown","基础"],"tags":["markdown"]},{"title":"Markdown笔记（3）——列表","url":"https://lujw666.github.io/2021/02/17/markdown-03/","content":"Markdown 支持有序列表和无序列表。\n\n\n无序列表无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：\n* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项\n显示结果如下：\n\n第一项\n第二项\n第三项\n\n\n第一项\n第二项\n第三项\n\n\n第一项\n第二项\n第三项\n\n\n\n有序列表有序列表使用数字并加上 . 号来表示，如：\n1. 第一项2. 第二项3. 第三项\n显示结果如下：\n\n第一项\n第二项\n第三项\n\n\n\n列表嵌套列表嵌套只需在子列表中的选项前面添加四个空格即可：\n1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素\n显示结果如下：\n\n第一项：\n第一项嵌套的第一个元素\n第一项嵌套的第二个元素\n\n\n第二项：\n第二项嵌套的第一个元素\n第二项嵌套的第二个元素\n\n\n\n","categories":["Markdown","基础"],"tags":["markdown"]},{"title":"Markdown笔记（2）——段落格式","url":"https://lujw666.github.io/2021/02/17/markdown-02/","content":"段落Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。\ntext  末尾添加两个空格text或text使用空行来换行text\n显示效果如下所示：\ntexttext\n\n\n字体Markdown 可以使用以下几种字体：\n*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___\n显示效果如下所示：\n斜体文本斜体文本粗体文本粗体文本粗斜体文本粗斜体文本\n\n\n分隔线在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n**** * ******- - -----------\n显示效果如下所示：\n\n\n\n\n\n\n\n删除线如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：\nBAIDU.COM~~BAIDU.COM~~\n显示效果如下所示：\nBAIDU.COMBAIDU.COM\n\n\n下划线下划线可以通过 HTML 的  标签来实现：\n&lt;u&gt;带下划线文本&lt;/u&gt;\n显示效果如下所示：\n带下划线文本\n\n\n脚注脚注是对文本的补充说明。\nMarkdown 脚注的格式如下:\n创建脚注格式类似这样 [^要注明的文本]。[^要注明的文本]: 学的不仅是技术，更是梦想！！！\n显示效果如下所示：\n创建脚注格式类似这样 ^要注明的文本。\n","categories":["Markdown","基础"],"tags":["markdown"]},{"title":"学习前言","url":"https://lujw666.github.io/2021/02/17/learntask/","content":"学习python、R、docker and sql的总结。希望大家协同打造一个编程学习笔记。\n\n\n学习内容存放位置Github:https://github.com/lujw666/learn.git\nGitbook:https://lujw666.gitbook.io/learn/\nBlog:https://lujw666.github.io/\nDockerhub:https://hub.docker.com/repository/docker/lujiawei/learn\n","categories":[],"tags":["其他"]},{"title":"Markdown笔记（1）——标题","url":"https://lujw666.github.io/2021/02/17/markdown-01/","content":"Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\nMarkdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。\nMarkdown 编写的文档后缀为 .md, .markdown。\n\n\nMarkdown 标题Markdown 标题有两种格式。\n使用 = 和 - 标记一级和二级标题= 和 - 标记语法格式如下：\n我展示的是一级标题=================我展示的是二级标题-----------------\n显示效果如下图：\n\n\n\n使用 # 号标记使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。\n# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题\n显示效果如下图：\n\n","categories":["Markdown","基础"],"tags":["markdown","简介"]},{"title":"Hexo-快速搭建博客框架","url":"https://lujw666.github.io/2021/02/17/hexo/","content":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n\n\n相关链接Hexo 中文官网:https://hexo.io/zh-cn/docs/theme-kaze 模板:https://demo.theme-kaze.top/\n\n\n建站步骤\n安装hexonpm install -g hexo-cli &amp;&amp; npm install hexo-deployer-git --save\n创建项目hexo init myblog\n切换到项目并安装依赖cd myblog &amp;&amp; npm install\n新建文章hexo new test\n编辑文章vim source/_posts/test.md\n在Github上新建一个 repository。如果站点通过 &lt;你的 GitHub 用户名&gt;.github.io 域名访问，你的 repository 应该直接命名为 /&lt;你的 GitHub 用户名&gt;.github.io。\n编辑configvim _config.yml,如下\n本地预览hexo g &amp;&amp; hexo s\n推送Githubhexo d\n\ndeploy:    type: git    repo: https://github.com/&lt;username&gt;/&lt;project&gt;    branch: master\n\n\nProject page如果你更希望你的站点部署在 &lt;你的 GitHub 用户名&gt;.github.io 的子目录中，你的 repository 需要直接命名为子目录的名字，这样你的站点可以通过 https://&lt;你的 GitHub 用户名&gt;.github.io/&lt;repository 的名字&gt; 访问。\n需要检查的 Hexo 配置文件，将 url 修改为 https://&lt;你的 GitHub 用户名&gt;.github.io/&lt;repository 的名字&gt;、将 root 的值修改为 /&lt;repository 的名字&gt;/。\n\n\nhexo new 创建新文章hexo new [layout] &lt;title&gt;\n\n\nLayoutHexo 有三种默认布局：post、page 和 draft。在创建这三种不同类型的文件时，它们将会被保存到不同的路径。\n\n\n\n布局\n路径\n\n\n\npost\nsource/_posts\n\n\npage\nsource\n\n\ndraft\nsource/_drafts\n\n\n\n\n文件名称Hexo 默认以标题做为文件名称，但您可编辑 new_post_name 参数来改变默认的文件名称，举例来说，设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章。\n\n\n\n变量\n描述\n\n\n\n:title\n标题（小写，空格将会被替换为短杠）\n\n\n:year\n建立的年份，比如， 2015\n\n\n:month\n建立的月份（有前导零），比如， 04\n\n\n:i_month\n建立的月份（无前导零），比如， 4\n\n\n:day\n建立的日期（有前导零），比如， 07\n\n\n:i_day\n建立的日期（无前导零），比如， 7\n\n\n\n\n草稿Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 source/_drafts 文件夹，可通过 publish 命令将草稿移动到 source/_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局。\nhexo publish [layout] &lt;title&gt;\n草稿默认不会显示在页面中，您可在执行时加上 --draft 参数，或是把 render_drafts 参数设为 true 来预览草稿。\n\n\n模版（Scaffold）在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如：\nhexo new photo &quot;My Gallery&quot;\n在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章。\n\n\nFront-matter文章md文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说：\n---title: Hello Worlddate: 2013/7/13 20:46:25---\n以下是预先定义的参数，可在模板中使用这些参数值并加以利用。\n\n\n\n参数\n描述\n默认值\n\n\n\nlayout\n布局\nconfig.default_layout\n\n\ntitle\n标题\n文章的文件名\n\n\ndate\n建立日期\n文件建立日期\n\n\nupdated\n更新日期\n文件更新日期\n\n\ncomments\n开启文章的评论功能\ntrue\n\n\ntags\n标签（不适用于分页）\n\n\n\ncategories\n分类（不适用于分页）\n\n\n\n\n\n资源文件夹资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。\n\n\n文章资源文件夹对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。可以通过将 config.yml 文件中的 post_asset_folder 选项设为 true 来打开。\n当资源文件管理功能打开后，Hexo将会在你每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。\n\n\n相对路径引用的标签插件通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。\n&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125;\n比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ![](example.jpg) ，它将不会出现在首页上。（但是它会在文章中按你期待的方式工作）\n正确的引用图片方式是使用下列的标签插件而不是 markdown ：\n&#123;% asset_img example.jpg This is an example image %&#125;\n通过这种方式，图片将会同时出现在文章和主页以及归档页中。\n\n\n使用标记嵌入图像hexo3.1.0引入了一个新选项，允许您在markdown中嵌入图像，而无需使用asset_img 标记插件。\n_config.ymlpost_asset_folder: truemarked:  prependRoot: true  postAsset: true\n启用后，资源映像将自动解析为其相应的post路径。例如 image.jpg 文件位于 source/_post/2020-01-02-foo ，这意味可以通过 /2020/01/02/foo/image.jpg调用。\n","categories":["Markdown","扩展","Git","扩展"],"tags":["markdown","hexo","blog","git","github"]},{"title":"Hello World","url":"https://lujw666.github.io/2021/02/17/hello-world/","content":"大家好！今天是我的诞生日。\nHello World！！！！！\n","categories":[],"tags":["其他"]}]