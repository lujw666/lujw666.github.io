[{"title":"SQL语法——SQL USE 语法","url":"https://lujw666.github.io/2021/03/10/sql-use/","content":"当SQL中有多个数据库时，在开始操作之前，需要选择一个执行所有操作的数据库。SQL USE语句用于选择SQL架构中的任何现有数据库。\nUSE语句的基本语法如下所示 :\nUSE DatabaseName;\n数据库名称在RDBMS中必须是唯一的。\n\n\n实例可以查看可用的数据库，如下所示：\nSQL&gt; SHOW DATABASES;+--------------------+| Database           |+--------------------+| information_schema || AMROOD             || TUTORIALSPOINT     || mysql              || orig               || test               |+--------------------+6 rows in set (0.00 sec)\n如果想使用AMROOD数据库，那么可以执行以下SQL命令并开始使用AMROOD数据库。\nSQL&gt; USE AMROOD;","categories":["SQL","基础"],"tags":["sql"]},{"title":"SQL语法——SQL UPDATE 语法","url":"https://lujw666.github.io/2021/03/10/sql-update/","content":"UPDATE 语句用于更新表中已存在的记录。\n可以使用AND或OR运算符组合多个条件。\n具有WHERE子句的UPDATE查询的基本语法如下所示：\nUPDATE table_nameSET column1 = value1, column2 = value2, ...WHERE condition;\n注意：更新表中的记录时要小心！要注意SQL UPDATE 语句中的 WHERE 子句！WHERE子句指定哪些记录需要更新。如果省略WHERE子句，所有记录都将更新！\n\n\nSQL UPDATE 实例以下SQL语句为第一个客户（CustomerID = 1）更新了“CustomerName”和“City”：\nUPDATE CustomersSET ContactName = &#x27;Alfred Schmidt&#x27;, City= &#x27;Frankfurt&#x27;WHERE CustomerID = 1;\n\n\n更新多个记录WHERE子句决定了将要更新的记录数量。\n以下SQL语句将把国家/地区为”Mexico”的所有记录的联系人姓名更新为“Juan”：\nUPDATE CustomersSET ContactName=&#x27;Juan&#x27;WHERE Country=&#x27;Mexico&#x27;;","categories":["SQL","基础"],"tags":["sql"]},{"title":"SQL语法——SQL DELETE 语法","url":"https://lujw666.github.io/2021/03/10/sql-delete/","content":"DELETE语句用于删除表中现有记录。\nSQL DELETE 语法:\nDELETE FROM table_nameWHERE condition;\n注意:删除表格中的记录时要小心！注意SQL DELETE 语句中的 WHERE 子句！WHERE子句指定需要删除哪些记录。如果省略了WHERE子句，表中所有记录都将被删除！\n\n\nSQL DELETE 实例假设我们想从”Customers” 表中删除客户“Alfreds Futterkiste”:\nDELETE FROM CustomersWHERE CustomerName=&#x27;Alfreds Futterkiste&#x27;;\n\n\n删除所有数据可以删除表中的所有行，而不需要删除该表。这意味着表的结构、属性和索引将保持不变：\nDELETE FROM table_name;\n或者\nDELETE * FROM table_name;\n注意：在没有备份的情况下，删除记录要格外小心！因为你删除了不能重复！\n","categories":["SQL","基础"],"tags":["sql"]},{"title":"SQL语法——SQL INSERT INTO 语法","url":"https://lujw666.github.io/2021/03/09/sql-insert-into/","content":"INSERT INTO 语句用于向表中插入新的数据行。\nSQL INSERT INTO 语法：\nINSERT INTO 语句可以用两种形式编写。\n第一种形式无需指定要插入数据的列名，只需提供被插入的值即可：\nINSERT INTO table_nameVALUES (value1,value2,value3,...);\n第二种形式需要指定列名及被插入的值：\nINSERT INTO table_name (column1,column2,column3,...)VALUES (value1,value2,value3,...);\n\n\nINSERT INTO 实例在”Customers”表中插入一个新行：\nINSERT INTO Customers (CustomerName, ContactName, Address, City, PostalCode, Country)VALUES (&#x27;Cardinal&#x27;,&#x27;Tom B. Erichsen&#x27;,&#x27;Skagen 21&#x27;,&#x27;Stavanger&#x27;,&#x27;4006&#x27;,&#x27;Norway&#x27;);\n插入一个新行，但只在“CustomerName”、“City”和“Country”列中插入数据:\nINSERT INTO Customers (CustomerName, City, Country)VALUES (&#x27;Cardinal&#x27;, &#x27;Stavanger&#x27;, &#x27;Norway&#x27;);\n\n\n使用另一个表填充一个表可以通过另一个表上的SELECT语句查询出来的字段值，然后将数据填充到本表中，条件是另一个表所查询的字段与本表要插入数据的字段是一一对应的。\nINSERT INTO first_table_name [(column1, column2, ... columnN)] SELECT column1, column2, ...columnN FROM second_table_name[WHERE condition];\n","categories":["SQL","基础"],"tags":["sql"]},{"title":"SQL语法——SQL HAVING 语法","url":"https://lujw666.github.io/2021/03/08/sql-having/","content":"HAVING 子句能够指定过滤条件，从而控制查询结果中哪些组可以出现在最终结果里面。\nWHERE 子句对被选择的列施加条件，而 HAVING 子句则对 GROUP BY 子句所产生的组施加条件。\nSQL HAVING 语法:\nSELECT column_name(s)FROM table_nameWHERE conditionGROUP BY column_name(s)HAVING conditionORDER BY column_name(s);\n在 SELECT 查询中，HAVING 子句必须紧随 GROUP BY 子句，并出现在 ORDER BY 子句（如果有的话）之前。\n\n\nSQL HAVING示例以下SQL语句列出了每个国家/地区的客户数量。只包括超过5位客户的国家/地区：\nSELECT COUNT(CustomerID), CountryFROM CustomersGROUP BY CountryHAVING COUNT(CustomerID) &gt; 5;\n\n\n以下SQL语句列出每个国家的客户数量，从高到低排序（仅包括拥有超过5名客户的国家/地区）：\nSELECT COUNT(CustomerID), CountryFROM CustomersGROUP BY CountryHAVING COUNT(CustomerID) &gt; 5ORDER BY COUNT(CustomerID) DESC;\n\n\n以下SQL语句列出已注册超过10个订单的员工：\nSELECT Employees.LastName, COUNT(Orders.OrderID) AS NumberOfOrdersFROM OrdersINNER JOIN Employees ON Orders.EmployeeID = Employees.EmployeeID)GROUP BY LastNameHAVING COUNT(Orders.OrderID) &gt; 10;\n \n\n以下SQL语句列出员工“Davolio”或“Fuller”是否已注册超过25个订单：\nSELECT Employees.LastName, COUNT(Orders.OrderID) AS NumberOfOrdersFROM OrdersINNER JOIN Employees ON Orders.EmployeeID = Employees.EmployeeIDWHERE LastName = &#x27;Davolio&#x27; OR LastName = &#x27;Fuller&#x27;GROUP BY LastNameHAVING COUNT(Orders.OrderID) &gt; 25;","categories":["SQL","基础"],"tags":["sql"]},{"title":"知乎一小时 056 如何高效地管理团队：年轻管理者手册","url":"https://lujw666.github.io/2021/03/07/ZhihuOneHour056/","content":"第一章 管理新人初长成一、为人还是为己大多数人其实既不是 Giver，也不是 Taker，而是 Matcher，为人和为己之心都有，我们会不自觉地衡量自己的付出和索取，争取一种平衡。\n当你成为管理者之后，为人和为己的天平自然需要一个调整。你需要更多地服务你的下属，尽力帮助他们的成长，为他们谋得福利。\n你的下属将为你工作，他们的努力如果获得回报，你毫无疑问会成为最大的受益者；而如果团队失败，你也必然遭受最大的挑战。所以无论成败，你都应该尽力帮助和给予他们。\n需要开始做这些观察和思考：\n\n你的下属在工作上遇到的困难和阻碍；\n搜罗或者争取哪些资源来帮助他们；\n怎样不吝啬赞美来激励他们；\n他们在学习、生活和情感上是否遇到困惑和低潮？\n\n\n\n「吃亏是福」同样适用于职场在企业中，短期的绩效会是一个无形的压力，它会影响成员的观念和行为。我们有时候并非不愿意帮助他人，而是由于现实的经营压力不得不多考虑一下自己。部门存在隔阂、上级与下属相侵大多缘于这样的绩效之争。\n更多愿意帮助他人的基层员工往往花费了太多的精力，影响了自己的短期绩效，尤其是被 Taker 利用的时候，但一旦走上管理岗位，Giver 的利他行为往往很快能够赢得更多的尊重和下属背书，从而在职场发展中处于更有利的位置。\n\n\n最有价值的帮助和给予是精神当我们说给予他人的时候，并不限于经济和物质方面，当你走上管理岗位，更加有价值的给予在于知识和精神层面。\n需要知道做出利他行为的动机并不是企图未来的回报，而是以下这些：\n\n个人对他人福祉的关切感\n责任感\n社会公正感\n同情心\n\n此刻，你可以分析你的动机，也可以培育你的动机，至少开始体验这些内心感受和自己本能行动上的联系。\n\n\n二、成员们最厌恶和最偏爱的三件事当你走上管理岗位，欲加影响于他人之前，首先要了解自我的局限。\n了解自我的第一步不是去解剖自己的灵魂，而是了解自我认知的规律。这未必需要你去深究心理学，但有几项普通而又重要的规律对你能否驾驭管理工作至关重要。\n\n\n你不可能真正了解和改变他人你和你的下属之间可能经历了面试、工作沟通、生活谈话。你们也可能从早到晚相处了很多的时间。但如果你的管理预设是充分了解一个人，然后有针对性地改变一个人，请小心制定这样的目标。\n管理者主观判断出下属的问题，试图指出问题，以求直接改变，这几乎是最糟糕的管理路径，因为它不仅成效低下，而且容易导致成员的抗拒。\n这种抗拒并不会发展成明面上的争吵，它要么让你的下属丧失自信、感觉委屈，要么无法从个人发展中感到满足，这样一来，他选择离开或者被迫离开团队的概率是非常高的。\n所以，当你走上管理岗位时，难免会本能地开始分析自己的下属，也许你会很认真地在笔记本上写下每个人的名字、评语及改进办法。如果你开始这样做了，请转念想一下这个问题：如果你的老板也在同一个夜晚，在笔记本上做了同样的笔记，其中提到了你本人，你会希望他写下什么样的评语？\n\n\n人最厌恶的三件事你的评语与改进计划无法奏效还有一个与人性有关的原因，即每个人都厌恶的三件事：被说不、被忽视、被指出缺陷。\n被说不就是被拒绝，被忽视就是缺乏关注。如果你的生活充满这两件事，基本就是悲惨的生活，这你不会有什么异议。但是「被指出缺陷」是人最讨厌的事情吗？ 你可能觉得不至于，对这五个字感受并不强烈。这是为什么呢？\n\n我并未指出你本人的缺陷；\n你也许并不觉得自己有什么明显的缺陷。\n\n如果是这样，当我直接指出你的问题，而这个问题你感觉很委屈的时候，我们就进入了沟通中最糟糕的局面。我们彼此之间必将封闭，所有的沟通不仅无效，而且彼此伤害。\n由此带来的沟通失败并不会显性表现出来，它不会引发争吵，相反，它从表面上看一点问题都没有，彼此继续和和气气，但不信任、不认同的关系就此固定下来。\n所以，无依据地根据个人判断指出他人的缺陷（即使你的判断是对的）是一个高风险的管理行为，即使对你的下属也是一样。\n那你肯定要问，如果明明知道下属有问题，还不能指出，那么我们怎么进步呢？\n别着急，我们现在要构筑的是管理的心理准备，你要对与此相关的人性规律有了解。改变他人是一件说难很难、说简单也简单的事情，因为只有一个途径，那就是改变你自己。\n\n\n赞扬是影响他人的最好办法人有最偏爱的三件事：被认同、被关注、被赞扬。\n要记得在人际沟通中，赞扬是启动有效沟通的进气阀，如果这个阀门没有打开，沟通要么是浪费时间，要么就起到相反的效果。\n这里的逻辑是这样的：你知道赞扬能够给人愉悦的感受，从而维护或者激发他的工作状态，于是你要关注赞扬的机会；因为你要找到赞扬的机会，又不能让赞扬显得随意和普遍，所以要更加关注下属的进步和变化；因为你要着眼于变化，所以你需要持续关注。\n\n\n无需把成功的 CEO 当榜样影响我们遵循人性的规律做出正确的管理假设，还包括一个有趣的原因，那就是其他管理者的示范。新晋管理者受到的最大影响是他本人的前老板，尤其是生意上比较成功的老板。\n但你要知道这么几个事实：\n\n对你的前老板，你根本没有那么了解，你对他们的人格判断仅仅是来自他人的总结或者你的观察。你也不知道他们在管理过程中是否有所变化，往哪个方向变。\n即使你的判断是对的，你也不知道，如果他们更加懂得关注和赞扬他人，会不会更成功？\n每个成功的管理者的确都有综合的能力，管理成功的结果来自很多要素，甚至包括外界的环境。但从长期的角度看，每位管理者都会在他的下属身上留下印记，这决定了企业的长期命运。\n\n更重要的是，更多的成功管理者是有完善的自我认知，会洞察人性，懂得通过关注和赞扬成员来激发热情，从而帮助企业获得成功，只不过媒体和舆论较少提到他们的名字而已。\n\n\n三、如何帮助你的成员？约翰米勒有一本著名的畅销书，名字就叫《问题背后的问题》，英文简称 QBQ。它给职场人士提供了一个怎样提升个人责任感的思维模式指南。简单说，就是在遇到问题的时候，改变问问题的方式，着眼于改变自己和当下，不要试图改变他人。\n不要试图改变他人，你根本改变不了，唯一能够改变依然是你自己。按照 QBQ 的精神，你同样应该围绕这个问题着眼于自己和当下。\n\n\n帮助成员提出 QBQ 问题给自己一个承诺，永远不要直接指出下属缺乏责任感、不够 QBQ，而是要建立具体问题具体沟通的习惯。\n如果你发现成员开始抱怨（首先要理解这是人之常情），你要帮助他开始用 QBQ 的模式提出新的问题。\n你不仅可以帮助下属提出这个问题，而且可以让他拥有这个问题。这时，尽管是被动的，但你的下属至少拥有了一个 QBQ 模式的问题去解决。当他要着手去解决这个问题时，他成了问题的主人。\n如果他能够从解决这个问题的过程中领悟到更多，也不再是你改变了他，而是他改变了他自己。他也许能够开始意识到问题背后的问题该怎么问，每个问题背后都有一个当下和自己能够执行的解决方案。\n\n\n帮助成员建立逻辑有很多不够 QBQ 的问题本身就有很大的逻辑漏洞。\n比如销售可能会抱怨产品价格过低，导致销售额上不去；营销部门可能会抱怨产品缺乏卖点，所以点击率很低；质量部门抱怨研发管理太弱，导致测试工作量过大；研发部门抱怨需求经常变动，所以常常做无用功。这些都是办公室内常见的躲避责任的问题。\n商业的结果几乎总是多因的：销售的成功来自产品的优秀、渠道的通畅、定价的合理、品牌的口碑；员工的成长来自本人的努力、有效的引导、有挑战的目标；利润的构成来自收入的提成和成本的控制；研发的质量来自设计的合理、有经验的团队和有效的质量控制；项目的准时交付来自清晰的进度、资源的到位、变更的把控、及时的沟通。\n当员工提出了与此相关的抱怨，无非是因为着眼于狭窄的角度，没有从完整的视角来看待问题。\n所以，当遇到这种情况时，我们无需责怨和试图让成员直接变得 QBQ，而是首先要让他看到因果全貌。富有逻辑的沟通总是能够有很强的说服力，试图直接改变他人的沟通总是两败俱伤。\n\n\n帮助成员提升自我我们无法直接改变他人，但是每个人都可能自我改变。同样的道理，你的下属的个人成长和你的说教无关，只和他自己改变的意愿有关。\n企业文化当然能够影响每一位成员，但是按照 QBQ 的精神，你永远都不能等待企业从上至下的文化影响，而是应该随时落实在你周边的成员。\n多阅读、多分享，寻找机会帮助他人，建立不评价他人的团队习惯。物以类聚，人以群分，作为团队领导，你的影响力是客观存在的。我们未必需要多谈表率和榜样，只要着眼于「帮助」你的下属提升自我的目标即可。\n实际上，当你下定决心这样去做，不用多久，你就会发现你的团队与众不同：他们不仅减少了抱怨，而且会越来越多地 QBQ 地解决问题。这正是你作为管理者的幸福感源泉。\n相反，如果你还没有感受到团队的足够进步，请坚持做下去。抱怨团队是管理的天敌，是你失望、焦虑、混乱和管理失败的起源。\n\n\n第二章 如何高效管理管理的首要任务并非「管事」，而是「理事」。\n管理者的工作应该以能够达成公司目标的任务为基础，是实质工作。\n\n\n一、企业的任务从何而来企业任务大体有两种性质：常规和关键。如果我们理解了企业的常规任务和关键任务，有助于厘清管理工作的核心内容。\n企业的战略决定了企业的任务来源，而竞争环境则决定了关键任务的多寡。\n\n\n从战略到目标在确定任务之前，我们先回到本源：怎样确定企业的战略和目标？\n我们日常的所有沟通都可能随时需要来和战略比对，所以，如果我们只谈工作目标、不谈战略反倒是不可能完成的任务。\n任何企业都会从某种模糊的战略愿景出发，不管你是不是用「愿景」来称谓它。\n没有战略愿景是足够清晰的，至于正确还是错误则是未来才能验证的事情。所以，更重要的是要有这么一个愿景存在。\n至于对未来愿景判断的时间周期，大体取决于行业的竞争变化的速度。但不同行业用来勾勒战略愿景的时间尺度大体上有章可循。比如农业、医疗、教育、汽车行业通常需要展开五到十年的周期；而互联网、金融、媒体这些行业则要短得多，在极端的情况下，两到三年的周期有时候都会显得过于遥远。\n一个企业可以自主制定自己的长期战略，但是永远需要根据市场环境和竞争来建立中短期的战略目标。而这个目标将用来帮助企业团队确定这段周期的关键任务。反过来说，如果这些关键任务不能被有效识别和完成，中短期战略目标就难以实现；这个目标如果不能实现，长期战略愿景就流于空想。\n在我们进入下一环节之前，还需要多花一点时间来审视目标。\n每个团队都面临过目标分解的时刻，要记住，在时间维度上进行目标的切分永远是一件好事。但我们实际的管理行为往往着眼于从另外一个维度进行目标分解。\n\n\n二、识别并执行关键任务从目标到关键任务任何一个企业的目标和任务都不可能这么简单。那么，企业的关键任务是如何从目标中分解出来的呢？\n当你成为一名管理者，每天都将面临目标和任务，即使你情商很高、通达人性、受到下属尊重，但在任务分解的过程中没有建立正确的认知，一样会遭受挫败。\n\n\n企业的短期目标由某一个关键因素驱动在理解关键任务的过程中，我们先要看到一个事实：企业长期目标的达成取决于竞争优势和整体能力的完备，两者缺一不可，但中短期目标达成的驱动因素会比较单一 。在更短的周期内，例如一个季度的目标，则基本取决于一两项关键事务的完成。\n无论是观察成功还是失败企业的案例，都会发现这个普遍规律：在特定周期内，如果企业无法识别出关键任务，就一定会在竞争中落败。\n\n\n不同阶段的企业的关键任务逻辑首先，不同阶段的企业大致会存在一些普遍规律：\n\n初创型企业\n\n初创型企业通常面临两类关键任务。\n第一类是有关于生存。\n第二类关键任务是试错。\n\n成长型企业\n\n当你的团队有幸能够迈过初创期，研发出基本适销对路的产品，理顺了供应链，发展出有效的营销方法和渠道，拥有了第一批顾客，恭喜你进入了成长型企业阶段。\n成长型企业的关键任务也可以大致分为两种。\n第一种我们称为消除瓶颈。\n比较常见的增长瓶颈包括：\n\n在量产阶段的质量挑战。 对于制造业而言是工艺可靠性和良品率，对于服务业是流程和团队扩展过程中的服务意识保证，即使对于互联网服务和软件行业，也有在大规模用户情况下的服务可靠性。\n短板凸显。 在早期的低销量和试错期，我们很难聚焦去解决短板问题，但进入增长阶段后，如果有明显的能力缺失，就会导致业务循环无法完整进行。\n跨越主流市场鸿沟。 因为初创企业获得早期用户时不可避免会带有两种特征，一种来自先锋性用户，愿意尝试新鲜的产品和服务，另一种来自社交推广的内圈红利。这两种用户特征和主流市场必然有很大的差异。中庸的主流用户大多不愿意尝试过于新颖的产品和服务，他们会观望和模仿其他用户；通过社交营销实现了首批客户获得后，因为缺乏后继的话题和注意力在主流市场难有作为，或者面临越来越高的营销成本。\n\n第二类关键任务通常是增强成长动因。 意思是在大多数瓶颈消除后，利用市场出现的机会快速突破，达到令竞争对手望而却步的规模标准。\n\n成熟型企业\n\n首先是「发现增效机会」。成熟企业依然可以通过降低成本和提高效率来提升经营绩效，无论是研发、生产还是销售部门均有这样的机会。\n成熟型企业还要警惕另外一种假象。有的时候，你所在的行业其实并非成熟行业，而是夕阳行业。这意味着市场并非稳定，而是需求开始下降、供给开始过剩。实质上，企业已经进入下降通道。\n这个时候，增效也许已经不是关键任务。开拓新的市场，进行大力的业务转型才是企业的生命线。\n当成熟企业需要转型到新的领域时，它的关键任务逻辑其实和初创型企业比较接近，只是在关键任务中生存类的任务要少于试错类。\n\n\n三、管理常规任务最核心的办法除了关键任务以外，每个企业都会有大量的常规任务。\n管理好常规任务的最核心办法是什么呢？\n\n流程标准\n监督管控\n绩效考核\n\nA，B，C 大概是一个逻辑的先后关系，所以你也可以认为每一项都是需要做好的。但是，如果你的资源非常有限，假设你只剩下最后一点精力，选择 A，而不是大多数人直觉上选择的 C。\n\n\n盯住流程标准会抹杀创造性吗？流程标准会不会抹杀员工的创造性呢？实际上真正伤害创造性的是 B 和 C（强硬的监督和试图用奖惩来控制结果）。\n实时监督和控制让执行者失去思考和判断的机会；而仅仅着眼于结果考核，并不能保证一个企业的运营质量，很多的常规任务执行并没有事后补救的机会。\n当我们有了完善的流程标准后，我们依然可以鼓励员工在执行过程中进行比较和思考，找到改进方法和流程的机会。\n所以，在关键任务以外，管理者的任务还包括通过设计和维护流程标准来完成企业的常规任务。\n\n\n四、不要重复发明轮子常规任务所对应的流程标准就像企业的轮子，它的转动能够推进企业。但是你的团队不可能一成不变，新成员加入的时候会不小心重新发明一个轮子。\n比如一家制造企业在交付货物给客人时制定了一个质量控制的流程，但是随着业务量的发展，新的员工加入时不知道有这么一个流程存在，于是他按照自己的理解来执行，结果可想而知，必然错漏百出。\n重复发明轮子，不仅成本高昂，而且质量低下。那我们怎样防范重复发明轮子？这要求管理者懂得策展（curate）知识。\n你也许听说过日本知识管理专家野中郁次郎的 SECI 模型，他把知识的形成过程描述为群化（Socialization）、外化（Externalization）、融合（Combination）和内化（Internalization）的循环。\n我们所说的知识策展就是他所描述的 Externalization（外化）的过程，这也是各层级管理者的管理任务之一。\n以下是一些有用的策展知识的形式：\n文章（Article）这是最基础的内容整理形式，之所以特称为「文章」，是因为整理者有义务围绕一个主题完整成文，交代上下文背景，构筑相对完整的写作结构，呈现明确的写作目标，最终都是为了方便读者建立理解。因此，它显然地区别于日常工作中的一般性沟通和分享。\n单篇文章所涉及的主题不需要过于宏大，越具体越好。文章累积到一定程度，我们就可以编排辑录，说白了就是可以依据文章的主题逻辑关系，编撰成册。\n这个过程目前已经可以高度数字化，有些企业使用 Wiki 工具来进行写作，不仅方便内部协同编辑，还可以随时保持内容的更新。Wiki 条目也可以通过章节关系和互链功能建立连接。\n检查清单（Checklist）这是一种简洁有效的知识整理形式，主要用于质量控制要求较高的流程性工作指南。\n检查清单同时还是一个重要的主动质量管理工具，但凡严格使用检查清单的企业，运营差错率更低，客户满意度更高。检查清单需要在实践中不断优化，通常在运营中产生的问题，经过成因分析，都能够通过检查清单来巩固未来的运作质量。\n检查清单可以用文章的形式来体现，如果足够重要，可以印刷成执行人随身或者案头张贴的卡片。\n有别于一般的知识整理，检查清单通常需要设计得非常简洁，专注在检查列表上，而不是再事无巨细地罗列每个检查项目的执行方法。\n流程图（Flow chart)和检查清单类似，流程图也是一种针对特定知识传递需求的形式设计。顾名思义，它既能够帮助读者了解一个复杂商业流程的全貌，也能够按图索骥，了解特定环节的处理规范。\n问题（Issue）文章、检查清单和流程图都是基于正常或理想状态下的企业运营知识整理形式。还有一种形式对于处理具体和例外状态更加恰当，那就是问题和案例。\n问题（Issue）一般可以分为常见和偶发两种类型。前者可以形成《常见问题与解答》，这是性价比很高的知识整理形式，因为少部分的内容可以用来反映大部分的知识传递需求。\n但偶发性的问题与解决方案同样重要，它也被称为「预案」（Contigency Plan），因为一旦发生，可能带来较大的损失。\n模版与表单（Template and Form）针对企业运营中不断重复的个性化流程，也可整理为「模版」或者「表单」，它能够帮助新人用最少的培训获得基本作业能力。\n例如广告公司针对消费品牌的营销服务中，常常根据客户需求的类型预先准备好提案的模版，虽然这不可避免地会降低原创程度，但对于需要通过重复来扩张规模的企业来说，是必须的选择。\n范式订单也是一种模版，它通常设计为可以直接填写的表格，通过罗列的单元格，让销售人员对订单执行中的诸多要素进行理解。\n所以，模版本身也是一种通过纲要来学习细节的工具。当我们要指导新员工如何评估客户满意度时，千言万语不如一张「客户满意度调查表」来得清晰有效。\n样例和案例（Example and Case）总有一些复杂的流程和技能是无法模版化的，这时候，我们可以通过另外一种整理形式来实现沉淀和利用——样例和案例。\n如果项目性质演变为营销或管理咨询，服务的流程大概就不可能依靠范式的文档来实现重复，此时，需要富有经验的服务人员将过往的执行整理为样本或者案例：前者是一个具体的工作成果展现（例如：项目策划建议书）；后者则是包括更加完整的背景描述、执行过程和结果评估的报告。无论何种详尽程度，它们起到的作用是类似的。\n样例和案例的整理通常需要花费更多的精力，因此，企业不必追求数量多，而是应该精益求精，力求通过最少的数量覆盖多元的场景类型。\n专家名录（Expert Directory）专家名录或者专家网络就是将运营环节中的难点和主题挖掘出来，依据每一个难点定位企业内部的专家。\n他们往往是这些难点问题的深度参与对象，具有丰富的经验，善于解决具体问题，同时，还要具备突出的分享精神。总之，这些员工往往是团队中德才兼备的明星成员。\n形成了问题和专家的对应关系后，就要把这组信息有效地传递给全员，让员工在遇到特定问题的时候，有一个明确的求助目标。\n\n\n第三章 管理的首要途径——沟通一、沟通的边界无论是规章制度，还是绩效考核方法，其实施都不会自动发挥作用；即使成员都百般顺从，也不可能一定会带来有价值的成果。但我们总是急于完成这些从上至下的简单沟通任务，认为规章和指令只要传达到位，就能够让它们生效。\n实际的情况并非这样，否则我们为什么还要开动员会，为什么还要有总经理意见箱，为什么还要有一对一？\n在企业组织中，沟通的挑战主要来自于这些边界：\n层级的边界除了管理者和直接下属之间心理上的隔阂之外，更严重的是跨越层级的边界，例如 CEO 和一线员工之间。\n部门的边界因为角色和目标的差异，不同职能部门容易站在本部门的角度看待问题，急于完成本部门的目标，导致沟通的成效极低。更加不要说两个不同部门的基层员工，他们之间的沟通很大程度上无法直接进行，而是要通过各自的上司进行。我们称这种沟通为倒 U 型沟通，或者深井式沟通。\n地理的边界因为成员不在一起，只能依靠远程协作工具，缺乏口头的当面交流，难以体察情绪反馈。地理的边界不一定是北京和上海这种异地距离，楼上楼下、相隔几个办公位就已经存在地理边界了。真正在地理上相对畅通的沟通几乎只能发生在一室之内。\n社会心理的边界当然，更多困扰我们的沟通屏障是来自职场中约定俗成的社会心理定势。担心多管闲事，少说多看，不敢冒犯上司，不愿打扰同事，虚伪奉承，担心越级越位，生怕招惹是非，包括部分成员的社交恐惧和社交泛滥，都会影响一个企业组织内部的沟通成效。\n\n\n在企业的早期阶段，规章制度、绩效考核这些管理工具几乎都很薄弱，但小企业之所以能够拥有生存和发展的可能，全有赖于它在层级扁平、边界淡薄阶段突出的沟通优势。也就是说，你的团队可以暂时没有明确的规章制度，但绝对不能没有顺畅的沟通。\n\n\n二、如何打造流畅的沟通？沟通的首要原则是透明描述沟通质量有很多维度，比如及时性、准确性、简洁性、完整性，但这些标准是否满足沟通的需要都会因时而异。在管理沟通中，唯有透明度是首要的通行要求。\n在你组织内部沟通工作时，除了极少数需要权衡保密的信息以外，大多数的沟通都应该尽可能让参与者周知的。反过来，形成团队效率制约的主要原因也在于沟通的不透明。\n它可能造成成员对企业目标的不清晰和不一致，对资源和条件的不了解，对团队其他成员的努力不知情，无视已经达成的阶段性成果，从而产生战略失焦、战术莽撞、成员误解、重复投入的问题。\n开放领导力华人咨询师 Charlene Li 在 2010 年出版的畅销书 Open Leadership 一书中首次提出了开放领导力的概念。\n和传统的领导力理论不同，她指出管理者的领导力不仅可以从提升情商中获得，也可以从推动开放沟通行为中增强。她还为企业内部的开放沟通行为作出了显性的定义，把管理者应该推动的透明沟通模式概括为以下六点：\n\n解释说明（Explaining）\n\n管理者从上至下的沟通常常包括战略决策、公告命令、任务指派。\n这些沟通大多都是单向的，而且往往容易被简化为公文，缺乏对参与者的解释说明。例如战略决策信息，我们需要说明这个决策的原因，如果我们不执行这个战略会导致什么后果？如果我们执行这个战略还会遇到什么挑战？\n当我们增加这些从上至下沟通内容的解释说明成分时，参与者可以获得更多的上下文，加深对决策理解和支持的程度，同时也有机会了解到可能存在的疑问和反对意见。\n\n\n知会（Updating）\n\n知会讲的是全员工作沟通的基本模式。有别于传统的管道式工作汇报（A 向 B 汇报，B 向 C 汇报），知会着眼于尽可能多和直接地让同事了解工作进度、问题和计划。\n在社交网络中，最常用的缺省提示是「你在想什么？」这正是一个绝佳的知会动作提示。通过知会，可以及时让同事了解你的工作状态、计划和可能遇到的问题，而如果采用传统的管道汇报、整理和再沟通，不仅效率低，而且会伤害沟通的准确性。\n\n\n自由对话（Conversing）\n\n自由对话讲的是允许和鼓励组织内任何成员之间直接沟通和协作，而不需要经过部门和层级的路由。\nA 部门的基层员工无需通过 A 部门的领导就能够直接和 B 部门需要进行协作的基层员工对话，基层员工在需要的情况下可以直接和跨越层级的领导协作。\n只要保持沟通在透明环境中进行，准确地说，就是充分使用知会的沟通模式来让相关人员都周知。\n\n\n开放发言（Open Mic）\n\n开放发言指的是允许和鼓励任何成员发起集体沟通，无论他（她）提出的是什么性质的话题。这个原则着眼于让团队在沟通层面建立无话不可说的氛围。\n常见的开放发言着眼于头脑风暴式的集体创意（ideation），集思广益，鼓励提出想法和点子。\n除此之外，更大的挑战在于允许和鼓励公开谈论企业问题，比如产品质量问题、需求适配度问题、竞争对手的优势、市场前景不佳，甚至包括对管理制度文化的意见。\n公开谈论企业问题是始终要实现的目标，尤其在发展速度很快的行业中，正视问题才是迅速解决问题的最大动力。\n在集体会议中，太多的意见，不符合当下聚焦点的建议需要一个分类梳理的模式，但更重要的是不要武断地打断好不容易发生的公开发言。无论对方讲的是什么内容，都应该允许被提出来，而不要当场压制。\n否则，不但发言的人备受打击，其他成员也会因此而更多地顾忌自己的发言内容。下图是一个简单易行的沟通讨论控制模式，它不仅能够让开放发言更加有针对性，而且能够促进参与者发言的意愿。\n\n\n众包（Crowdsourcing）\n\n众包并非外包的一种形式，而是指企业内部任务分配的模式。传统的任务大多是指派给特定成员的，而众包式任务分配则是指公开征求愿意负责任务的人、主动愿意来承担的成员成为任务的负责人。\n对于重要和关键的任务，如果有了主动承担的意愿度保证，则会大大提高任务完成的质量。当然，一个组织如果能够实现很多的众包式任务分配，它的前提是已经初步建立了开放沟通的文化氛围。\n\n\n使用统一平台（Platform）\n\n为了实现开放沟通的目标，组织还应该对沟通的方式和平台有约定和要求。如果不同成员使用不同的沟通平台，那么我们所要达成的透明度目标在物理上也实现不了。所以，在沟通方式的约定上，并不依赖民主和自治，它要求大家达成一致意见。\n除了平台和工具的选择，沟通的内容和形式也应该约定。如果我们要求每天知会工作，那么知会内容应该包含哪些方面，也应该作出要求。\n\n\n\n\n\n三、什么是管理沟通的真正挑战在本书的最后，我们进入管理沟通的最大挑战——倾听和教练。这也是管理者成长到一个阶段后必然遭遇的困境和反思时刻。\n倾听是沟通的一部分沟通才是管理真正有效的途径，那么我们自然应该理解倾听就是沟通的一部分。\n通过一些管理技术，的确也可以根据绩效数据来判断员工的问题所在。比如销售漏斗中，根据逐段的转化率差异分析，可以有针对性地帮助提高。\n但是这些来自数据的分析只能起到提升员工绩效的教练目标，而并非着眼于员工的发展。所以在培训领域，我们需要区分的是为「绩效」（performance）的培训，还是为「发展」（development）的教练：前者能够提供员工的局部技能，后者能够帮助你构筑有长期竞争力的团队。\n学会问好的问题想要让成员讲述有价值的内容，你需要学会问好的问题。\n提问是最好的教练方式，因为在个人发展方面，任何的直接说教不仅不能改变人，而且也无法启发思考。当我们听到一个提问时大脑运行的模式和听到一段说教时的运行模式是不一样的。\n前者会让对方快速开启搜索模式，寻求答案，后者会让对方的思考停止，接受和记忆度也随之降低。况且，在很多情况下，管理者未必能够有足够的信息和知识来指导员工。\nMichael Bungay Stanier 在 The Coaching Habit 一书中提供了管理者提问的最佳选择。他建议了七个好问题，或者提问模式，分别有不同的目的，但总体上都是为了让提问的你能够更有效地倾听，启发被问者自发找到更完善的答案。\n\n开启谈话的开放问题：「最近在思考什么？」\n持续深挖的问题：「还有什么吗？」\n帮助聚焦的问题：「在这里，你真正的挑战是什么？」\n帮助找到基石和根源的问题：「你真正想要的是什么？」\n提示让成员自主思考和承担的问题：「这些事情中哪些是需要我来帮你做的？」\n促进战略思考的问题：「如果我们选择做这个，那么你会选择放弃哪一个？」\n促进学习的提问：「今天你觉得什么对你最有用？」\n\n你不必呆板地引用这些提问例句，更重要的是理解为什么要用提问来开启倾听。只有你真正听到了成员的表达，才明白自己所处的管理环境，才能进一步通过沟通和协调来达到你的目标。\n","categories":["科普","知乎一小时"],"tags":["管理"]},{"title":"python笔记（02）——解释器","url":"https://lujw666.github.io/2021/03/07/python-02/","content":"解释器Linux/Unix 的系统上，Python 解释器通常被安装在 /usr/local/python3 这样的有效路径（目录）里。\n可以将路径 /usr/local/python3/bin 添加到您的 Linux/Unix 操作系统的环境变量中，这样您就可以通过 shell 终端输入下面的命令来启动 Python 。\n$ PATH=$PATH:/user/local/python3/bin/python #设置环境变量$ python3 --vesionPython 3.7.6\n在 Window 系统下你可以通过以下命令来设置 Python 的环境变量，假设你的 Python 安装在 C:\\Python37 下:\nset path=%path%;C:\\python37\n\n\n解释器的调用\n#!/usr/bin/python ：指定用什么解释器运行脚本以及解释器所在的位置，如果解释器没有装在/usr/bin/目录，改成其所在目录就行了，或者更通用的方法是：#!/usr/bin/env python。\n\n#!/usr/bin/python3\n\n保存在XXX.py 文件中并使用python命令执行该脚本文件\n\npython XXX.py","categories":["Python","基础"],"tags":["python","解释器"]},{"title":"python笔记（01）——安装","url":"https://lujw666.github.io/2021/03/07/python-01/","content":"Python是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。\n\n解释型语言：开发过程中没有了编译这个环节。类似于PHP和Perl语言。\n交互式语言：可以在一个Python提示符，直接互动执行写你的程序。\n面向对象语言: 支持面向对象的风格或代码封装在对象的编程技术。\n初学者的语言：对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。\n\n\n\npython安装linux &amp; unix1.适用于 Unix/Linux 的源码压缩包下载：https://www.python.org/downloads/source/2.解压及安装\ntar -zxvf Python-3.8.5.tgzcd Python-3.8.5./configuremake &amp;&amp; make install\n3.检查Python3是否正常可用\npython3 -V\n\n\nwinodws\n打开WEB浏览器访问https://www.python.org/downloads/windows/\n在下载列表中选择 Windows 平台安装包，包格式为：python-3.8.5-amd64.exe 文件 ， -3.8.5 为你要安装的版本号，-amd64为你系统的版本。\n下载后，双击下载包，进入 Python 安装向导，安装非常简单，你只需要使用默认的设置一直点击”下一步”直到安装完成即可。\n\n\n\nMacMAC系统一般都自带有 Python2.7 版本的环境，也可以在链接https://www.python.org/downloads/mac-osx/上下载最新版安装。\n","categories":["Python","基础"],"tags":["简介","安装","python"]},{"title":"SQL语法——SQL GROUP BY 语法","url":"https://lujw666.github.io/2021/03/07/sql-groupby/","content":"Aggregate 函数常常需要添加 GROUP BY 语句。\nGROUP BY语句通常与集合函数（COUNT，MAX，MIN，SUM，AVG）一起使用，以按一个或多个列对结果集进行分组。\nSQL GROUP BY 语法:\nSELECT column_name(s)FROM table_nameWHERE conditionGROUP BY column_name(s)ORDER BY column_name(s);\n\n\nSQL GROUP BY示例下面的 SQL 语句从 “Customers” 表中列出了每个国家/地区的客户数量：\nSELECT COUNT(CustomerID), CountryFROM CustomersGROUP BY Country;\n下面的 SQL 语句从 “Customers” 表中列出每个国家的客户数量，从高到低排序：\nSELECT COUNT(CustomerID), CountryFROM CustomersGROUP BY CountryORDER BY COUNT(CustomerID) DESC;\n\n\nGROUP BY使用JOIN示例下面的 SQL 语句从 “Orders” 和”Shippers”表中列出了每个发货人发送的订单数量：\nSELECT Shippers.ShipperName, COUNT(Orders.OrderID) AS NumberOfOrders FROM OrdersLEFT JOIN Shippers ON Orders.ShipperID = Shippers.ShipperIDGROUP BY ShipperName;","categories":["SQL","基础"],"tags":["sql"]},{"title":"SQL语法——SQL ORDER BY 语法","url":"https://lujw666.github.io/2021/03/07/sql-orderby/","content":"ORDER BY 关键字用于按升序或降序对结果集进行排序。\nORDER BY 关键字默认情况下按升序排序记录。\n如果需要按降序对记录进行排序，可以使用DESC关键字。\nSQL ORDER BY 语法:\nSELECT column1, column2, ...FROM table_nameORDER BY column1, column2, ... ASC|DESC;\n在ORDER BY子句中使用多个列，但要确保用于对该列进行排序的列应该在列表中。\n\n\nORDER BY 实例下面的 SQL 语句从 “Customers” 表中选取所有客户，并按照 “Country” 列排序：\nSELECT * FROM CustomersORDER BY Country;\n\n\nORDER BY DESC 实例下面的 SQL 语句从 “Customers” 表中选取所有客户，并按照 “Country” 列降序排序：\nSELECT * FROM CustomersORDER BY Country DESC;\n\n\nORDER BY 多列 实例1下面的 SQL 语句从 “Customers” 表中选取所有客户，并按照 “Country” 和 “CustomerName” 列排序：\nSELECT * FROM CustomersORDER BY Country, CustomerName;\n\n\nORDER BY 多列 实例2以下SQL语句从”Customers” 表中选择所有客户，按 “Country” 升序排列，并按 “CustomerName” 列降序排列：\nSELECT * FROM CustomersORDER BY Country ASC, CustomerName DESC;","categories":["SQL","基础"],"tags":["sql"]},{"title":"SQL语法——SQL WHERE 语法","url":"https://lujw666.github.io/2021/03/04/sql-where/","content":"WHERE 子句用于过滤记录，提取满足指定标准的记录。\nSQL WHERE 语法：\nSELECT column1, column2, ... FROM table_name WHERE condition;\n\n注意： WHERE子句不仅用于SELECT语法，还用于UPDATE，DELETE语法等！\n\nWHERE子句可以与以下类型的SQL语句一起使用：\n\nUPDATE\nDELETE\n\nUPDATE语句：\nUPDATE &quot;table_name&quot;SET &quot;column_1&quot; &#x3D; [new value]WHERE &quot;condition&quot;;\nDELETE语句：\nDELETE FROM &quot;table_name&quot;WHERE &quot;condition&quot;;\n\n\nSQL 运算符运算符是保留字或主要用于 SQL 语句的 WHERE 子句中的字符，用于执行操作，例如：比较和算术运算。 这些运算符用于指定 SQL 语句中的条件，并用作语句中多个条件的连词。\n常见运算符有以下几种：\n\n算术运算符\n比较运算符\n逻辑运算符\n否定条件运算符\n\n\n\nSQL 算术运算符\n假设变量 a 的值是：10，变量 b 的值是：20，以下为各运算符执行结果：\n\n\n\n运算符\n描述\n例子\n\n\n\n+\n加法，执行加法运算。\na + b 得到 30\n\n\n-\n减法，执行减法运算。\na - b 得到 -10\n\n\n*\n乘法，执行乘法运算。\na * b 得到 200\n\n\n/\n用左操作数除以右操作数。\nb / a 得到 2\n\n\n%\n用左操作数除以右操作数并返回余数。\nb % a 得到 0\n\n\n\n\nSQL 比较运算符假设变量 a 的值是：10，变量 b 的值是：20，以下为各运算符执行结果：\n\n\n\n运算符\n描述\n例子\n\n\n\n=\n检查两个操作数的值是否相等，如果是，则条件为真(true)。\n(a = b) is false.\n\n\n!=\n检查两个操作数的值是否相等，如果值不相等则条件为真(true)。\n(a != b) is true.\n\n\n&lt;&gt;\n检查两个操作数的值是否相等，如果值不相等则条件为真(true)。\n(a &lt;&gt; b) is true.\n\n\n&gt;\n检查左操作数的值是否大于右操作数的值，如果是，则条件为真(true)。\n(a &gt; b) is false.\n\n\n&lt;\n检查左操作数的值是否小于右操作数的值，如果是，则条件为真(true)。\n(a &lt; b) is true.\n\n\n&gt;=\n检查左操作数的值是否大于或等于右操作数的值，如果是，则条件为真(true)。\n(a &gt;= b) is false\n\n\n&lt;=\n检查左操作数的值是否小于或等于右操作数的值，如果是，则条件为真(true)。\n(a &lt;= b) is true.\n\n\n!&lt;\n检查左操作数的值是否不小于右操作数的值，如果是，则条件变为真(true)。\n(a !&lt; b) is false.\n\n\n!&gt;\n检查左操作数的值是否不大于右操作数的值，如果是，则条件变为真(true)。\n(a !&gt; b) is true.\n\n\n\n\nSQL 逻辑运算符：这是在 SQL 所有的逻辑运算符的列表。\n\n\n\n运算符\n描述\n\n\n\nALL\nALL运算符用于将值与另一个值集中的所有值进行比较。\n\n\nAND\nAND运算符允许在SQL语句的WHERE子句中指定多个条件。\n\n\nANY\nANY运算符用于根据条件将值与列表中的任何适用值进行比较。\n\n\nBETWEEN\nBETWEEN运算符用于搜索在给定最小值和最大值内的值。\n\n\nEXISTS\nEXISTS运算符用于搜索指定表中是否存在满足特定条件的行。\n\n\nIN\nIN运算符用于将值与已指定的文字值列表进行比较。\n\n\nLIKE\nLIKE运算符用于使用通配符运算符将值与类似值进行比较。\n\n\nNOT\nNOT运算符反转使用它的逻辑运算符的含义。 例如：NOT EXISTS, NOT BETWEEN, NOT IN等等，这是一个否定运算符。\n\n\nOR\nOR运算符用于组合SQL语句的WHERE子句中的多个条件。\n\n\nIS NULL\nIS NULL运算符用于将值与NULL值进行比较。\n\n\nUNIQUE\nUNIQUE运算符搜索指定表的每一行的唯一性(无重复项)。\n\n\n","categories":["SQL","基础"],"tags":["sql"]},{"title":"SQL语法——SQL SELECT 语法","url":"https://lujw666.github.io/2021/03/03/sql-select/","content":"SELECT 语法用于从数据库中选择数据。\n返回的数据存储在结果表中，称为结果集。\nSQL SELECT 语法：\nSELECT column1, column2FROM table_name;\n与\nSELECT * FROM table_name;\n\n\n\nSELECT  检索一列下面的 SQL 语句从 “Customers” 表中选取 “City” 列：\nSELECT City FROM Customers; \n查询结果：\nCountry GermanyMexico Mexico UKSweden\nSELECT  检索多列下面的 SQL 语句从 “Customers” 表中选取 “CustomerName” 和 “City” 列：\nSELECT CustomerName, City FROM Customers;\n 注意：这两个列名在查询中用逗号分隔。每当您选择多个列时，它们必须用逗号分隔，但最后一列名称之后不能添加逗号。\nSELECT  检索所有列下面的 SQL 语句从 “Customers” 表中选取所有列：\nSELECT * FROM Customers;","categories":["SQL","基础"],"tags":["sql"]},{"title":"SQL语法——SQL SELECT DISTINCT 语法","url":"https://lujw666.github.io/2021/03/03/sql-select-distinct/","content":"SELECT DISTINCT语法用于仅返回不同的值。\n在一张表内，一列通常包含许多重复的值; 有时只想列出不同的值。\nSQL SELECT DISTINCT语法：\nSELECT DISTINCT column1, column2, ... FROM table_name;\n\n\nSELECT DISTINCT 实例以下SQL语句仅从”Customers” 表中的 “Country” 列中选择DISTINCT值：\nSELECT DISTINCT Country FROM Customers;\n查询结果：\nCountryGermanyMexicoUKSweden\n","categories":["SQL","基础"],"tags":["sql"]},{"title":"SQL笔记（02）——SQL 语法","url":"https://lujw666.github.io/2021/03/03/sql-02/","content":"SQL 语法规则\nSQL语句总是以关键字开始\nSQL语句以分号结尾\nSQL不区分大小写\n\n\n\nSQL语句结构结构化查询语言包含6个部分：\n\n数据查询语言（DQL:Data Query Language）：用以从表中获得数据，确定数据怎样在应用程序给出。保留字SELECT是DQL（也是所有SQL）用得最多的动词，其他DQL常用的保留字有WHERE，ORDER BY，GROUP BY和HAVING。这些DQL保留字常与其他类型的SQL语句一起使用。\n\nSELECT 语句用于从数据库中选择数据。返回的数据存储在结果表中，称为结果集。\nSELECT DISTINCT 语句用于返回唯一不同的值。\nWHERE 子句用于提取那些满足指定条件的记录。\n算术运算符\n比较运算符\n逻辑运算符\nAND &amp; OR  运算符用于基于一个以上的条件对记录进行过滤。\nLIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。\nIN &amp;NOT IN操作符允许在 WHERE 子句中规定多个值。\nBETWEEN 操作符用于选取介于两个值之间的数据范围内的值。\nALL 用于将值与另一个值集中的所有值进行比较\nEXISTS 用于搜索指定表中是否存在满足特定条件的行\nIS NULL &amp; IS NOT NULL 用于将值与NULL值进行比较\nUNIQUE 搜索指定表的每一行的唯一性\nNOT 反转使用它的逻辑运算符的含义\n\n\n\n\nORDER BY 关键字用于对结果集进行排序。\nGROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。\nHAVING 子用于返回筛选分组后的各组数据。\n\n\n数据操作语言（DML：Data Manipulation Language）：其语句包括动词INSERT，UPDATE和DELETE。它们分别用于添加，修改和删除表中的行。也称为动作查询语言。\n\nINSERT INTO 语句用于向表中插入新记录。\nUPDATE 语句用于更新表中的记录。\nDELETE 语句用于删除表中的记录。\n\n\n事务处理语言（TPL）：它的语句能确保被DML语句影响的表的所有行及时得以更新。TPL语句包括BEGIN TRANSACTION，COMMIT和ROLLBACK。\n\nCOMMIT 提交更改\nROLLBACK 回滚更改\nSAVEPOINT 在事务内部创建一系列可以 ROLLBACK 的还原点\nRELEASE SAVEPOINT 命令用于删除先前创建的保存点\nSET TRANSACTION 命名事务\n\n\n数据控制语言（DCL）：它的语句通过GRANT或REVOKE获得许可，确定单个用户和用户组对数据库对象的访问。某些RDBMS可用GRANT或REVOKE控制对表单个列的访问。\n\nGRANT 授予权限\nREVOKE 撤销已授予的权限\n\n\n数据定义语言（DDL）：其语句包括动词CREATE和DROP。在数据库中创建新表或删除表（CREAT TABLE 或 DROP TABLE）；为表加入索引等。DDL包括许多与人数据库目录中获得数据有关的保留字。它也是动作查询的一部分。\n\nCREATE DATABASE 创建新数据库\nALTER DATABASE 修改数据库\nCREATE TABLE 创建新表\nALTER TABLE 变更（改变）数据库表\nDROP TABLE 删除表\nCREATE INDEX 创建索引（搜索键）\nDROP INDEX 删除索引\n\n\n指针控制语言（CCL）：它的语句，像DECLARE CURSOR，FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作。\n\n\n","categories":["SQL","基础"],"tags":["sql"]},{"title":"SQL笔记（01）——什么是 SQL","url":"https://lujw666.github.io/2021/03/01/sql-01/","content":"结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。\n结构化查询语言是高级的非过程化编程语言，允许用户在高层数据结构上工作。它不要求用户指定对数据的存放方法，也不需要用户了解具体的数据存放方式，所以具有完全不同底层结构的不同数据库系统, 可以使用相同的结构化查询语言作为数据输入与管理的接口。结构化查询语言语句可以嵌套，这使它具有极大的灵活性和强大的功能。\n\n\nRDBMSRDBMS 指关系型数据库管理系统，全称 Relational Database Management System。\nRDBMS 是 SQL 的基础，同样也是所有现代数据库系统的基础。SQL是关系数据库系统的标准语言。所有关系数据库管理系统(RDMS)，如MySQL、MS Access、Oracle、Sybase、Informix、Postgres和SQL Server都使用SQL作为它们的标准数据库语言。\nRDBMS 中的数据存储在被称为表的数据库对象中。\n\n表是相关的数据项的集合，它由列和行组成。\n每个表都被分解成称为字段的更小的实体。字段是表中的一列，用于维护表中每条记录的特定信息。\n记录（也称为行）是表中存在的每个单独条目。\n列是表中的垂直实体，其包含与表中的特定字段相关联的所有信息。\n\n","categories":["SQL","基础"],"tags":["简介","sql"]},{"title":"知乎一小时 015 土豆驯化记","url":"https://lujw666.github.io/2021/03/01/ZhihuOneHour015/","content":"土豆到底叫啥？土豆的中国学名叫马铃薯，它还有很多的别名。广东叫薯仔/荷兰豆，山东叫地蛋，陕北叫山叶，安徽叫地瓜/地豆，云南和四川叫洋芋，湖北叫洋芋，绍兴叫洋番薯，河北叫山药，内蒙叫山药蛋，湖南叫芋头，苏北叫地豆子……\n土豆在国外也有很多好玩的名称，比如地苹果、地梨等等。\n它的拉丁学名叫做 Solanum tuberosum L.，这是在国内最常见的栽培马铃薯种名，在南美其实还有其他的栽培土豆物种，比如 Solanum ajanhuiri, Solanum curtilobum 和 Solanum juzepczukii。\n植物学小提示：在每种语言里，对同一个生物可能有很多不同的叫法，为了能让所有生物都有一个通用的学名，最常用的命名系统叫做二名法，由瑞典植物学家林奈（Linnaeus）于 1753 年推广开来。简单来说，就是植物的属名加上种名，最后再加上命名者的名字。\n茄科植物土豆的属名是 Solanum, 中文是茄属，茄子和番茄也是茄科茄属，它们的拉丁名分别叫 Solanum melongena 和 Sola-num lycopersicum，而番茄是作物里和土豆亲缘关系最近的，这也是为什么科学家多年来一直想培育出地上长番茄、地下长土豆的「番茄土豆」。再往前推一点，茄科（Solanaceae）的物种可就更多了，比如烟草、辣椒、枸杞、酸浆，还有一些有毒的植物，比如颠茄、曼陀罗等等……\n也正是因为不少茄科植物都有毒，所以茄科还有一个很酷的名字叫做「Nightshades」, 翻译过来是「夜影」。\n\n\n土豆的起源和驯化土豆起源于南美的安第斯山脉(陆地上最长的山脉，约有 7000 公里长，平均高度为 4000 米。横穿 8 个南美国家，由北到南依次是委内瑞拉、哥伦比亚、厄瓜多尔、秘鲁、玻利维亚、智利及阿根廷。美洲的第一高峰阿空加瓜山也属于安第斯山脉，它在阿根廷境内，高达 6962 米，是亚洲以外最高的山峰)。\n根据分子生物学的证据，大概 1400 万年前，茄子和番茄土豆的祖先分化；之后在 700 万年前，番茄和土豆分化。而距今大约是在 1 万年前，南美安第斯山脉当地的农民开始驯化土豆作为食物。\n\n\n土豆传入欧洲土豆起源于南美安第斯山脉，当地的印加人称之为「papas」, 而当那些西班牙的探险家们将土豆带回本土的时候，也沿用了这个名字。但后来也许是因为 papa 和「爸爸」的发音很相似，西班牙人将土豆称为 patata。随后传播到了意大利，同样沿用了 patata 这个称呼。在英国，人们习惯称呼土豆为「白土豆」(white potato)，到了西欧，土豆又变成了「地苹果」或者「地梨」，比如法国、荷兰、芬兰甚至希腊都是这么称呼土豆的。后来，随着欧洲殖民活动的展开，土豆的各种外号也传到了不同的殖民地，比如印度的有些地方由于被葡萄牙殖民过，所以叫土豆 batata。而在中国，那些「洋」字头的名字也是因为土豆是西方舶来品。\n土豆刚刚传播到欧洲的时候，名声可并不好。人们通常都是本能地惧怕和排斥新事物，其他作物都是靠种子繁殖，而种土豆一般都是靠一小块种薯，大家觉得这种从地里挖出来的脏兮兮的东西是「魔鬼的食物」，所以那个时候，土豆主要是用来喂猪或者给监狱里的囚犯吃。\n在 17-18 世纪的欧洲，饥饿是个很普遍的现象。从 1500 到 1800 年间，有过 40 场全国范围内的饥荒；平均每十年就发生超过一场。简而言之，欧洲大陆依赖小麦的农业系统不能喂饱自己的人民。\n但土豆改变了这一切。每年农民都会休耕超过一半的谷物田地，一方面为了恢复土壤肥力，同时还要去除杂草。而有了土豆后，农民就可以在这段时间种上土豆。由于土豆产量极高，所以从卡路里的角度来看，它使欧洲的食物供给翻了一倍。\n在 18 世纪末，土豆在欧洲的大部分地方都成为了主食。在爱尔兰，有大概 40% 的人除了土豆吃不到任何固体食物，而在荷兰，比利时，普鲁士和波兰，大概有 10%-30% 的人同样只有土豆吃。在吃土豆的国家，频繁的饥荒从此消失。终于，欧洲这片土地上的人民能吃饱了。    \n\n\n土豆晚疫病土豆晚疫病，这种病害的罪魁祸首——Phytophthora in-festans, 中文学名是致病疫霉。这东西属于卵菌，它主要的宿主是番茄和土豆。致病疫霉是一种半活体寄生的病原菌，它会释放游动孢子，当孢子附着到植物上就会开始萌发，长出菌丝插入植物的细胞吸取养分，在生长的后期杀死植物细胞。它还能全方位的侵染植物，一般是从叶子开始，能看到明显的病斑，之后会快速传播到其他组织，所以即使得病的植株能长出土豆，很可能也是被晚疫病菌侵染过的。 \n土豆的种植方式主要是依靠薯块本身进行无性繁殖，这是因为土豆的基因组高度杂合，且有着自交不亲和或者自交衰退的现象，而通过杂交生产出来的种子，后代的所有性状都会疯狂地分离，导致一块田里的土豆可能长得形状各异。正因为依靠薯块进行的无性繁殖，导致了欧洲的土豆没有任何遗传多样性；好处是人们喜欢的性状都将得以保留，比如大薯块、低茄碱等等。但同时，这也导致了如果它们对某种病原菌缺乏抗性，如果这种病原菌有足够的传播能力，那么所有的土豆都将毁于一旦。\n1845 年 9 月，爱尔兰农民发现土豆遭受了一种以前没见过的病害，这就是晚疫病。在 1845 年晚疫病刚刚传播到爱尔兰的时候，它摧毁了当年 40% 左右的土豆。\n由于当时对于晚疫病缺乏了解，那些被感染的烂土豆都被留在了田里，这就导致了晚疫病菌可以继续存活。到了 1846 年，这些潜伏的晚疫病菌一下子摧毁了 90% 的土豆。而在那个时代，人们对于植物的病害根本束手无策。\n1845 到 1852，由于土豆晚疫病造成的大饥荒，导致超过一百万人饿死，又有超过两百万爱尔兰人移民到其他国家，其中大部分都去了美国。因此爱尔兰的人口几乎下降了一半，至今还没有恢复到大饥荒前的数量。晚疫病可能是爱尔兰人民心中永远的痛，在当地有这么一句爱尔兰谚语：\n\n这个世界上只有两件事绝对不能开玩笑：婚姻和土豆。\n\n\n\n晚疫病后的欧洲土豆晚疫病促进了化学农药的发展。当时土豆瘟疫后，人们想方设法去寻找晚疫病的解决方案。最终有一个人偶然发现用剩下的绿色颜料竟然能杀死晚疫病菌——这种绿色颜料是由砒霜和铜等成分组成——所以开始将这种绿色颜料稀释，然后喷洒到得病的土豆田里。\n对于农民来说，巴黎绿就像是上天的礼物，而化学家们也从中得到启发——如果砒霜能杀死土豆甲虫，那为什么不试试是否能杀死其他害虫呢？如果巴黎绿能杀死晚疫病菌，那其他化学试剂是否能解决别的农业问题？就这样，现代农药产业慢慢开始发展了。\n同时，植物育种家也在努力。他们开始尝试培育出具有晚疫病抗性的土豆，最开始的策略是将野生土豆里的抗性转入栽培土豆。\n这场瘟疫并不能浇灭欧洲人民对土豆的热情，很多文艺作品也在这之后被创作出来，不仅有法国画家米勒于 1861 年创作的「种土豆的」，更有梵高 1885 年创作的「吃土豆的人」。\n同时，土豆也随着欧洲的殖民而流传到全球，比如印度、中国、新西兰、非洲等地。\n土豆到中国中国现在的土豆种植面积和土豆消费量是世界第一，但产量并不高，大概只有荷兰产量的三分之一。2015 年，农业部宣布，将要启动土豆主粮化战略。\n在南方，早在 1603 年，荷兰人就在中国台湾的澎湖岛上种上了土豆，后来在 1623 年到 1662 年，荷兰占领台湾期间，也在台湾岛上开始栽种土豆。之后荷兰人开始和中国东南沿海的省份进行贸易，就在这个时候将土豆引入到东南沿海一带。那里的很多地方，至今还将土豆称为「荷兰薯」。\n和土豆开始在欧洲的冷遇不同，在中国，土豆一上来就是高级货。明朝的时候，土豆被传到北京，作为皇家特供食品，由专门的皇家菜户供应。在清朝取消了明朝的蔬菜供应系统，土豆这才传入民间，登上了百姓的餐桌。\n而西部的土豆可能先是通过印度、缅甸等地传入云南，后来又传到四川、贵州。在当地，现在还有很多人称土豆为洋芋。\n还有一些可能的传入途径，比如是通过俄国传教士，在十七世纪早期由西伯利亚传入山西、陕西，之后又传到东北一代。\n\n\n土豆的育种植物育种可以说是科学和艺术的结合，所以植物育种家不仅仅要有丰富的植物学、遗传学、统计的背景，有时候还需要玩一些花招。为了让作物更好地满足人们的需求，就要靠植物育种家们通过各种手段去改善植物的各种性状。在育种上，有一些性状普遍很重要，比如高产量、抗虫抗病、低龙葵碱、耐旱、耐储藏等等。还有一些性状就完全是为了满足不同的需求或者不同地方人的喜好了。\n按照功能来分类，可以简单地将土豆分为餐用、加工用（薯条、薯片等等）、饲料用和工业用途，每种都要满足不同的标准。工业用途要特殊的支链淀粉，从而更好地应用于造纸业和黏合剂等；加工用的，就需要耐低温储藏，外形适合机器加工，炸出来的薯条、薯片得颜色漂亮；餐用土豆还要考虑不同的加工方法，比如烘烤、油炸、水煮、沙拉用等等。每种用途的土豆都需要特定的性状。\n传统育种通过杂交，从后代中选择出最满意的那个，再通过反复的回交，留下需要的性状，同时去除那些不利的。\n概念：基因池 (gene pool）比如一个人有两万个基因，但是每个基因都可能有不同的等位基因（allels），把几十亿人所有可能的所有等位基因都堆到一起，就是人类的基因池了。\n土豆育种的过程可能非常漫长，短则十几年，慢则几十年。不过借助现代分子生物学工具，可以很大地提高传统育种的速度。\n分子标记辅助育种知道土豆的基因组已经测序，一共有 12 条染色体，图中蓝色的方块就代表这些分子标记，红色代表我们需要的晚疫病抗性基因，灰色方块代表和抗性基因离得很近的「不好的」基因。我们的育种目标是只保留抗病基因，避免高毒素或者容易变黑等不好的性状。现在有了分子标记，我们不需要再像传统育种项目那样进行大规模的表型测试，只需要提取杂交后代的 DNA，然后利用已有的分子标记对这些材料进行基因型筛选就好。\n\n还是以我们的晚疫病抗性育种项目为例，我们需要保留红色的「晚疫病抗性基因」，但同时要去掉茄碱和褐化基因。我们要做的就是寻找带有标记 1 和标记 2，同时不带有标记 3 和标记 4 的个体。当然，受限于群体数量，我们还是要反复进行几轮回交，从而筛选掉大部分野生型的基因组。\n\n有了分子标记这个工具，可以大大加速植物育种，同时让育种项目的目标和结果都变得更加容易掌控。\n分子标记育种的不足\n分子标记从哪儿来？如果需要进行分子标记育种，我们首先要获得分子标记的连锁图谱，这个任务的工作量巨大，需要大量的时间和经费去开发这些分子标记。\n如果我们想要的性状来自不可杂交的材料里怎么办？\n如果我们需要的性状来自动物、细菌，甚至病毒呢？这时候分子标记育种就完全无计可施了。\n\n\n\n土豆基因组的测序随着近几年基因组测序技术的发展，很多植物的基因组都已经完成测序，这对于植物育种有着非常大的帮助。土豆的基因组于 2011 年发表于《 Nature 》杂志。\n2005 年，荷兰的瓦赫尼根大学（Wageningen University and Research Cen-ter）组织了国际上很多高校和科研院所，一起组成了「土豆基因组测序国际协作组」（The Potato Genome Sequencing Consortium ，PGSC），共同发起土豆基因组的测序工作。\n当时，现任中国农科院蔬菜花卉研究所的生物技术室主任黄三文刚刚在瓦赫尼根大学的植物育种组拿到博士学位，他联系了当时农科院副院长屈冬玉（现任农业部副部长，也是瓦大育种组毕业的博士），决定参与这个测序项目。中国农科院负责土豆十二条染色体中两条的测序工作，黄三文作为首席科学家。\n当时二代测序技术正好刚刚兴起，于是黄三文先是和华大基因合作将黄瓜的基因组完成，而那时土豆基因组仍然没有克服瓶颈。于是在积累了二代测序的经验以及各种软件开发后，在 2008 年通过二代测序直接将纯合的双单倍体土豆进行测序。\n\n\n中国的「土豆主粮化」战略2015 年 1 月，农业部宣布中国将启动马铃薯主粮化战略：据农业部消息，我国将启动马铃薯主粮化战略，推进把马铃薯加工成馒头、面条、米粉等主食，马铃薯将成稻米、小麦、玉米外又一主粮。预计 2020 年 50% 以上的马铃薯将作为主粮消费。\n2016 年 1 月，农业部正式发布了文件「关于推进马铃薯产业开发的指导意见」，将马铃薯作为主粮产品进行产业化开发。\n\n\n番茄土豆和火星土豆番茄土豆在驯化土豆的道路上，人们还在发挥着想象力去探索更多的可能性。\n比如土豆只能收获地下的块茎，而地上部分毫无用处；番茄则正好相反。如果能把这俩结合到一起，岂不是能最大化地利用空间？科学家也一直在进行努力和尝试，比如通过传统的杂交手段，由于番茄和土豆都属于茄科茄属，亲缘关系很近，所以如果人工将其杂交，是可以产生种子的，但因为土豆基因组高度杂合，所以后代会出现大量分离，但并没有植株能做到上半部分长番茄而地下部分长土豆。\n还有科学家尝试过体细胞杂交技术，把番茄和土豆的细胞融合到一起。虽然这些融合细胞可以再生出新的植物，但结果同样让人失望。\n最后成功的案例是靠着一个传统的技术——「嫁接」。其售价高达每株 9.99 英镑，从价格来看，目前还是太高，并不适合大规模商业化生产。\n火星土豆看过电影《火星救援》的朋友一定都对在火星种土豆那段故事印象深刻。这并不是什么想象出来的桥段，事实上，在太空种植蔬菜已经开始进入应用阶段了，至少是在空间站上。\n比起其他作物，土豆的最大好处是其既能充当主食提供大量碳水化合物，同时又能起到蔬菜的作用，提供其他所需营养物质。目前 NASA 已经在和国际马铃薯中心（CIP）合作开始在研发火星土豆。\n\n\n后记一万年前的南美安第斯山脉；大航海时代的西班牙探险家；靠着土豆终于能够吃饱的欧洲人民；爱尔兰的土豆瘟疫；伟大的土豆育种家；新一代的植物育种技术以及未来的火星土豆。\n土豆就这样一步步从不起眼的埋在地下脏兮兮的块茎，被人类驯服从而成为世界上第四大粮食作物。\n如今，中国也要进入土豆主粮化时代，希望本文能让更多人了解土豆的故事。\n","categories":["科普","知乎一小时"],"tags":["土豆"]},{"title":"GitHub 命令行 hub","url":"https://lujw666.github.io/2021/02/27/hub/","content":"Hub 是对 git 的一层封装，以便和 GitHub 完美结合，而且对 git 完全兼容，推荐直接将 hub 设置为 git 的别名，所以在执行 git 的时候实际上是在执行 hub。\n\n\nHub安装# 在Debian/Ubuntu中安装apt-get install hub# 在Centos/RedHat中安装yum install hub# 在Mac下的安装brew install hub\n\n\nHub功能\n\n\n命令\n参数\n填写内容\n功能\n等同\n\n\n\nhub clone\n\n仓库名or其他用户名/仓库名\n获取Github远程仓库\ngit clone &#x67;&#105;&#116;&#64;&#103;&#x69;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;/用户名/仓库名.git\n\n\nhub remote add\n\n用户名\n添加Github远程仓库\ngit remote add 标识符 git://github.com/用户名/当前操作仓库的名称.git\n\n\nhub fork\n\n仓库名\nfork仓库\n=（在GitHub上对仓库做Fork处理）git remote add -f 用户名 &#103;&#105;&#x74;&#x40;&#103;&#x69;&#116;&#104;&#117;&#98;&#x2e;&#99;&#111;&#109;:仓库名.git\n\n\nhub pull-request\n-i Issue编号 -b 用户名:接收分支 -h 用户名:发送分支\n\nGithub的pull-request推送\n\n\n\nhub checkout\n\nURL\n在本地检查pull-request分支的运行状况\n\n\n\nhub create\n\n仓库名\n在Github上创建库\n\n\n\nhub push\n\n标识符 分支\n推送至Github远程仓库\n\n\n\nhub browse\n\n\n打开当前操作的仓库在 GitHub 上对应的仓库页面\n\n\n\nhub compare\n\n\n打开 GitHub 上对应的查看差别的页面\n\n\n\n","categories":["Git","扩展"],"tags":["git","github"]},{"title":"GitHub Pages 部署静态网页","url":"https://lujw666.github.io/2021/02/27/githubpages/","content":"Github Page 是 Github 提供的一种免费的静态网页托管服务，可以用来托管博客、项目官网等静态网页。支持 Jekyll、Hugo、Hexo 编译静态资源。\n点击查看如何将 Hexo 博客部署到 GitHub Pages 上\n","categories":["Git","扩展"],"tags":["git","github"]},{"title":"Git Flow 工作流程","url":"https://lujw666.github.io/2021/02/27/gitflow/","content":"Git Flow安装及初始化# 在Debian/Ubuntu中安装apt-get install gitflow# 在Centos/RedHat中安装yum install gitflow# 在Mac下的安装brew install git-flow# 初始化仓库git flow init\n\n\nGit Flow工作流程\n\n\n\n分支\n说明\n\n\n\nmaster\n时常保持着软件可以正常运行的状态。由于要维持这一 状态，所以不允许开发者直接对 master 分支的代码进行修改和提交。其他分支的开发工作进展到可以发布的程度后，将会与 master分支进行合并，而且这一合并只在发布成品时进行。发布时会附加包含版本编号的Git标签（Tag）。\n\n\ndevelop\n开发过程中的代码中心分支。与master分支一样，这个分支也不允许开发者直接进行修改和提交。程序员要以develop分支为起点新建feature分支，在feature分支中进行新功能的开发或者代码的修正。也就是说，develop分支维持着开发过程中的最新源代码，以便程序员创建feature分支进行自己的工作。\n\n\nfeature\n以develop分支为起点，是开发者直接更改代码发送提交的分支。与develop分支合并后，已经完成工作的feature分支就失去了作用，可以在适当的时候删除。\n\n\nrelease\n基于最新develop分支创建，当新功能足够发布一个新版本，从develop分支创建一个release分支作为新版本的起点，用于测试，所有的测试bug在这个分支改。测试完成后合并到master并打上版本号，同时也合并到develop，更新最新开发分支。\n\n\nhotfix\n并不是预期中计划出现的分支。它是一个紧急应对措施，只有当前发布的版本中出现BUG或漏洞，而且其严重程度要求开发方必须立刻处理，无法等到下一个版本发布时，hotfix分支才会 被创建。 因此，hotfix 分支都是以发布版本的标签或master分支为起点。借助hotfix分支，可以在不影响develop分支正常开发的情况下，由其他开发者处理成品的修正工作。\n\n\n\n\nMaster/Devlop分支所有在Master分支上的Commit应该打上Tag，一般情况下Master不存在Commit，Devlop分支基于Master分支创建。\n\n\n\nFeature分支Feature分支做完后，必须合并回Develop分支, 合并完分支后一般会删点这个Feature分支，毕竟保留下来意义也不大。\n\ngit checkout developgit pull origin developgit flow feature start xxx# 在feature/xxx分支中实现目标功能并进行提交git commit -am &quot;&quot;git flow feature finish xxxgit push origin develop\n\n\nRelease分支Release分支基于Develop分支创建，打完Release分支之后，我们可以在这个Release分支上测试，修改Bug等。同时，其它开发人员可以基于Develop分支新建Feature (记住：一旦打了Release分支之后不要从Develop分支上合并新的改动到Release分支)发布Release分支时，合并Release到Master和Develop， 同时在Master分支上打个Tag记住Release版本号，然后可以删除Release分支了。\n\ngit checkout developgit pull origin developgit flow release start &#x27;1.0.0&#x27;# 在release /1.0.0分支中实现目标功能并进行提交git commit -am &quot;&quot;git flow release finish &#x27;1.0.0&#x27;git checkout developgit push origin developgit push origin mastergit push --tags\n\n\nHotfix分支hotfix分支基于Master分支创建，开发完后需要合并回Master和Develop分支，同时在Master上打一个tag。\n\ngit checkout mastergit pull origin mastergit flow hotfix start &#x27;1.0.1&#x27; &#x27;1.0.0&#x27;# 在hotfix /1.0.1分支中实现目标功能并进行提交git commit -am &quot;&quot;git flow hotfix finish 1.0.1git checkout developgit push origin developgit push origin mastergit push --tags","categories":["Git","扩展"],"tags":["git","gitflow"]},{"title":"Git笔记（07）——忽略文件","url":"https://lujw666.github.io/2021/02/27/git-07/","content":"项目中经常会生成一些Git系统不需要追踪(track)的文件。典型的是在编译生成过程中产生的文件或是编程器生成的临时备份文件。\n当然，你不追踪(track)这些文件，可以不用”git add”去把它们加到索引中。 但是这样会很快变成一件烦人的事，会发现项目中到处有未追踪(untracked)的文件。\n可以在你的顶层工作目录中添加一个叫”.gitignore”的文件，来告诉Git系统要忽略掉哪些文件，下面是文件内容的示例:\n# 以&#39;#&#39; 开始的行，被视为注释.# 忽略掉所有文件名是 foo.txt 的文件.foo.txt# 忽略所有生成的 html 文件,*.html# foo.html是手工维护的，所以例外.!foo.html#  忽略所有.o 和 .a文件.*.[oa]\n可以把 .gitignore 文件放到工作树 (working tree) 里的其它目录中，这就会在它和它的子目录起忽略 (ignore) 指定文件的作用。.gitignore 文件同样可以像其它文件一样加到项目仓库里( 直接用 git add .gitignore 和 git commit 等命令), 这样项目里的其它开发者也能共享同一套忽略文件规则。\n如果想忽略规则只对特定的仓库起作用,可以把这些忽略规则写到仓库下 .git/info/exclude文件中，或是写在Git配置变量core.excludesfile中指定的文件里。\n","categories":["Git","进阶"],"tags":["git"]},{"title":"Git笔记（06）——目录","url":"https://lujw666.github.io/2021/02/27/git-06/","content":"Git 目录是为你的项目存储所有历史和元信息的目录 - 包括所有的对象(commits,trees,blobs,tags), 这些对象指向不同的分支。\n.git|-- HEAD         # 这个git项目当前处在哪个分支里|-- config       # 项目的配置信息，git config命令会改动它|-- description  # 项目的描述信息|-- hooks/       # 系统默认钩子脚本目录|-- index        # 索引文件|-- logs/        # 各个refs的历史信息|-- objects/     # Git本地仓库的所有对象 (commits, trees, blobs, tags)|-- refs/        # 标识你项目里的每个分支指向了哪个提交(commit)。","categories":["Git","进阶"],"tags":["git"]},{"title":"Git笔记（05）——基本操作","url":"https://lujw666.github.io/2021/02/27/git-05/","content":"链接：https://lujw666.gitbook.io/learn/git/00-basic/05-ji-ben-cao-zuo\nGit 常用的是以下 6 个命令：git clone、git push、git add 、git commit、git checkout、git pull。\n\n说明：\n\nworkspace：工作区\nstaging area：暂存区/缓存区\nlocal repository：或本地仓库\nremote repository：远程仓库\n\n\n\n创建仓库\n\n\n命令\n说明\n\n\n\ngit init\n初始化仓库\n\n\ngit clone\n拷贝一份远程仓库，也就是下载一个项目\n\n\n\n\n提交与修改\n\n\n命令\n说明\n\n\n\ngit add\n添加文件到仓库\n\n\ngit status\n查看仓库当前的状态，显示有变更的文件\n\n\ngit diff\n比较文件的不同，即暂存区和工作区的差异\n\n\ngit commit\n提交暂存区到本地仓库\n\n\ngit reset\n回退版本\n\n\ngit rm\n删除工作区文件\n\n\ngit mv\n移动或重命名工作区文件\n\n\n\n\n分支管理\n\n\n命令\n说明\n\n\n\ngit branch\n显示或创建分支命令\n\n\ngit checkout\n切换分支命令\n\n\ngit merge\n合并分支命令\n\n\n\n\n远程操作\n\n\n命令\n说明\n\n\n\ngit remote\n远程仓库操作\n\n\ngit fetch\n从远程获取代码库\n\n\ngit pull\n下载远程代码并合并\n\n\ngit push\n上传远程代码并合并\n\n\n\n\n标签\n\n\n命令\n说明\n\n\n\ngit tag\n给提交打上标签\n\n\n\n\n提交日志\n\n\n命令\n说明\n\n\n\ngit log\n查看历史提交记录\n\n\ngit blame\n以列表形式查看指定文件的历史修改记录\n\n\n","categories":["Git","基础"],"tags":["git"]},{"title":"Git笔记（04）——工作流程","url":"https://lujw666.github.io/2021/02/27/git-04/","content":"\n克隆 Git 资源作为工作目录。\n在克隆的资源上添加或修改文件。\n如果其他人修改了，你可以更新资源。\n在提交前查看修改。\n提交修改。\n在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。\n\n\n\n\n基本概念\n工作区：能看到的目录\n版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。\n暂存区：一般存放在 .git 目录下的 index 文件（.git/index）中，所以把暂存区有时也叫作索引（index）。\n\n\n\n图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage/index），标记为 “master” 的是 master 分支所代表的目录树。\n图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。\n图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。\n当对工作区修改（或新增）的文件执行 git add 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。\n当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。\n当执行 git reset HEAD 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。\n当执行 git rm –cached [file] 命令时，会直接从暂存区删除文件，工作区则不做出改变。\n当执行 git checkout . 或者 git checkout – [file] 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。\n当执行 git checkout HEAD . 或者 git checkout HEAD [file] 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。\n\n","categories":["Git","基础"],"tags":["git"]},{"title":"Git笔记（03）——配置","url":"https://lujw666.github.io/2021/02/27/git-03/","content":"Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。\n这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量存放在以下三个不同的地方：\n\n/etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 –system 选项，读写的就是这个文件。\n~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 –global 选项，读写的就是这个文件。\n当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。\n\n在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\\Documents and Settings$USER。\n此外，Git 还会尝试找寻 /etc/gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。\n\n\n用户信息配置个人的用户名称和电子邮件地址：\ngit config --global user.name &quot;用户名&quot;git config --global user.email &quot;邮箱&quot;\n如果用了 –global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。\n如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。\n\n\n查看配置信息要检查已有的配置信息，可以使用 git config –list 命令。\n有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 /etc/gitconfig 和 ~/.gitconfig），不过最终 Git 实际采用的是最后一个。\n配置也可以在 ~/.gitconfig 或 /etc/gitconfig 看到，也可以直接查阅某个环境变量的设定，只要把特定的名字跟在 git config 后面即可。\n","categories":["Git","基础"],"tags":["git"]},{"title":"Git笔记（02）——安装","url":"https://lujw666.github.io/2021/02/27/git-02/","content":"Linux 平台上安装Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。\n\n\nDebian/UbuntuDebian/Ubuntu Git 安装命令为：\napt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-devapt-get install git\n\n\nCentos/RedHat如果你使用的系统是 Centos/RedHat 安装命令为：\nyum install curl-devel expat-devel gettext-devel openssl-devel zlib-develyum -y install git-core\n\n\nWindows 平台上安装安装包下载地址：https://gitforwindows.org/\n官网慢，可以用国内的镜像：https://npm.taobao.org/mirrors/git-for-windows/\n完成安装之后，就可以使用命令行的 git 工具（自带 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。在开始菜单里找到”Git”-&gt;”Git Bash”，会弹出 Git 命令窗口，你可以在该窗口进行 Git 操作。\n\n\nMac 平台上安装在 Mac 平台上安装 Git 最容易的当属使用图形化的 Git 安装工具，下载地址为：http://sourceforge.net/projects/git-osx-installer/\n","categories":["Git","基础"],"tags":["git","安装"]},{"title":"Git笔记（01）——简介","url":"https://lujw666.github.io/2021/02/27/git-01/","content":"Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。\n\n\nGit 与 SVN 区别Git 不仅仅是个版本控制系统，它也是个内容管理系统(CMS)，工作管理系统等。\nGit 与 SVN 区别点：\n\nGit 是分布式的，SVN 不是：这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。\nGit 把内容按元数据方式存储，而 SVN 是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。\nGit 分支和 SVN 的分支不同：分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。\nGit 没有一个全局的版本号，而 SVN 有：目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。\nGit 的内容完整性要优于 SVN：Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。\n\n\n\n\nGit 快速入门Git 简明指南: https://www.runoob.com/manual/git-guide/\nGit 完整命令手册地址：http://git-scm.com/docs\nGit Community book 中文版：http://gitbook.liuhui998.com/\nPDF 版命令手册：github-git-cheat-sheet.pdf\n","categories":["Git","基础"],"tags":["简介","git"]},{"title":"空间代谢组分析（3）——质谱数据处理","url":"https://lujw666.github.io/2021/02/25/spatialmeta-03/","content":"raw to mzml（弃用）使用ProteoWizard的msconvert软件可将质谱数据（.raw、.wiff格式数据）转格式为mzML格式。\nProteoWizard官网:http://proteowizard.sourceforge.net/\nMSConvertWindows操作msconvert提供了 Windows 平台和 Linux 平台。\n在 Windows 上使用也比较简单：\n\n入文件位置和输出文件位置；\n选择输出格式和编码精度；\n添加（add）所需要的功能 （Peak Picking）。\n点击右下角的开始（Start）\n\n\n\n\nLinux操作msconvert在linux系统安装较为复杂，可直接调用docker image进行使用。\ndocker hub:https://hub.docker.com/r/chambm/pwiz-skyline-i-agree-to-the-vendor-licenses\n也可使用https://hub.docker.com/r/lujiawei/msconvert，image相同仅修改tag名。\n对于msconvert命令行查看帮助：\ndocker run -it --rm \\chambm/pwiz-skyline-i-agree-to-the-vendor-licenses \\wine msconvert --help\n对于msconvert命令行使用：\ndocker run -it --rm \\-e WINEDEBUG=-all \\-v /your/data:/data \\chambm/pwiz-skyline-i-agree-to-the-vendor-licenses \\wine msconvert /data/file.raw\n\n\nmzML to imzML（弃用）imzMLConverter 允许将mzML质谱中间数据转化为imzML质谱成像数据，还允许将多个imzML文件组合成一个单一的imzML文件进行比较和数据处理。\nimzMLConverter官网:https://www.cs.bham.ac.uk/~ibs/imzMLConverter/\n\n\n\nraw to imzMLjimzMLConverterjimzMLConverter软件可以直接将质谱数据转化为imzML格式。\njimzMLConverter:https://github.com/AlanRace/imzMLConverter\njimzMLConverter Dockerfile:https://github.com/AlanRace/imzmlconverter-docker\njimzMLConverter docker image:https://hub.docker.com/r/alanrace/imzmlconverter\ndocker run -it --rm -v /path/to/mydata:/mydata \\alanrace/imzmlconverter:latest \\jimzMLConverter imzML /mydata/data.RAW\n\njimzMLConverter优势：\n\n可直接对质谱数据（.raw、.wiff）处理。\n能通过脚本直接调用。\n\n\n\njimzMLConverter问题：\n\n脚本调用要循环调用，一次调用仅能对一个数据进行处理，多文件处理是会以第一个文件覆盖处理不能合并。\n不能将多个imzML合并为一个imzML，但后续流程可实现此操作。\n\n\n\n\n格式转化R脚本-RawToImzML.R（弃用）R语言调用alanrace/imzmlconverter镜像使用jimzMLConverter脚本：\n#!/opt/conda/bin/Rscript  # 弃用，效率低# 文件名RawToImzML.R# 保存路径:/public/LM-database/script/SpatialMetaboAnalysis# 调用:/public/LM-database/script/SpatialMetaboAnalysis/RawToImzML.R# jimzMLConvert函数RawToImzML &lt;- function(filepath,                       format = &quot;raw&quot;,                       intern= FALSE,                       ignore.stdout = FALSE,                       ignore.stderr = FALSE,                       wait = TRUE)&#123;    # 获取路径下format格式文件信息  dirname &lt;- list.files(path = filepath,                        pattern = paste0(format,&quot;$&quot;),                        full.names = F,                        recursive = T)    # 循环调用docker image:alanrace/imzmlconverter  for ( i in 1:length(dirname)) &#123;        system(paste0(&quot;docker run -i --rm &quot;,                  &quot;-v &quot;,filepath,&quot;:/mydata &quot;,                  &quot;alanrace/imzmlconverter:latest &quot;,                  &quot;jimzMLConverter imzML &quot;,                  &quot;/mydata/&quot;,dirname[i]),           intern = intern,           ignore.stdout = ignore.stdout,           ignore.stderr = ignore.stderr,           wait =wait)    # 为保证循环正常运行，每一次循环暂停docker调用5s    Sys.sleep(5)  &#125;  &#125;# 获取当前路径filepath &lt;- getwd()# 对当前路径下format格式文件转化为imzMLRawToImzML(filepath = filepath)\n\n\n格式转化sh脚本-RawToImzML.shalanrace/imzmlconverter镜像调用jimzMLConverter:\n#!/bin/bash# 文件名RawToImzML.sh# 保存路径:/public/LM-database/script/SpatialMetaboAnalysis# docker调用:docker run -it --rm -v /path:/mydata -v /public/LM-database/script/SpatialMetaboAnalysis:/script alanrace/imzmlconverter:latest /script/RawToImzML.sh# 寻找目录下.raw格式文件name=$(find /mydata -type f -name &quot;*.raw&quot;)# 由于jimzMLConverter不能批量转换，所以循环对raw文件进行imzml格式转换for i in $namedo   jimzMLConverter imzML $idone\n\n\n调用RawToImzML.R（弃用）shell中调用RawToImzML.R：\n# 弃用，效率低# 目录定位于处理目录cd /to/pathRscript /public/LM-database/script/SpatialMetaboAnalysis/RawToImzML.R\nR中调用RawToImzML.R：\n#!/opt/conda/bin/Rscript# 弃用，效率低# 文件名CallRawToImzML.R# 保存路径:/public/LM-database/script/SpatialMetaboAnalysis# 调用:/public/LM-database/script/SpatialMetaboAnalysis/CallRawToImzML.Rsetwd(&quot;raw&quot;)# 调用RawToImzML.Rsystem(&quot;/opt/conda/bin/Rscript /public/LM-database/script/SpatialMetaboAnalysis/RawToImzML.R&quot;,       ignore.stdout = F,       ignore.stderr = F,       wait = T)setwd(&quot;../&quot;)\n\n\n调用RawToImzML.shshell中调用RawToImzML.sh：\n#!/bin/bash# 文件名CallRawToImzML.sh# 保存路径:/public/LM-database/script/SpatialMetaboAnalysis# 调用:/public/LM-database/script/SpatialMetaboAnalysis/CallRawToImzML.sh# 工作目录移动到raw目录cd raw# 获取当前工作目录路径path=$(pwd)# 使用alanrace/imzmlconverter调用RawToImzML.sh脚本docker run -i --rm \\-v $path:/mydata \\-v /public/LM-database/script/SpatialMetaboAnalysis:/script \\alanrace/imzmlconverter:latest \\/script/RawToImzML.sh\n","categories":["代谢","扩展"],"tags":["空间代谢组"]},{"title":"空间代谢组分析（2）——分析流程","url":"https://lujw666.github.io/2021/02/25/spatialmeta-02/","content":"分析流程说明\n质谱数据处理，将raw格式转化为imzML格式\n\nimzML预处理\n\n\n多imzML文件合并\n参照样本选择(默认导入第一个imzML数据为参照样本，可选择)\n参照样本y轴(保留时间)对齐处理(处理方式)\n参照样本背景扣除\n参照样本峰对齐，导出mz数据\n其余样本y轴(保留时间)对齐处理\n其余样本背景扣除\n以mz数据对其余样本峰对齐\n\n\n\n样本分割\n\n\n玻片排样规则表格填写\n根据排样规则对imzML数据切割\n初始样本imzML数据,并绘制成像图\n根据成像图判断是否背景扣除准确，是否样本分给准确\n根据成像图修整将样本imzML人工修整\n样本数据聚类分析\n将聚类分析可视化结果给客户作为选区参考\n\n\n\n样本选区\n\n\n人工或聚类选区\n导出选区质谱成像图、选区信息数据、mean和all定量数据\n将选区、分组、比较组信息整理\n\n\n\n搜库定性(根据mz数据定性)\n\n比较分析\n\n\n\n\n\n分析脚本流程# 创建项目文件夹mkdir filenamecd filename# 将空间质谱数据放入raw文件夹中# raw文件格式，根据正负离子创建文件夹，后将根据玻片或样本创建文件夹.filename|── raw|\t|── neg|\t|\t|── sample1|\t|\t|\t|-- sample1-001.raw|\t|\t|\t|-- sample1-002.raw|\t|\t|\t|-- ···|\t|\t|── sample2|\t|\t|\t|-- sample2-001.raw|\t|\t|\t|-- sample2-002.raw|\t|\t|\t|-- ···|\t|\t|-- ···|\t|── pos|\t|\t|\t|-- sample1-001.raw|\t|\t|\t|-- sample1-002.raw|\t|\t|\t|-- ···|\t|\t|── sample2|\t|\t|\t|-- sample2-001.raw|\t|\t|\t|-- sample2-002.raw|\t|\t|\t|-- ···|\t|\t|-- ···# 将raw格式转化为imzML格式/public/LM-database/script/SpatialMetaboAnalysis/CallRawToImzML.sh# 多imzML文件合并/public/LM-database/script/SpatialMetaboAnalysis/MulImzMLToOne.sh# 上述脚本生成imzml目录后生成相应文件.filename|── imzml|\t|── neg|\t|\t|── sample1|\t|\t|\t|-- silde.imzML|\t|\t|── sample2|\t|\t|\t|-- silde.imzML|\t|\t|-- ···|\t|── pos|\t|\t|── sample1|\t|\t|\t|-- silde.imzML|\t|\t|── sample2|\t|\t|\t|-- silde.imzML|\t|\t|-- ···\n","categories":["代谢","扩展"],"tags":["空间代谢组"]},{"title":"空间代谢组分析（1）——分析环境","url":"https://lujw666.github.io/2021/02/25/spatialmeta-01/","content":"本分析会调用多套docker镜像。\n质谱数据处理环境可在常规分析环境中脚本调用质谱数据处理环境运行脚本\nalanrace/imzmlconverter:https://hub.docker.com/r/alanrace/imzmlconverter\n# 使用alanrace/imzmlconverter调用jimzMLConverter软件docker run -i --rm \\-v /path/to/mydata:/mydata \\alanrace/imzmlconverter:latest \\jimzMLConverter imzML /mydata/data.RAW# 使用alanrace/imzmlconverter调用脚本docker run -i --rm \\-v /path/to/mydata:/mydata \\-v /path/to/script:/script \\alanrace/imzmlconverter:latest \\/script/XXX.script# 使用alanrace/imzmlconverterdocker run -it --rm \\-v /path/to/mydata:/mydata \\-v /path/to/script:/script \\alanrace/imzmlconverter:latest \\bash\n\n\nimzML预处理环境可在常规分析环境中脚本调用预处理环境运行脚本\nlujiawei/cardinalenv:https://hub.docker.com/r/lujiawei/cardinalenv\n# 使用lujiawei/cardinalenv调用脚本docker run -i --rm \\-v /public:/public \\-v /etc/sysconfig/docker:/etc/sysconfig/docker \\-v /var/run/docker.sock:/var/run/docker.sock \\-v /usr/bin/docker:/usr/bin/docker \\lujiawei/cardinalenv \\/path/to/script/XXX.script# 使用lujiawei/cardinalenvdocker run -d --privileged \\-v /public:/public \\-v /etc/sysconfig/docker:/etc/sysconfig/docker \\-v /var/run/docker.sock:/var/run/docker.sock \\-v /usr/bin/docker:/usr/bin/docker \\-p 8082:22 -p 8789:8787 \\--name cardinalenv \\lujiawei/cardinalenv\n\n\n常规分析环境lujiawei/lumingos(加密，仅lujiawei账户可拉取，不对外使用):https://hub.docker.com/r/lujiawei/lumingos\n# 使用lujiawei/lumingos调用脚本docker run -i --rm \\-v /public:/public \\-v /etc/sysconfig/docker:/etc/sysconfig/docker \\-v /var/run/docker.sock:/var/run/docker.sock \\-v /usr/bin/docker:/usr/bin/docker \\lujiawei/lumingos \\/path/to/script/XXX.script# 使用lujiawei/lumingosdocker run -d --privileged \\-v /public:/public \\-v /data/mzdata:/data/mzdata \\-v /etc/sysconfig/docker:/etc/sysconfig/docker \\-v /var/run/docker.sock:/var/run/docker.sock \\-v /usr/bin/docker:/usr/bin/docker \\-p 8080:22 -p 8787:8787 -p 3838:3838\\--name ssh \\lujiawei/lumingos# 通过22端口进入容器后开启以下功能rstudio-server startnohup shiny-server &amp;# 可通过ip:8787链接使用rstudio-server\n","categories":["代谢","扩展"],"tags":["空间代谢组"]},{"title":"个人简历","url":"https://lujw666.github.io/2021/02/23/profile/","content":"陆嘉伟 / Jiawei Lu生物信息分析工程师 / Bioinformatics Analysis Engineer&nbsp;&#x6c;&#106;&#x77;&#x31;&#56;&#x37;&#x32;&#49;&#51;&#x32;&#55;&#52;&#x37;&#50;&#x40;&#x6f;&#117;&#116;&#x6c;&#111;&#x6f;&#107;&#x2e;&#x63;&#111;&#x6d;\nhttps://lujw666.gitbook.io/learn/\n\n关于我本人进取主动、独立性强、具有高度的职责感和敬业精神，待人真诚、诚实守信、团结协作意识强，能够吃苦耐劳，勇于挑战新事物，具有必须的开拓创新本事。具备丰富的工作经验，认真踏实负责，熟练掌握python/R/shell语言，熟悉git、gitlab等项目开发协作平台的使用，掌握SQL使用。\n\n工作经历上海鹿明生物科技有限公司&emsp;&emsp;&emsp;&emsp;2018/9-至今\n生物信息分析主管\n工作描述:\n\n负责管理生物信息分析部组日常分析工作；\n组织及负责生物信息分析平台搭建及维护;\n根据文献和客户需求完成个性化分析需求，并配合其他部门解决数据分析相关问题;\n负责达成公司生物信息开发、维护和升级已有生物信息分析流程，对数据分析流程进行优化；\n\n\n教育经历江苏大学&emsp;生物技术&emsp;本科&emsp;&emsp;2011/9-2015/7\n专业描述：\n本科阶段主修：生物化学，无机化学，有机化学，物理化学，细胞生物学，微生物学，植物学，动物学，生化分离工程，基因工程，发酵工程，酶工程，细胞工程，遗传学，分子生物学，生物信息学，蛋白质组学，食品生物技术。\n\n培训经历超级经理人&emsp;上海大企之道有限公司&emsp;&emsp;2019/10-2020/10\n培训描述：以企业中高层管理团队为培养对象的系统化训练模式，既是目前富有成效的团队素质提升系统，也是推动组织目标高效达成的支持体系\n\n技能特长\n","categories":[],"tags":["其他"]},{"title":"Markdown之reveal.js","url":"https://lujw666.github.io/2021/02/23/reveal-js/","content":"reveal.js是一个使用HTML和Markdown快速创建和演示幻灯片的工具。\nreveal.js的主要功能如下：\n\n可创建水平和垂直幻灯片，支持幻灯片链接，可在幻灯片之间跳转。\n可使用Markdown和HTML编写内容，也支持引用独立的Markdown文件。\n可使用颜色、图片、视频、网页做为背景。\n可添加演讲者注释，支持一键打开。\n可配置幻灯片的主题和过渡动画，有多种方案可供选择。\n可在手机或平板电脑上打开和演示幻灯片。\n可打印和导出PDF格式的文档。\n可以安装很多实用的插件来增强幻灯片的功能和演示效果。\n自由度大，可灵活定制。\n支持很多快捷键的使用，操作非常方便。\n\n\n\n相关链接reveal.js 官网：https://revealjs.com/reveal.js 教程:https://sspai.com/post/40657\n","categories":["Markdown","扩展"],"tags":["markdown","reveal.js"]},{"title":"Markdown之mermaid插件","url":"https://lujw666.github.io/2021/02/23/mermaid/","content":"mermaid插件画流程图、时序图(顺序图)、甘特图。\n官网说明:https://mermaid-js.github.io/mermaid/#/\n\n\n横向流程图graph LRA[方形] --&gt;B(圆角)    B --&gt; C&#123;条件a&#125;    C --&gt;|a&#x3D;1| D[结果1]    C --&gt;|a&#x3D;2| E[结果2]    F[横向流程图]\n\n\n\n竖向流程图graph TDA[方形] --&gt; B(圆角)    B --&gt; C&#123;条件a&#125;    C --&gt; |a&#x3D;1| D[结果1]    C --&gt; |a&#x3D;2| E[结果2]    F[竖向流程图]\n\n\n\nUML时序图%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头sequenceDiagram    participant 张三    participant 李四    张三-&gt;王五: 王五你好吗？    loop 健康检查        王五-&gt;王五: 与疾病战斗    end    Note right of 王五: 合理 食物 &lt;br&#x2F;&gt;看医生...    李四--&gt;&gt;张三: 很好!    王五-&gt;李四: 你怎么样?    李四--&gt;王五: 很好!\n\n\n\n甘特图gantt    dateFormat  YYYY-MM-DD    title 软件开发甘特图    section 设计    需求                      :done,    des1, 2014-01-06,2014-01-08    原型                      :active,  des2, 2014-01-09, 3d    UI设计                     :         des3, after des2, 5d    未来任务                     :         des4, after des3, 5d    section 开发    学习准备理解需求                      :crit, done, 2014-01-06,24h    设计框架                             :crit, done, after des2, 2d    开发                                 :crit, active, 3d    未来任务                              :crit, 5d    耍                                   :2d    section 测试    功能测试                              :active, a1, after des3, 3d    压力测试                               :after a1  , 20h    测试报告                               : 48h\n\n","categories":["Markdown","扩展"],"tags":["markdown","mermaid"]},{"title":"Swarm 集群管理","url":"https://lujw666.github.io/2021/02/23/docker-swarn/","content":"Docker Swarm 是 Docker 的集群管理工具。它将 Docker 主机池转变为单个虚拟 Docker 主机。 Docker Swarm 提供了标准的 Docker API，所有任何已经与 Docker 守护程序通信的工具都可以使用 Swarm 轻松地扩展到多个主机。\n支持的工具包括但不限于以下各项：\n\nDokku\nDocker Compose\nDocker Machine\nJenkins\n\n\n\n原理swarm 集群由管理节点（manager）和工作节点（work node）构成。\n\nswarm mananger：负责整个集群的管理工作包括集群配置、服务管理等所有跟集群有关的工作。\nwork node：即图中的 available node，主要负责运行相应的服务来执行任务（task）。\n\n\n\n\n使用1、创建 swarm 集群管理节点（manager）\n创建 docker 机器：\n$ docker-machine create -d virtualbox swarm-manager\n\n初始化 swarm 集群，进行初始化的这台机器，就是集群的管理节点。\n$ docker-machine ssh swarm-manager$ docker swarm init --advertise-addr 192.168.99.107 #这里的 IP 为创建机器时分配的 ip。\n\n以上输出，证明已经初始化成功。需要把以下这行复制出来，在增加工作节点时会用到：\ndocker swarm join --token SWMTKN-1-4oogo9qziq768dma0uh3j0z0m5twlm10iynvz7ixza96k6jh9p-ajkb6w7qd06y1e33yrgko64sk 192.168.99.107:2377\n2、创建 swarm 集群工作节点（worker）\n这里直接创建好俩台机器，swarm-worker1 和 swarm-worker2 。\n\n分别进入两个机器里，指定添加至上一步中创建的集群，这里会用到上一步复制的内容。\n\n以上数据输出说明已经添加成功。\n上图中，由于上一步复制的内容比较长，会被自动截断，实际上在图运行的命令如下：\n$ docker swarm join --token SWMTKN-1-4oogo9qziq768dma0uh3j0z0m5twlm10iynvz7ixza96k6jh9p-ajkb6w7qd06y1e33yrgko64sk 192.168.99.107:2377\n3、查看集群信息\n进入管理节点，执行：docker info 可以查看当前集群的信息。\n$ docker info\n\n通过画红圈的地方，可以知道当前运行的集群中，有三个节点，其中有一个是管理节点。\n4、部署服务到集群中\n注意：跟集群管理有关的任何操作，都是在管理节点上操作的。\n以下例子，在一个工作节点上创建一个名为 helloworld 的服务，这里是随机指派给一个工作节点：\ndocker@swarm-manager:~$ docker service create --replicas 1 --name helloworld alpine ping docker.com\n\n5、查看服务部署情况\n查看 helloworld 服务运行在哪个节点上，可以看到目前是在 swarm-worker1 节点：\ndocker@swarm-manager:~$ docker service ps helloworld\n\n查看 helloworld 部署的具体信息：\ndocker@swarm-manager:~$ docker service inspect --pretty helloworld\n\n6、扩展集群服务\n将上述的 helloworld 服务扩展到俩个节点。\ndocker@swarm-manager:~$ docker service scale helloworld=2\n可以看到已经从一个节点，扩展到两个节点。\n\n7、删除服务\ndocker@swarm-manager:~$ docker service rm helloworld\n查看是否已删除：\n\n8、滚动升级服务\n将介绍 redis 版本如何滚动升级至更高版本。\n创建一个 3.0.6 版本的 redis。\ndocker@swarm-manager:~$ docker service create --replicas 1 --name redis --update-delay 10s redis:3.0.6\n\n滚动升级 redis 。\ndocker@swarm-manager:~$ docker service update --image redis:3.0.7 redis\n\n看图可以知道 redis 的版本已经从 3.0.6 升级到了 3.0.7，说明服务已经升级成功。\n9、停止某个节点接收新的任务\n查看所有的节点：\ndocker@swarm-manager:~$ docker node ls\n\n可以看到目前所有的节点都是 Active, 可以接收新的任务分配。\n停止节点 swarm-worker1：\n\n注意：swarm-worker1 状态变为 Drain。不会影响到集群的服务，只是 swarm-worker1 节点不再接收新的任务，集群的负载能力有所下降。\n可以通过以下命令重新激活节点：\ndocker@swarm-manager:~$  docker node update --availability active swarm-worker1\n\n","categories":["Docker","扩展"],"tags":["docker","swarn"]},{"title":"Docker Machine","url":"https://lujw666.github.io/2021/02/23/docker-machine/","content":"Docker Machine 是一种可以让您在虚拟主机上安装 Docker 的工具，并可以使用 docker-machine 命令来管理主机。\n使用 docker-machine 命令，您可以启动，检查，停止和重新启动托管主机，也可以升级 Docker 客户端和守护程序，以及配置 Docker 客户端与您的主机进行通信。\n\n\n安装安装 Docker Machine 之前你需要先安装 Docker。\nDocker Machine 可以在多种平台上安装使用，包括 Linux 、MacOS 以及 windows。\n\n\nLinux 安装命令$ base=https://github.com/docker/machine/releases/download/v0.16.0 &amp;&amp;  curl -L $base/docker-machine-$(uname -s)-$(uname -m) &gt;/tmp/docker-machine &amp;&amp;  sudo mv /tmp/docker-machine /usr/local/bin/docker-machine &amp;&amp;  chmod +x /usr/local/bin/docker-machine\n\n\nmacOS 安装命令$ base=https://github.com/docker/machine/releases/download/v0.16.0 &amp;&amp;  curl -L $base/docker-machine-$(uname -s)-$(uname -m) &gt;/usr/local/bin/docker-machine &amp;&amp;  chmod +x /usr/local/bin/docker-machine\n\n\nWindows 安装命令如果是 Windows 平台，可以使用 Git BASH，并输入以下命令：\n$ base=https://github.com/docker/machine/releases/download/v0.16.0 &amp;&amp;  mkdir -p &quot;$HOME/bin&quot; &amp;&amp;  curl -L $base/docker-machine-Windows-x86_64.exe &gt; &quot;$HOME/bin/docker-machine.exe&quot; &amp;&amp;  chmod +x &quot;$HOME/bin/docker-machine.exe&quot;\n\n\n使用1、列出可用的机器\n$ docker-machine ls\n2、创建机器\n创建一台名为 test 的机器。\n$ docker-machine create --driver virtualbox test\n\n–driver：指定用来创建机器的驱动类型，这里是 virtualbox。\n\n3、查看机器的 ip\n$ docker-machine ip test\n4、停止机器\n$ docker-machine stop test\n5、启动机器\n$ docker-machine start test\n6、进入机器\n$ docker-machine ssh test\n\n\ndocker-machine 命令参数说明\nactive：查看当前激活状态的 Docker 主机。\nconfig：查看当前激活状态 Docker 主机的连接信息。\ncreat：创建 Docker 主机\nenv：显示连接到某个主机需要的环境变量\ninspect： 以 json 格式输出指定Docker的详细信息\nip： 获取指定 Docker 主机的地址\nkill： 直接杀死指定的 Docker 主机\nls： 列出所有的管理主机\nprovision： 重新配置指定主机\nregenerate-certs： 为某个主机重新生成 TLS 信息\nrestart： 重启指定的主机\nrm： 删除某台 Docker 主机，对应的虚拟机也会被删除\nssh： 通过 SSH 连接到主机上，执行命令\nscp： 在 Docker 主机之间以及 Docker 主机和本地主机之间通过 scp 远程复制数据\nmount： 使用 SSHFS 从计算机装载或卸载目录\nstart： 启动一个指定的 Docker 主机，如果对象是个虚拟机，该虚拟机将被启动\nstatus： 获取指定 Docker 主机的状态(包括：Running、Paused、Saved、Stopped、Stopping、Starting、Error)等\nstop： 停止一个指定的 Docker 主机\nupgrade： 将一个指定主机的 Docker 版本更新为最新\nurl： 获取指定 Docker 主机的监听 URL\nversion： 显示 Docker Machine 的版本或者主机 Docker 版本\nhelp： 显示帮助信息\n\n","categories":["Docker","扩展"],"tags":["docker"]},{"title":"Docker Compose","url":"https://lujw666.github.io/2021/02/23/docker-compose/","content":"docker compose 用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。\nCompose 使用的三个步骤：\n\n使用 Dockerfile 定义应用程序的环境。\n使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。\n最后，执行 docker-compose up 命令来启动并运行整个应用程序。\n\ndocker-compose.yml 的配置案例:\n# yaml 配置实例version: &#x27;3&#x27;services:  web:    build: .    ports:   - &quot;5000:5000&quot;    volumes:   - .:/code    - logvolume01:/var/log    links:   - redis  redis:    image: redisvolumes:  logvolume01: &#123;&#125;\n\n\nDocker-compose 安装Linux 平台上安装Debian/UbuntuDebian/Ubuntu 安装命令为：\napt-get install -y docker-compose\nCentos/RedHat如果你使用的系统是 Centos/RedHat 安装命令为：\npip install docker-compose\n\n\nWindows/macOS 平台上安装Windows/macOS 的 Docker 桌面版和 Docker Toolbox 已经包括 Compose 和其他 Docker 应用程序，因此用户不需要单独安装 Compose。\n\n\nDocker-compose 常用命令Docker-compose命令格式docker-compose [-f &lt;arg&gt;...] [options] [COMMAND] [ARGS...]\n\n-f –file FILE指定Compose模板文件，默认为docker-compose.yml\n-p –project-name NAME 指定项目名称，默认使用当前所在目录为项目名\n–verbose  输出更多调试信息\n-v，-version 打印版本并退出\n–log-level LEVEL 定义日志等级(DEBUG, INFO, WARNING, ERROR, CRITICAL)\n\n\n\ndocker-compose up启动应用程序\ndocker-compose up [options] [--scale SERVICE=NUM...] [SERVICE...]\n\n-d 在后台运行服务容器\n-no-color 不是有颜色来区分不同的服务的控制输出\n-no-deps 不启动服务所链接的容器\n–force-recreate 强制重新创建容器，不能与-no-recreate同时使用\n–no-recreate 如果容器已经存在，则不重新创建，不能与–force-recreate同时使用\n–no-build 不自动构建缺失的服务镜像\n–build 在启动容器前构建服务镜像\n–abort-on-container-exit 停止所有容器，如果任何一个容器被停止，不能与-d同时使用\n-t, –timeout TIMEOUT 停止容器时候的超时（默认为10秒）\n–remove-orphans 删除服务中没有在compose文件中定义的容器\n\n\n\ndocker-compose ps列出项目中所有的容器\ndocker-compose  ps [options] [SERVICE...]\n\n\ndocker-compose stop停止正在运行的容器\ndocker-compose stop [options] [SERVICE...]\n\n-t, –timeout TIMEOUT 停止容器时候的超时（默认为10秒）\n\n停止运行的容器，可以通过docker-compose start 再次启动\n\n\ndocker-compose -h查看帮助\n\n\ndocker-compose down停止和删除容器、网络、卷、镜像\ndocker-compose down [options]\n\n–rmi type，删除镜像，类型必须是：all，删除compose文件中定义的所有镜像；local，删除镜像名为空的镜像\n-v, –volumes，删除已经在compose文件中定义的和匿名的附在容器上的数据卷\n–remove-orphans，删除服务中没有在compose中定义的容器\n\n\n\ndocker-compose logs查看服务容器的输出\ndocker-compose logs [options] [SERVICE...]\n\n-f 跟踪日志输出\n\n默认情况下，docker-compose将对不同的服务输出使用不同的颜色来区分。可以通过–no-color来关闭颜色。\n\n\ndocker-compose bulid构建（重新构建）项目中的服务容器\ndocker-compose build [options] [--build-arg key=val...] [SERVICE...]\n\n–compress 通过gzip压缩构建上下环境\n–force-rm 删除构建过程中的临时容器\n–no-cache 构建镜像过程中不使用缓存\n–pull 始终尝试通过拉取操作来获取更新版本的镜像\n-m, –memory MEM为构建的容器设置内存大小\n–build-arg key=val为服务设置build-time变量\n服务容器一旦构建后，将会带上一个标记名。可以随时在项目目录下运行docker-compose build来重新构建服务\n\n\n\ndocker-compose pull拉取服务依赖的镜像\ndocker-compose pull [options] [SERVICE...]\n\n–ignore-pull-failures，忽略拉取镜像过程中的错误\n–parallel，多个镜像同时拉取\n–quiet，拉取镜像过程中不打印进度信息\n\n\n\ndocker-compose restart重启项目中的服务\ndocker-compose restart [options] [SERVICE...]\n\n-t, –timeout TIMEOUT，指定重启前停止容器的超时（默认为10秒）\n\n\n\ndocker-compose rm删除所有（停止状态的）服务容器,但推荐先执行docker-compose stop命令来停止容器。\ndocker-compose rm [options] [SERVICE...]\n\n–f, –force，强制直接删除，包括非停止状态的容器\n-v，删除容器所挂载的数据卷\n\n\n\ndocker-compose start启动已经存在的服务容器\ndocker-compose start [SERVICE...]\n\n\ndocker-compose run在指定服务上执行一个命令\ndocker-compose run [options] [-v VOLUME...] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]\n\n\ndocker-compose scale设置指定服务运行的容器个数。通过service=num的参数来设置数量\ndocker-compose scale web=3 db=2\n\n\ndocker-compose pause暂停一个服务容器\ndocker-compose pause [SERVICE...]\n\n\ndocker-compose kill通过发送SIGKILL信号来强制停止服务容器\ndocker-compose kill [options] [SERVICE...]\n\n\ndocker-compose config验证并查看compose文件配置\ndocker-compose config [options]\n\n–resolve-image-digests 将镜像标签标记为摘要\n-q, –quiet 只验证配置，不输出。 当配置正确时，不输出任何内容，当文件配置错误，输出错误信息\n–services 打印服务名，一行一个\n–volumes 打印数据卷名，一行一个\n\n\n\ndocker-compose create为服务创建容器\ndocker-compose create [options] [SERVICE...]\n\n–force-recreate：重新创建容器，即使配置和镜像没有改变，不兼容–no-recreate参数\n–no-recreate：如果容器已经存在，不需要重新创建，不兼容–force-recreate参数\n–no-build：不创建镜像，即使缺失\n–build：创建容器前，生成镜像\n\n\n\ndocker-compose exec在运行的容器中执行命令\ndocker-compose exec [options] SERVICE COMMAND [ARGS...]\n\n-d 分离模式，后台运行命令。\n–privileged 获取特权。\n–user USER 指定运行的用户。\n-T 禁用分配TTY，默认docker-compose exec分配TTY。\n–index=index，当一个服务拥有多个容器时，可通过该参数登陆到该服务下的任何服务，例如：docker-compose exec –index=1 web /bin/bash ，web服务中包含多个容器\n\n\n\ndocker-compose port显示某个容器端口所映射的公共端口\ndocker-compose port [options] SERVICE PRIVATE_PORT\n\n–protocol=proto，指定端口协议，TCP（默认值）或者UDP\n–index=index，如果同意服务存在多个容器，指定命令对象容器的序号（默认为1）\n\n\n\ndocker-compose push推送服务依的镜像\ndocker-compose push [options] [SERVICE...]\n\n–ignore-push-failures 忽略推送镜像过程中的错误\n\n\n\ndocker-compose uppause恢复处于暂停状态中的服务\ndocker-compose unpause [SERVICE...]\n\n\nyml 配置指令参考version指定本 yml 依从的 compose 哪个版本制定的。\n\n\nbuild指定为构建镜像上下文路径：\n例如 webapp 服务，指定为从上下文路径 ./dir/Dockerfile 所构建的镜像：\nversion: &quot;3.7&quot;services:  webapp:    build: ./dir\n或者，作为具有在上下文指定的路径的对象，以及可选的 Dockerfile 和 args：\nversion: &quot;3.7&quot;services:  webapp:    build:      context: ./dir      dockerfile: Dockerfile-alternate      args:        buildno: 1      labels:        - &quot;com.example.description=Accounting webapp&quot;        - &quot;com.example.department=Finance&quot;        - &quot;com.example.label-with-empty-value&quot;      target: prod\n\ncontext：上下文路径。\ndockerfile：指定构建镜像的 Dockerfile 文件名。\nargs：添加构建参数，这是只能在构建过程中访问的环境变量。\nlabels：设置构建镜像的标签。\ntarget：多层构建，可以指定构建哪一层。\n\n\n\ncap_add，cap_drop添加或删除容器拥有的宿主机的内核功能。\ncap_add:  - ALL # 开启全部权限cap_drop:  - SYS_PTRACE # 关闭 ptrace权限\n\n\ncgroup_parent为容器指定父 cgroup 组，意味着将继承该组的资源限制。\ncgroup_parent: m-executor-abcd\n\n\ncommand覆盖容器启动的默认命令。\ncommand: [&quot;bundle&quot;, &quot;exec&quot;, &quot;thin&quot;, &quot;-p&quot;, &quot;3000&quot;]\n\n\ncontainer_name指定自定义容器名称，而不是生成的默认名称。\ncontainer_name: my-web-container\n\n\ndepends_on设置依赖关系。\ndocker-compose up ：以依赖性顺序启动服务。在以下示例中，先启动 db 和 redis ，才会启动 web。docker-compose up SERVICE ：自动包含 SERVICE 的依赖项。在以下示例中，docker-compose up web 还将创建并启动 db 和 redis。docker-compose stop ：按依赖关系顺序停止服务。在以下示例中，web 在 db 和 redis 之前停止。\nversion: &quot;3.7&quot;services:  web:    build: .    depends_on:      - db      - redis  redis:    image: redis  db:    image: postgres\n注意：web 服务不会等待 redis db 完全启动 之后才启动。\n\n\ndeploy指定与服务的部署和运行有关的配置。只在 swarm 模式下才会有用。\nversion: &quot;3.7&quot;services:  redis:    image: redis:alpine    deploy:      mode：replicated      replicas: 6      endpoint_mode: dnsrr      labels:         description: &quot;This redis service label&quot;      resources:        limits:          cpus: &#x27;0.50&#x27;          memory: 50M        reservations:          cpus: &#x27;0.25&#x27;          memory: 20M      restart_policy:        condition: on-failure        delay: 5s        max_attempts: 3        window: 120s\n可以选参数：\n\nendpoint_mode：访问集群服务的方式。\n\nendpoint_mode: vip # Docker 集群服务一个对外的虚拟 ip。所有的请求都会通过这个虚拟 ip 到达集群服务内部的机器。endpoint_mode: dnsrr# DNS 轮询（DNSRR）。所有的请求会自动轮询获取到集群 ip 列表中的一个 ip 地址。\n\nlabels：在服务上设置标签。可以用容器上的 labels（跟 deploy 同级的配置） 覆盖 deploy 下的 labels。\nmode：指定服务提供的模式。\nreplicated：复制服务，复制指定服务到集群的机器上。\nglobal：全局服务，服务将部署至集群的每个节点。\n\n\nreplicas：mode 为 replicated 时，需要使用此参数配置具体运行的节点数量。\nresources：配置服务器资源使用的限制，例如上例子，配置 redis 集群运行需要的 cpu 的百分比 和 内存的占用。避免占用资源过高出现异常。\nrestart_policy：配置如何在退出容器时重新启动容器。\ncondition：可选 none，on-failure 或者 any（默认值：any）。\ndelay：设置多久之后重启（默认值：0）。\nmax_attempts：尝试重新启动容器的次数，超出次数，则不再尝试（默认值：一直重试）。\nwindow：设置容器重启超时时间（默认值：0）。\n\n\nrollback_config：配置在更新失败的情况下应如何回滚服务。\nparallelism：一次要回滚的容器数。如果设置为0，则所有容器将同时回滚。\ndelay：每个容器组回滚之间等待的时间（默认为0s）。\nfailure_action：如果回滚失败，该怎么办。其中一个 continue 或者 pause（默认pause）。\nmonitor：每个容器更新后，持续观察是否失败了的时间 (ns|us|ms|s|m|h)（默认为0s）。\nmax_failure_ratio：在回滚期间可以容忍的故障率（默认为0）。\norder：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者 start-first（并行回滚）（默认 stop-first ）。\n\n\nupdate_config：配置应如何更新服务，对于配置滚动更新很有用。\nparallelism：一次更新的容器数。\ndelay：在更新一组容器之间等待的时间。\nfailure_action：如果更新失败，该怎么办。其中一个 continue，rollback 或者pause （默认：pause）。\nmonitor：每个容器更新后，持续观察是否失败了的时间 (ns|us|ms|s|m|h)（默认为0s）。\nmax_failure_ratio：在更新过程中可以容忍的故障率。\norder：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者 start-first（并行回滚）（默认stop-first）。\n\n\n\n\n\ndevices指定设备映射列表。\ndevices:  - &quot;/dev/ttyUSB0:/dev/ttyUSB0&quot;\n\n\ndns自定义 DNS 服务器，可以是单个值或列表的多个值。\ndns: 8.8.8.8dns:  - 8.8.8.8  - 9.9.9.9\n\n\ndns_search自定义 DNS 搜索域。可以是单个值或列表。\ndns_search: example.comdns_search:  - dc1.example.com  - dc2.example.com\n\n\nentrypoint覆盖容器默认的 entrypoint。\nentrypoint: /code/entrypoint.shentrypoint:    - php    - -d    - zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so    - -d    - memory_limit=-1    - vendor/bin/phpunit\n\n\nenv_file从文件添加环境变量。可以是单个值或列表的多个值。\nenv_file: .envenv_file:  - ./common.env  - ./apps/web.env  - /opt/secrets.env\n\n\nenvironment添加环境变量。您可以使用数组或字典、任何布尔值，布尔值需要用引号引起来，以确保 YML 解析器不会将其转换为 True 或 False。\nenvironment:  RACK_ENV: development  SHOW: &#x27;true&#x27;\n\n\nexpose暴露端口，但不映射到宿主机，只被连接的服务访问。\n仅可以指定内部端口为参数：\nexpose: - &quot;3000&quot; - &quot;8000&quot;\n\n\nports对外暴露的端口定义，和 expose 对应\nports:   # 暴露端口信息  - &quot;宿主机端口:容器暴露端口&quot; - &quot;8763:8763&quot; - &quot;8763:8763&quot;\n\n\nextra_hosts添加主机名映射。类似 docker client –add-host。\nextra_hosts: - &quot;somehost:162.242.195.82&quot; - &quot;otherhost:50.31.209.229&quot;\n以上会在此服务的内部容器中 /etc/hosts 创建一个具有 ip 地址和主机名的映射关系：\n162.242.195.82  somehost50.31.209.229   otherhost\n\n\nhealthcheck用于检测 docker 服务是否健康运行。\nhealthcheck:  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;] # 设置检测程序  interval: 1m30s # 设置检测间隔  timeout: 10s # 设置检测超时时间  retries: 3 # 设置重试次数  start_period: 40s # 启动后，多少秒开始启动检测程序\n\n\nimage指定容器运行的镜像。以下格式都可以：\nimage: redisimage: ubuntu:14.04image: tutum/influxdbimage: example-registry.com:4000/postgresqlimage: a4bc65fd # 镜像id\n\n\nlogging服务的日志记录配置。\ndriver：指定服务容器的日志记录驱动程序，默认值为json-file。有以下三个选项\ndriver: &quot;json-file&quot;driver: &quot;syslog&quot;driver: &quot;none&quot;\n仅在 json-file 驱动程序下，可以使用以下参数，限制日志得数量和大小。\nlogging:  driver: json-file  options:    max-size: &quot;200k&quot; # 单个文件大小为200k    max-file: &quot;10&quot; # 最多10个文件\n当达到文件限制上限，会自动删除旧得文件。\nsyslog 驱动程序下，可以使用 syslog-address 指定日志接收地址。\nlogging:  driver: syslog  options:    syslog-address: &quot;tcp://192.168.0.42:123&quot;\n\n\nnetwork_mode设置网络模式。\nnetwork_mode: &quot;bridge&quot;network_mode: &quot;host&quot;network_mode: &quot;none&quot;network_mode: &quot;service:[service name]&quot;network_mode: &quot;container:[container name/id]&quot;\n\n\nnetworks配置容器连接的网络，引用顶级 networks 下的条目 。\nservices:  some-service:    networks:      some-network:        aliases:         - alias1      other-network:        aliases:         - alias2networks:  some-network:    # Use a custom driver    driver: custom-driver-1  other-network:    # Use a custom driver which takes special options    driver: custom-driver-2\naliases ：同一网络上的其他容器可以使用服务名称或此别名来连接到对应容器的服务。\n\n\nrestart\nno：是默认的重启策略，在任何情况下都不会重启容器。\nalways：容器总是重新启动。on-failure：在容器非正常退出时（退出状态非0），才会重启容器。unless-stopped：在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器\n\nrestart: &quot;no&quot;restart: alwaysrestart: on-failurerestart: unless-stopped\n注：swarm 集群模式，请改用restart_policy。\n\n\nsecrets存储敏感数据，例如密码：\nversion: &quot;3.1&quot;services:mysql:  image: mysql  environment:    MYSQL_ROOT_PASSWORD_FILE: /run/secrets/my_secret  secrets:    - my_secretsecrets:  my_secret:    file: ./my_secret.txt\n\n\nsecurity_opt修改容器默认的 schema 标签。\nsecurity-opt：  - label:user:USER   # 设置容器的用户标签  - label:role:ROLE   # 设置容器的角色标签  - label:type:TYPE   # 设置容器的安全策略标签  - label:level:LEVEL  # 设置容器的安全等级标签\n\n\nstop_grace_period指定在容器无法处理 SIGTERM (或者任何 stop_signal 的信号)，等待多久后发送 SIGKILL 信号关闭容器。\nstop_grace_period: 1s # 等待 1 秒stop_grace_period: 1m30s # 等待 1 分 30 秒\n默认的等待时间是 10 秒。\n\n\nstop_signal设置停止容器的替代信号。默认情况下使用 SIGTERM 。\n以下示例，使用 SIGUSR1 替代信号 SIGTERM 来停止容器。\nstop_signal: SIGUSR1\n\n\nsysctls设置容器中的内核参数，可以使用数组或字典格式。\nsysctls:  net.core.somaxconn: 1024  net.ipv4.tcp_syncookies: 0sysctls:  - net.core.somaxconn=1024  - net.ipv4.tcp_syncookies=0\n\n\ntmpfs在容器内安装一个临时文件系统。可以是单个值或列表的多个值。\ntmpfs: /runtmpfs:  - /run  - /tmp\n\n\nulimits覆盖容器默认的 ulimit。\nulimits:  nproc: 65535  nofile:    soft: 20000    hard: 40000\n\n\nvolumes将主机的数据卷或着文件挂载到容器里。\nversion: &quot;3.7&quot;services:  db:    image: postgres:latest    volumes:      - &quot;/localhost/postgres.sock:/var/run/postgres/postgres.sock&quot;      - &quot;/localhost/data:/var/lib/postgresql/data&quot;","categories":["Docker","扩展"],"tags":["docker"]},{"title":"Docker笔记（10）——技巧和秘诀","url":"https://lujw666.github.io/2021/02/23/docker-10/","content":"容器和镜像的关系无论容器里做什么操作，写文件，删文件。该容器的基本镜像都不会有任何改变。这是因为Docker从父镜像建立增量镜像，只存储每个容器的更改。因此，如果你有一个300MB的父镜像，如果你在容器中安装了50MB的额外应用或服务，你的容器只有50MB，父镜像还是300MB。 但是可以使用Dockfile或commit命令来，把增量镜像和父镜像一起生成一个新的镜像。\n#  显示容器中运行的进程docker top &lt;容器名orID&gt;# 查看容器的root用户名和密码docker logs &lt;容器名orID&gt; 2&gt;&amp;1 | grep &#x27;^User: &#x27; | tail -n1# 因为docker容器启动时的root用户的密码是随机分配的。所以，通过这种方式就可以得到redmine容器的root用户的密码了。# 实时查看容器日志docker logs -f &lt;容器名orID&gt;# 删除所有容器docker rm $(docker ps -a -q)# 停止、启动、杀死一个容器docker stop &lt;容器名orID&gt;docker start &lt;容器名orID&gt;docker kill &lt;容器名orID&gt;# 查看所有镜像docker images# 删除所有镜像docker rmi $(docker images | grep none | awk &#x27;&#123;print $3&#125;&#x27; | sort -r)# 移除所有的容器和镜像（大扫除）# 用一行命令大扫除：docker kill $(docker ps -q) ; docker rm $(docker ps -a -q) ; docker rmi $(docker images -q -a)# 注：shell 中的 $() 和command类似，会先执行这里面的内容，上面的脚本会出现如下 docker kill &quot;pids&quot; ; docker kill 在 docker 中用于停止容器，docker rm 删除容器， docker rmi 删除镜像# 当没有运行的容器或者是根本没有容器的时候，这只会提示一个警告信息。当你想尝试的时候，这就是个非常好的单行命令。如果你仅仅想删除所有的容器，你可以运行如下命令：docker kill $(docker ps -q) ; docker rm $(docker ps -a -q) # 不在 Shell 上运行命令# 如果你使用需要Shell 的扩展项的 docker run 命令处理某些事情，比如 docker run --rm busybox ls &#x27;/var/log/&#x27;, 这个命令将失败。原来没有 Shell ， 而 ``` 是 Shell 的扩展项，因此你需要一个能使用的 Shell 。正确方法为docker run --rm busybox sh -c &#x27;ls /var/log/*&#x27;# 多程序开机自动运行方法：# docker容器每次启动时，开机自启动的命令都要在启动容器前指定。如 docker run -I -t debian /bin/bash命令，只会运行/bin/bash程序，其它的程序都不会运行，对于要跑多个程序的容器特别纠结。可把前面所说的启动命令换成docker run -I -t debian /etc/rc.local# 在容器中把所有需要开机自的启动命令放在/etc/rc.local中，就可以达到多程序开机自启动了。# 后台运行则是：docker run -d -p 50001:22 debian /etc/rc.local# 退出时删除容器# 如果你仅仅想在一个容器中快速的运行一个命令，然后退出，并且不用担心容器状态，把 --rm 参数加入 run 命令后面,这将结束很多你保存了的容器，并且清理它们。docker run --rm -i -t busybox /bin/bash# 运行一个新容器，同时为它命名、端口映射、文件夹映射。以redmine镜像为例docker run --name redmine -p 9003:80 -p 9023:22 -d -v /var/redmine/files:/redmine/files -v /var/redmine/mysql:/var/lib/mysql sameersbn/redmine# 一个容器连接到另一个容器docker run -i -t --name sonar -d -link mmysql:db   tpires/sonar-serversonar# 容器连接到mmysql容器，并将mmysql容器重命名为db。这样，sonar容器就可以使用db的相关的环境变量了。\n\n\n镜像的保存与导入当需要把一台机器上的镜像迁移到另一台机器的时候，需要保存镜像与加载镜像。 \n机器a操作:\ndocker save busybox-1 &gt; /home/save.tar\n使用scp将save.tar拷到机器b上，然后：\ndocker load &lt; /home/save.tar# 构建自己的镜像docker build -t &lt;镜像名&gt; &lt;Dockerfile路径&gt;# 如Dockerfile在当前路径：docker build -t xx/gitlab .# 重新查看container的stdout# 启动top命令，后台运行ID=$(sudo docker run -d ubuntu /usr/bin/top -b)# 获取正在running的container的输出docker attach $IDtop - 02:05:52 up  3:05,  0 users,  load average: 0.01, 0.02, 0.05Tasks:   1 total,   1 running,   0 sleeping,   0 stopped,   0 zombieCpu(s):  0.1%us,  0.2%sy,  0.0%ni, 99.7%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%stMem:    373572k total,   355560k used,    18012k free,    27872k buffersSwap:   786428k total,        0k used,   786428k free,   221740k cached^C$sudo docker stop $ID# 后台运行(-d)、并暴露端口(-p)docker run -d -p 127.0.0.1:33301:22 centos6-ssh# 从container中拷贝文件出来sudo docker cp 7bb0e258aefe:/etc/debian_version .# 拷贝7bb0e258aefe中的/etc/debian_version到当前目录下。# 注意：只要7bb0e258aefe没有被删除，文件命名空间就还在，可以放心的把exit状态的container的文件拷贝出来\n","categories":["Docker","进阶"],"tags":["docker"]},{"title":"Docker笔记（09）——清理命令","url":"https://lujw666.github.io/2021/02/23/docker-09/","content":"杀死所有正在运行的容器docker kill $(docker ps -a -q)\n\n\n删除所有已经停止的容器docker rm $(docker ps -a -q)\n\n\n删除所有未打 dangling 标签的镜像docker rmi $(docker images -q -f dangling&#x3D;true)\n\n\n通过镜像的id来删除指定镜像docker rmi &lt;image id&gt;\n\n\n删除所有镜像docker rmi $(docker images -q)\n\n\n上述命令创建别名# ~/.bash_aliases# 杀死所有正在运行的容器.alias dockerkill=&#x27;docker kill $(docker ps -a -q)&#x27;# 删除所有已经停止的容器.alias dockercleanc=&#x27;docker rm $(docker ps -a -q)&#x27;# 删除所有未打标签的镜像.alias dockercleani=&#x27;docker rmi $(docker images -q -f dangling=true)&#x27;# 删除所有已经停止的容器和未打标签的镜像.alias dockerclean=&#x27;dockercleanc || true &amp;&amp; dockercleani&#x27;\n","categories":["Docker","进阶"],"tags":["docker"]},{"title":"Docker笔记（08）——命令大全","url":"https://lujw666.github.io/2021/02/23/docker-08/","content":"链接：https://lujw666.gitbook.io/learn/docker/00-basic/08-ming-ling\n\n\n\n\n\n容器生命周期管理\nrun 创建一个新的容器并运行一个命令\nstart/stop/restart   启动/停止/重启一个容器\nkill  杀掉一个运行中的容器\nrm  删除一个或多个容器\npause/unpause 暂停/恢复容器中所有的进程\ncreate   创建一个新的容器但不启动它\nexec   在运行的容器中执行命令\n\n\n\n容器操作\nps   列出容器\ninspect 获取容器/镜像的元数据\ntop 查看容器中运行的进程信息\nattach   连接到正在运行中的容器\nevents   从服务器获取实时事件\nlogs   获取容器的日志\nwait    阻塞运行直到容器停止，然后打印出它的退出代码\nexport   将文件系统作为一个tar归档文件导出到STDOUT\nport  列出指定的容器的端口映射\n\n\n\n容器rootfs命令\ncommit   从容器创建一个新的镜像\ncp   用于容器与主机之间的数据拷贝\ndiff   检查容器里文件结构的更改\n\n\n\n镜像仓库\nlogin/logout  登陆/登出Docker镜像仓库\npull   从镜像仓库中拉取或者更新指定镜像\npush   将本地的镜像上传到镜像仓库\nsearch   从Docker Hub查找镜像\n\n\n\n本地镜像管理\nimages   列出本地镜像\nrmi 删除本地一个或多少镜像\ntag 标记本地镜像，将其归入某一仓库\nbuild 用于使用 Dockerfile 创建镜像\nhistory 查看指定镜像的创建历史\nsave  将指定镜像保存成 tar 归档文件\nload  导入使用 docker save 命令导出的镜像\nimport   从归档文件中创建镜像\n\n","categories":["Docker","基础"],"tags":["docker"]},{"title":"Docker笔记（07）——dockerfile","url":"https://lujw666.github.io/2021/02/23/docker-07/","content":"Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。\n\n\n构建镜像\n在一个空目录下，新建一个名为 Dockerfile 文件，并在文件内添加内容；\n在 Dockerfile 文件的存放目录下，执行构建动作。\n\n以下示例，通过目录下的 Dockerfile 构建一个 nginx:v3（镜像名称:镜像标签）。\n$ docker build -t nginx:v3 .\n注：最后的 . 代表本次执行的上下文路径\n\n\n上下文路径指令最后一个 . 是上下文路径，那么什么是上下文路径呢？\n上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。\n解析：由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。\n如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置。\n注意：上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。\n\n\n指令详解FROM定制的镜像都是基于 FROM 的镜像。\nFROM nginxRUN echo &#x27;这是一个本地构建的nginx镜像&#x27; &gt; /usr/share/nginx/html/index.html\n上述 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。\n\n\nRUN用于执行后面跟着的命令行命令。\nRUN &lt;命令行命令&gt; # &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]# exec 格式\n注意：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。\nFROM centosRUN yum install wgetRUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;RUN tar -xvf redis.tar.gz以上执行会创建 3 层镜像。可简化为以下格式：FROM centosRUN yum install wget \\    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot; \\    &amp;&amp; tar -xvf redis.tar.gz\n如上，以 &amp;&amp; 符号连接命令，这样执行后，只会创建 1 层镜像。\n\n\nCOPY复制指令，从上下文目录中复制文件或者目录到容器里指定路径。\nCOPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,...  &quot;&lt;目标路径&gt;&quot;]\n\n–chown=&lt;user&gt;:&lt;group&gt;：可选参数，用户改变复制到容器内文件的拥有者和属组。\n&lt;源路径&gt;：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：\n\nCOPY hom* /mydir/COPY hom?.txt /mydir/\n\n&lt;目标路径&gt;：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。\n\n\n\nADDADD 指令和 COPY 的使用格式一致（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：\nADD 的优点：在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。\n\n\nCMD类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:\n\nCMD 在docker run 时运行。\nRUN 是在 docker build。\n\n作用：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。\n注意：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。\nCMD &lt;shell 命令&gt; CMD [&quot;&lt;可执行文件或命令&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]  # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数# 推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。\n\n\nENTRYPOINT类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。\n但是, 如果运行 docker run 时使用了 –entrypoint 选项，此选项的参数可当作要运行的程序覆盖 ENTRYPOINT 指令指定的程序。\n优点：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。\n注意：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。\nENTRYPOINT [&quot;&lt;executeable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]# 可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。\n示例：\n# 假设已通过 Dockerfile 构建了 nginx:test 镜像：FROM nginxENTRYPOINT [&quot;nginx&quot;, &quot;-c&quot;] # 定参CMD [&quot;/etc/nginx/nginx.conf&quot;] # 变参\n$ # 1、不传参运行$ docker run  nginx:test$ # 容器内会默认运行以下命令，启动主进程。nginx -c /etc/nginx/nginx.conf$ # 2、传参运行$ docker run  nginx:test -c /etc/nginx/new.conf$ # 容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件)nginx -c /etc/nginx/new.conf\n\n\nENV设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。\nENV &lt;key&gt; &lt;value&gt;ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...\n# 以下示例设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用：ENV NODE_VERSION 7.2.0RUN curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&quot; \\    &amp;&amp; curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot;\n\n\nARG构建参数，与 ENV 作用一至。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。\n构建命令 docker build 中可以用 –build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。\nARG &lt;参数名&gt;[=&lt;默认值&gt;]\n\n\nVOLUME定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。\n作用：\n\n避免重要的数据，因容器重启而丢失，这是非常致命的。\n避免容器不断变大。\n\nVOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]VOLUME &lt;路径&gt;\n在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。\n\n\nEXPOSE仅仅只是声明端口。\n作用：\n\n帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。\n在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。\n\nEXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]\n\n\nWORKDIR指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。\ndocker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。\nWORKDIR &lt;工作目录路径&gt;\n\n\nUSER用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。\nUSER &lt;用户名&gt;[:&lt;用户组&gt;]\n\n\nHEALTHCHECK用于指定某个程序或者指令来监控 docker 容器服务的运行状态。\nHEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令HEALTHCHECK [选项] CMD &lt;命令&gt; : 这边 CMD 后面跟随的命令使用，可以参考 CMD 的用法。\n\n\nONBUILD用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这是执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。\nONBUILD &lt;其它指令&gt;\n","categories":["Docker","基础"],"tags":["docker"]},{"title":"Docker笔记（06）——Docker 仓库管理","url":"https://lujw666.github.io/2021/02/23/docker-06/","content":"仓库（Repository）是集中存放镜像的地方。以下介绍一下 Docker Hub。当然不止 docker hub，只是远程的服务商不一样，操作都是一样的。\nDocker Hub目前 Docker 官方维护了一个公共仓库 Docker Hub。\n\n\n注册在 https://hub.docker.com 免费注册一个 Docker 账号。\n\n\n登录使用 docker login 命令登录需要输入用户名和密码，登录成功后，我们就可以从 docker hub 上拉取自己账号下的全部镜像。\n$ docker login\n\n\n退出使用 docker logout 命令退出 docker hub。\n$ docker logout\n\n\n拉取镜像通过 docker search 命令来查找官方仓库中的镜像，并利用 docker pull 命令来将它下载到本地。\n$ # 以 ubuntu 为关键词进行搜索$ docker search ubuntu$ # 使用 docker pull 将官方 ubuntu 镜像下载到本地$ docker pull ubuntu\n\n\n推送镜像用户登录后，可以通过 docker push 命令将自己的镜像推送到Docker Hub。\n$ #以下命令中的 username 请替换为你的 Docker 账号用户名。$ docker tag ubuntu:18.04 username/ubuntu:18.04$ docker image lsREPOSITORY      TAG        IMAGE ID            CREATED           ...  ubuntu          18.04      275d79972a86        6 days ago        ...  username/ubuntu 18.04      275d79972a86        6 days ago        ...  $ docker push username/ubuntu:18.04$ docker search username/ubuntuNAME             DESCRIPTION       STARS         OFFICIAL    AUTOMATEDusername/ubuntu","categories":["Docker","基础"],"tags":["docker"]},{"title":"Docker笔记（05）——Docker 容器操作","url":"https://lujw666.github.io/2021/02/23/docker-05/","content":"启动容器使用 docker run 命令使镜像启动一个容器。\n$ docker run -it ubuntu /bin/bashb750bbbcfd88 \n参数说明：\n\n-i: 交互式操作。\n-t: 终端。\nubuntu: ubuntu 镜像。\n/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。\n\ndocker run [OPTIONS] IMAGE [COMMAND] [ARG...]\nOPTIONS说明：\n\n-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；\n-d: 后台运行容器，并返回容器ID；\n-i: 以交互模式运行容器，通常与 -t 同时使用；\n-P: 随机端口映射，容器内部端口随机映射到主机的端口\n-p: 指定端口映射，格式为：主机(宿主)端口:容器端口\n-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；\n–name=”nginx-lb”: 为容器指定一个名称；\n–dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；\n–dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；\n-h “mars”: 指定容器的hostname；\n-e username=”ritchie”: 设置环境变量；\n–env-file=[]: 从指定文件读入环境变量；\n–cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行；\n-m :设置容器使用内存最大值；\n–net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；\n–link=[]: 添加链接到另一个容器；\n–expose=[]: 开放一个端口或一组端口；\n–volume , -v: 绑定一个卷\n\n\n\n网络端口映射容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射。\n\n-P :是容器内部端口随机映射到主机的高端口。\n-p : 是容器内部端口绑定到指定的主机端口\n\n$ docker run -d -p 5000:5000 training/webapp python app.py33e4523d30aaf0258915c368e66e03b49535de0ef20317d3f639d40222ba6bc0$ docker psCONTAINER ID        IMAGE               COMMAND           ...           PORTS                     NAMES33e4523d30aa        training/webapp     &quot;python app.py&quot;   ...   0.0.0.0:5000-&gt;5000/tcp    berserk_bartik\n可以指定容器绑定的网络地址。\n$ docker run -d -p 127.0.0.1:5001:5000 training/webapp python app.py95c6ceef88ca3e71eaf303c2833fd6701d8d1b2572b5613b5a932dfdfe8a857c$ docker psCONTAINER ID        IMAGE               COMMAND           ...     PORTS                                NAMES95c6ceef88ca        training/webapp     &quot;python app.py&quot;   ...  5000/tcp, 127.0.0.1:5001-&gt;5000/tcp   adoring_stonebraker\n默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 /udp。\n$ docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py6779686f06f6204579c1d655dd8b2b31e8e809b245a97b2d3a8e35abe9dcd22a$ docker psCONTAINER ID        IMAGE               COMMAND           ...   PORTS                                NAMES6779686f06f6        training/webapp     &quot;python app.py&quot;   ...   5000/tcp, 127.0.0.1:5000-&gt;5000/udp   drunk_visvesvaraya\n使用[docker port]命令可以让我们快捷地查看端口的绑定情况。\n$ docker port adoring_stonebraker 5000127.0.0.1:5001\n\n\n停止容器使用 docker stop 命令停止容器。\n$ docker stop &lt;容器 ID&gt;\n\n\n启动已停止运行的容器使用 docker start 或 restart 命令启动一个已停止的容器。\n$ docker start b750bbbcfd88 \n\n\n进入容器在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：\n\ndocker attach\ndocker exec：推荐使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。\n\n$ docker attach b750bbbcfd88$ docker exec -it b750bbbcfd88 /bin/bash\n\n\n导出和导入容器导出容器使用 docker export 命令导出本地容器。\n$ docker export b750bbbcfd88  &gt; ubuntu.tar\n\n\n导入容器快照使用 docker import 从容器快照文件中再导入为镜像。\n$ # 将快照文件 ubuntu.tar 导入到镜像 test/ubuntu:v1$ docker import ubuntu.tar test/ubuntu:v1$ # 通过指定 URL 或者某个目录来导入$ docker import http://example.com/exampleimage.tgz example/imagerepo\n\n\n删除容器使用 docker rm 命令删除容器。\n$ docker rm -f b750bbbcfd88\n\n\n清除容器使用 docker container prune 清理掉所有处于终止状态的容器。\n\n\n容器互联docker 有一个连接系统允许将多个容器连接在一起，共享连接信息。\ndocker 连接会创建一个父子关系，其中父容器可以看到子容器的信息。\n\n\n新建网络创建一个新的 Docker 网络。\n$ docker network create -d bridge test-net\n参数说明：\n\n-d：参数指定 Docker 网络类型，有 bridge、overlay。其中 overlay 网络类型用于 Swarm mode，在本小节中你可以忽略它。\n\n\n\n连接容器运行一个容器并连接到新建的 test-net 网络:\n$ docker run -itd --name test1 --network test-net ubuntu /bin/bash\n打开新的终端，再运行一个容器并加入到 test-net 网络:\n$ docker run -itd --name test2 --network test-net ubuntu /bin/bash\n可以通过 ping 来证明 test1 容器和 test2 容器建立了互联关系。\n如果你有多个容器之间需要互相连接，推荐使用 Docker Compose。\n","categories":["Docker","基础"],"tags":["docker"]},{"title":"Docker笔记（04）——Docker 镜像使用","url":"https://lujw666.github.io/2021/02/22/docker-04/","content":"列出镜像列表使用 docker images 来列出本地主机上的镜像。\n$ docker images          REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              14.04               90d5884b1ee0        5 days ago          188 MBphp                 5.6                 f40e9e0f10c8        9 days ago          444.8 MBnginx               latest              6f8d099c3adc        12 days ago         182.7 MBmysql               5.6                 f2e8d6c772c0        3 weeks ago         324.6 MBhttpd               latest              02ef73cf1bc0        3 weeks ago         194.4 MBubuntu              15.10               4e3b13c8a266        4 weeks ago         136.3 MBhello-world         latest              690ed74de00f        6 months ago        960 Btraining/webapp     latest              6fae60ef3446        11 months ago       348.8 MB\n各个选项说明:\n\nREPOSITORY：表示镜像的仓库源\nTAG：镜像的标签\nIMAGE ID：镜像ID\nCREATED：镜像创建时间\nSIZE：镜像大小\n\n同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，使用 REPOSITORY:TAG 来定义不同的镜像。\ndocker images [OPTIONS] [REPOSITORY[:TAG]]\nOPTIONS说明：\n\n-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；\n–digests :显示镜像的摘要信息；\n-f :显示满足条件的镜像；\n–format :指定返回值的模板文件；\n–no-trunc :显示完整的镜像信息；\n-q :只显示镜像ID。\n\n\n\n获取一个新的镜像使用 docker pull 命令下载镜像。当在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。\n$ docker pull ubuntu:13.1013.10: Pulling from library/ubuntu6599cadaf950: Pull complete 23eda618d451: Pull complete f0be3084efe9: Pull complete 52de432f084b: Pull complete a3ed95caeb02: Pull complete Digest: sha256:15b79a6654811c8d992ebacdfbd5152fcf3d165e374e264076aa435214a947a3Status: Downloaded newer image for ubuntu:13.10\ndocker pull [OPTIONS] NAME[:TAG|@DIGEST]\nOPTIONS说明：\n\n-a :拉取所有 tagged 镜像\n–disable-content-trust :忽略镜像的校验,默认开启\n\n\n\n查找镜像使用 docker search 命令来搜索镜像。\n比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。\n$  docker search httpdNAME                                    DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDhttpd                                   The Apache HTTP Server Project                  3339      [OK]centos/httpd-24-centos7                 Platform for running Apache httpd 2.4 or bui…   36centos/httpd                                                                            33                   [OK]arm32v7/httpd                           The Apache HTTP Server Project                  9polinux/httpd-php                       Apache with PHP in Docker (Supervisor, CentO…   4                    [OK]salim1983hoop/httpd24                   Dockerfile running apache config                2                    [OK]clearlinux/httpd                        httpd HyperText Transfer Protocol (HTTP) ser…   1\n各个选项说明:\n\nNAME: 镜像仓库源的名称\nDESCRIPTION: 镜像的描述\nOFFICIAL: 是否 docker 官方发布\nstars: 类似 Github 里面的 star，表示点赞、喜欢的意思。\nAUTOMATED: 自动构建。\n\ndocker search [OPTIONS] TERM\nOPTIONS说明：\n\n–automated :只列出 automated build类型的镜像；\n–no-trunc :显示完整的镜像描述；\n-f &lt;过滤条件&gt;:列出收藏数不小于指定值的镜像。\n\n\n\n删除镜像镜像删除使用 docker rmi 命令，比如删除 hello-world 镜像：\n$ docker rmi hello-world\ndocker rmi [OPTIONS] IMAGE [IMAGE...]\nOPTIONS说明：\n\n-f :强制删除；\n–no-prune :不移除该镜像的过程镜像，默认移除；\n\n\n\n创建镜像当从 docker 镜像仓库中下载的镜像不能满足我们的需求时，可以通过以下两种方式对镜像进行更改。\n\n从已经创建的容器中更新镜像，并且提交这个镜像\n使用 Dockerfile 指令来创建一个新的镜像\n\n\n\n更新镜像更新镜像之前，需要使用镜像来创建一个容器。\n在运行的容器内使用进行操作更新。在完成操作之后，输入 exit 命令来退出这个容器。\n此时 ID 为 e218edb10161 的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit 来提交容器副本。\n$ docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2sha256:70bf1840fd7c0d2d8ef0a42a817eb29f854c1af8f7c59fc03ac7bdee9545aff8\n各个参数说明：\n\n-m: 提交的描述信息\n-a: 指定镜像作者\ne218edb10161：容器 ID\nrunoob/ubuntu:v2: 指定要创建的目标镜像\n\n从容器创建一个新的镜像。\ndocker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]\nOPTIONS说明：\n\n-a :提交的镜像作者；\n-c :使用Dockerfile指令来创建镜像；\n-m :提交时的说明文字；\n-p :在commit时，将容器暂停。\n\n\n\n构建镜像使用命令 docker build， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。\n$ cat Dockerfile FROM    centos:6.7MAINTAINER      Fisher &quot;fisher@sudops.com&quot;RUN     /bin/echo &#x27;root:123456&#x27; |chpasswdRUN     useradd runoobRUN     /bin/echo &#x27;runoob:123456&#x27; |chpasswdRUN     /bin/echo -e &quot;LANG=\\&quot;en_US.UTF-8\\&quot;&quot; &gt;/etc/default/localEXPOSE  22EXPOSE  80CMD     /usr/sbin/sshd -D\n每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。第一条FROM，指定使用哪个镜像源。RUN 指令告诉docker 在镜像内执行命令，安装了什么。然后，我们使用 Dockerfile 文件，通过 docker build 命令来构建一个镜像。\n$ docker build -t runoob/centos:6.7 .Sending build context to Docker daemon 17.92 kBStep 1 : FROM centos:6.7 ---&amp;gt; d95b5ca17cc3Step 2 : MAINTAINER Fisher &quot;fisher@sudops.com&quot; ---&amp;gt; Using cache ---&amp;gt; 0c92299c6f03Step 3 : RUN /bin/echo &#x27;root:123456&#x27; |chpasswd ---&amp;gt; Using cache ---&amp;gt; 0397ce2fbd0aStep 4 : RUN useradd runoob......\n参数说明：\n\n-t ：指定要创建的目标镜像名\n. ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径\n\ndocker build [OPTIONS] PATH | URL | -\nOPTIONS说明：\n\n–build-arg=[] :设置镜像创建时的变量；\n–cpu-shares :设置 cpu 使用权重；\n–cpu-period :限制 CPU CFS周期；\n–cpu-quota :限制 CPU CFS配额；\n–cpuset-cpus :指定使用的CPU id；\n–cpuset-mems :指定使用的内存 id；\n–disable-content-trust :忽略校验，默认开启；\n-f :指定要使用的Dockerfile路径；\n–force-rm :设置镜像过程中删除中间容器；\n–isolation :使用容器隔离技术；\n–label=[] :设置镜像使用的元数据；\n-m :设置内存最大值；\n–memory-swap :设置Swap的最大值为内存+swap，”-1”表示不限swap；\n–no-cache :创建镜像的过程不使用缓存；\n–pull :尝试去更新镜像的新版本；\n–quiet, -q :安静模式，成功后只输出镜像 ID；\n–rm :设置镜像成功后删除中间容器；\n–shm-size :设置/dev/shm的大小，默认值是64M；\n–ulimit :Ulimit配置。\n–squash :将 Dockerfile 中所有的操作压缩为一层。\n–tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。\n–network: 默认 default。在构建期间设置RUN指令的网络模式\n\n\n\n设置镜像标签使用 docker tag 命令，为镜像添加一个新的标签。\n$ docker tag 860c279d2fec runoob/centos:dev\ndocker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]\ndocker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]\n","categories":["Docker","基础"],"tags":["docker"]},{"title":"Docker笔记（03）——Docker 架构","url":"https://lujw666.github.io/2021/02/22/docker-03/","content":"Docker 包括三个基本概念:\n\n镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。\n容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。\n仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。\n\n\n\n\n\n概念\n说明\n\n\n\nDocker 镜像(Images)\nDocker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。\n\n\nDocker 容器(Container)\n容器是独立运行的一个或一组应用，是镜像运行时的实体。\n\n\nDocker 客户端(Client)\nDocker 客户端通过命令行或者其他工具使用 Docker SDK https://docs.docker.com/develop/sdk/ 与 Docker 的守护进程通信。\n\n\nDocker 主机(Host)\n一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。\n\n\nDocker Registry\nDocker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub https://hub.docker.com 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。\n\n\nDocker Machine\nDocker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。\n\n\n","categories":["Docker","基础"],"tags":["docker"]},{"title":"Docker笔记（02）——Docker 安装","url":"https://lujw666.github.io/2021/02/22/docker-02/","content":"Linux 平台上安装Debian/UbuntuDebian/Ubuntu Docker 安装命令为：\n# 获取最新版本的 Docker 安装包apt-get updateapt-get install -y docker.io# 启动docker 后台服务service docker start\n\n\nCentos/RedHat如果你使用的系统是 Centos/RedHat 安装命令为：\nyum -y install dockerservice docker start\n\n\nWindows 平台上安装Docker Desktop 是 Docker 在 Windows 10 和 macOS 操作系统上的官方安装方式，这个方法依然属于先在虚拟机中安装 Linux 然后再安装 Docker 的方法。\nDocker Desktop 官方下载地址：https://hub.docker.com/editions/community/docker-ce-desktop-windows\n通过命令来启用 Hyper-V ，请右键开始菜单并以管理员身份运行 PowerShell，执行以下命令：\nEnable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All\n运行安装文件完成之后，Docker 会自动启动。通知栏上会出现个小鲸鱼的图标，这表示 Docker 正在运行。\n\n\nMac 平台上安装macOS 我们可以使用 Homebrew 来安装 Docker。\nHomebrew 的 Cask 已经支持 Docker for Mac。\n$ brew install --cask --appdir&#x3D;&#x2F;Applications docker&#x3D;&#x3D;&gt; Creating Caskroom at &#x2F;usr&#x2F;local&#x2F;Caskroom&#x3D;&#x3D;&gt; We&#39;ll set permissions properly so we won&#39;t need sudo in the futurePassword:          # 输入 macOS 密码&#x3D;&#x3D;&gt; Satisfying dependencies&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;download.docker.com&#x2F;mac&#x2F;stable&#x2F;21090&#x2F;Docker.dmg######################################################################## 100.0%&#x3D;&#x3D;&gt; Verifying checksum for Cask docker&#x3D;&#x3D;&gt; Installing Cask docker&#x3D;&#x3D;&gt; Moving App &#39;Docker.app&#39; to &#39;&#x2F;Applications&#x2F;Docker.app&#39;.&amp;#x1f37a;  docker was successfully installed!","categories":["Docker","基础"],"tags":["docker","安装"]},{"title":"Docker笔记（01）——什么是 Docker","url":"https://lujw666.github.io/2021/02/22/docker-01/","content":"Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。\nDocker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。\n容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。\n\n\nDocker和传统虚拟化方式\n\n\n特性\n容器\n虚拟机\n\n\n\n启动\n秒级\n分钟级\n\n\n硬盘使用\n一般为 MB\n一般为 GB\n\n\n性能\n接近原生\n弱于\n\n\n系统支持量\n单机支持上千个容器\n一般几十个\n\n\n\n\n\n\nDocker的优点Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。\n\n快速，一致地交付您的应用程序Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。容器非常适合持续集成和持续交付（CI / CD）工作流程，请考虑以下示例方案：\n您的开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。\n他们使用 Docker 将其应用程序推送到测试环境中，并执行自动或手动测试。\n当开发人员发现错误时，他们可以在开发环境中对其进行修复，然后将其重新部署到测试环境中，以进行测试和验证。\n测试完成后，将修补程序推送给生产环境，就像将更新的镜像推送到生产环境一样简单。\n\n\n响应式部署和扩展Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。Docker 的可移植性和轻量级的特性，还可以使您轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。\n在同一硬件上运行更多工作负载Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。Docker 非常适合于高密度环境以及中小型部署，而您可以用更少的资源做更多的事情。\n\n","categories":["Docker","基础"],"tags":["简介","docker"]},{"title":"Gitbook笔记（4）——配置","url":"https://lujw666.github.io/2021/02/18/gitbook-04/","content":"GitBook的项目结构如下：\n\n多语言的GitBook项目结构示例如下：\n\n\n\n配置项目结构book.json是全局配置文件，可以自定义项目的根目录、自述文件、摘要、词汇表、多语言等文件的文件名。\n在book.json中可配置的变量如下:\n\n\n\n变量\n描述\n\n\n\nroot\n配置书籍的根目录，默认时当前目录\n\n\nstructure\n配置自述文件、摘要、词汇表的文件名\n\n\ntitle\n配置书名、如果不配置，则默认从自述文件README文件第一段提取\n\n\ndescription\n配置书籍的描述，如果不配置则默认从自述文件中提取\n\n\nauthor\n配置作者姓名\n\n\nisbn\n配置本书的国际码 ISBN\n\n\nlanguage\n配置本书语言的ISO代码，默认值为en\n\n\ndirection\n配置本书的方向。可以是rtl或ltr,默认值取决于language的值\n\n\ngitbook\n指定GitBook版本，使用SemVer规范，几首”&gt;=3.0.0”这样的格式\n\n\n\n\n\n自定义根目录和文件名在GitBook项目中，默认所有文件都是从根目录开始查找的，如果想自定义根目录，需要在book.json中通过root指定根目录。例如，将docs指定为项目的根目录，如下所示:\n\n除root变量之外，还可以自定义GitBook的自述文件、摘要、词汇表和语言文件的名称，这些文件必须在书籍的根目录（或每种语言图书的根目录）下。自述文件、摘要、词汇表和语言文件的默认设置见下表。\n\n\n\n变量\n描述\n\n\n\nstructure.readme\n自述文件名（默认为README.md）\n\n\nstructure.summary\n摘要文件名（默认为SUMMARY.md）\n\n\nstructure.glossary\n词汇表文件名（默认为GLOSSARY）\n\n\nstructure.languages\n语言文件名（默认为LANGS.md）\n\n\n\n\n配置链接如果搭建的是内部文档，右上角的分享链接就没必要出现了，那该怎么关闭呢?\n关闭分享链接的示例代码如下：\n\n如果要在导航栏配置一些链接，其示例代码如下:\n\n\n\n配置插件在book.json中配置插件，与之相关的变量见下表:\n\n\n\n变量\n描述\n\n\n\nplugins\n配置插件列表\n\n\npluginsConfig\n配置插件属性\n\n\n配置插件的示例代码如下：\n\n\n\n插件的安装步骤\n找到插件:由于GitBook将重心放在了网站上，原来的插件页面已不存在，我们只能通过搜索引擎或一些推荐找到想要的插件。\n配置插件:在book.json中通过plugins和pluginsConfig字段配置插件名和插件属性。例如，可以配置插件名为“anotherPlugin”。\n如果想指定特定的插件版本，则可以将插件名配置为“&#x6d;&#121;&#x50;&#108;&#x75;&#x67;&#105;&#x6e;&#x40;&#50;&#46;&#49;&#x2e;&#49;”的样子；如果不指定版本，GitBook默认会使用最新的。\n\n\n安装插件:在项目根目录执行gitbook install来安装插件，仅供当前项目使用。\n禁用自带插件(在自带插件名前面加上-)。GitBook默认自带5个插件:\nhighlight：代码高亮\nsearch：搜索\nsharing：分享\nfont-settings：字体设置\nlivereload：实时加载\n\n\n\n\n\n功能插件\ngitbook-plugin-atoc是一款自动生成文章导航目录的插件\npage-treeview为每一个页面自动生成目录树\nanchor-navigation-ex为每篇文章自动生成目录\ntbfed-pagefooter用来定制每篇文章的页脚，可以添加版权信息和显示文件修改时间\nsearch-pro支持中文搜索\nimage-captions插件自动生成并显示图片标题\ngithub-button插件可以显示GitHub的Star和Fork的数量\nsplitter插件通过拖拽的方式自由调节侧边栏宽度\ndonate插件支持定义和显示支付宝和微信打赏\n\n相关链接:http://gitbook.zhangjikai.com/plugins.html\n\n\n自定义PDF文档的输出格式在book.json中定制输出PDF格式的文档，与之相关的变量见下表：\n\n\n\n变量\n描述\n\n\n\npdf.pageNumbers\n将页码添加到每个页面的底部\n\n\npdf.fontSize\n基本字体大小（默认为12）\n\n\npdf.fontFamily\n基本字体系列（默认为Arial）\n\n\npdf.paperSize\n纸张尺寸（默认为 a4）\n\n\npdf.margin.top\n上边距（默认是 56）\n\n\npdf.margin.botton\n下边距（默认是 56）\n\n\npdf.margin.right\n右边距（默认是 62）\n\n\npdf.margin.left\n左边距（默认是 62）\n\n\n\n\n配置全局变量GitBook的变量分为预定义变量和自定义变量，变量在GitBook构建时会被替换。自定义变量又分为全局变量和局部变量，全局变量在book.json中定义，局部变量在文件中定义。\nbook.json中自定义全局变量的格式如下：\n\n可以像下面这样引用全局变量：\n\n\n\n配置目录\n\n配置多语言GitBook支持用多种语言编写书籍，如果配置了多语言，在打开站点的首页后会看到一个选择语言的页面。\n目录结构按语言分类，每种语言都有一个独立的子目录，在目录中遵循单语言的配置规则，示例如下:\n\n在根目录中有一个book.json文件作为主配置，在每种语言的子目录中也可以有一个book.json来定义自己的配置，它们将作为主配置的扩展存在。\n\n\n配置词汇表在GLOSSARY.md中可以指定词汇及词汇的定义，GitBook会自动构建索引并在文中突出显示这些词汇。GLOSSARY.md的格式如下所示:\n\n注意：词汇不能是中文。\n配置后，在其他页面使用这两个词汇时，它们会被突出显示，如果把鼠标放到上面，则会显示词汇的定义。\n\n\n配置要忽略的文件GitBook是通过Git进行管理的，一般IDE自动产生的文件和编译时产生的文件都是没有必要纳入到版本控制的，因此需要忽略这些文件。\nGitBook会通过读取.gitignore（推荐）、.bookignore和.ignore中的配置来获取要忽略的文件。\n","categories":["Markdown","扩展"],"tags":["markdown","gitbook"]},{"title":"Gitbook笔记（3）——GitHub托管","url":"https://lujw666.github.io/2021/02/18/gitbook-03/","content":"GitBook.com 为每本书籍都创建了一个 Git 项目，并且使用这个 Git 项目来管理书籍源码。\n\n\n连接你的账号/权限在集成你的书本和GitHub前，你需要授予GitBook访问你的GitHub账号的权限。\n在你的 账号设置 里，使用正确的权限连接你的GitHub账号：\n\n默认的权限：仅仅在登陆的时候访问你的GitHub账号来验证你\n访问webhook：访问你的GitHub账号来在指定的仓库中创建webhook（查看webhooks）\n访问公开的仓库：从网页编辑器中访问你的GitHub仓库，你可以很容易的在GitBook中编辑你的书本（仅仅公共仓库）\n访问私有的仓库：和上面一项目一样，但是只能访问私有仓库\n\n\n\n从GitHub导入书创建一本新书的时候，GitHub 标签页让你选择一个 GitHub 仓库导入。\n新创建的书会使用你仓库的内容，webhook 也会自动添加。\n\n\nWebhooks当你的GitHub的仓库改变时，Webhooks会通知GitBook。\n如果你的GitHub仓库改变时，GitBook没有收到通知，这个问题的主要原因是webhook。你可以检查仓库设置中webhook的状态。\n","categories":["Markdown","扩展"],"tags":["markdown","gitbook"]},{"title":"Gitbook笔记（2）——使用","url":"https://lujw666.github.io/2021/02/18/gitbook-02/","content":"创建如下目录结构：\n$ tree book/book/├── README.md└── SUMMARY.md\nREADME.md 和 SUMMARY.md 是两个必须文件。\n\n\nREADME.mdREADME.md是对书籍的简单介绍。\n$ cat book/README.md # READMEThis is a book powered by [GitBook](https://github.com/GitbookIO/gitbook).\n\n\nSUMMARY.mdSUMMARY.md 是书籍的目录结构。\nSUMMARY.md文件中定义书籍的目录结构，格式为链接列表，链接的标题将被作为章节的标题，链接所指向的目标是该章节所对应的文件的路径；如果向父章节添加嵌套列表，则会创建子章节。\n$ cat book/SUMMARY.md # SUMMARY* [Chapter1](chapter1/README.md)  * [Section1.1](chapter1/section1.1.md)  * [Section1.2](chapter1/section1.2.md)* [Chapter2](chapter2/README.md)\n章节可以使用标题或水平线进行分隔,如下：\n$ cat book/SUMMARY.md # SUMMARY## 第一部分* [Chapter1](chapter1/README.md)  * [Section1.1](chapter1/section1.1.md)  * [Section1.2](chapter1/section1.2.md)## 第二部分* [Chapter2](chapter2/README.md)---* [Chapter3](chapter3/README.md)\n如果想要显示目录中章节的层级序号，需要在 book.json 中开启 showLevel 。\n","categories":["Markdown","扩展"],"tags":["markdown","gitbook"]},{"title":"Gitbook笔记（1）——简介及安装","url":"https://lujw666.github.io/2021/02/18/gitbook-01/","content":"GitBook 是一个基于 Node.js 的命令行工具，可使用Github/Git和 Markdown来制作精美的电子书。\nGitBook可以把你的书本生成为许多格式：PDF，ePub，mobi，或者成为一个网站。\n\n\n官方网站GitBook.com 是一个使用工具链来创建和托管书籍的在线平台 &lt;www.gitbook.com&gt;。\n\n\n其他文档开发文档 (API &amp; 插件) 地址：&lt;developer.gitbook.com&gt;\n企业版本的安装向导和手册的地址：&lt;help.enterprise.gitbook.com&gt;\n\n\n帮助和支持通过 &lt;gitbook.com/contact&gt; 来提问题或者报告一个错误\n\n\n系统要求系统需要满足以下两个要求：\n\nNodeJS (v4.0.0及以上)\nWindows, Linux, Unix, or Mac OS X\n\n\n\n使用npm安装安装GitBook的最佳方式是通过npm。在终端提示符下，只需运行以下命令即可安装GitBook：\nnpm install gitbook-cli -g\ngitbook-cli是在同一系统上安装和使用多个版本的GitBook的实用程序。它会自动安装所需的 GitBook 版本来构建书籍。\n","categories":["Markdown","扩展"],"tags":["markdown","gitbook"]},{"title":"Markdown笔记（10）——其他","url":"https://lujw666.github.io/2021/02/18/markdown-10/","content":"HTML不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。\nHTML知识点请参考https://www.runoob.com/html/html-tutorial.html\n\n\n公式在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。\n\n\n\n转义Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\\   反斜线`   反引号*   星号_   下划线&#123;&#125;  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号\n\n\n表情符号使用：包裹表情代码即可，语法如下。\n实例演示如下:\n\n:blush::blush:\n\n更多的表情符号请参考http://www.webpagefx.com/tools/emoji-cheat-sheet/\n","categories":["Markdown","进阶"],"tags":["markdown"]},{"title":"Markdown笔记（9）——排版优化","url":"https://lujw666.github.io/2021/02/18/markdown-09/","content":"关于空格建议中文和英文之间加空格，中文/英文和数字之间也要加空格，不过有些编辑器和输入法会自动添加空隙，就没必要手动添加了。\n\n需要加空格的情况\n英文标点符号（如，.；：？）与后面的字符之间需要加空格，与前面的字符之间不需要加空格。\n当在中文、英文中使用＞（半角）标识路径时，两边都需要加空格。\n\n\n不加空格的情况\n中文标点符号和数字、中文、英文之间不需要添加空格。\n数字和百分号之间不需要添加空格。\n数字和单位符号之间不需要添加空格。\n英文和数字组合成的名字之间不需要添加空格。\n当/（半角）表示“或”、“路径”时，与前后的字符之间均不加空格。\n货币符号后不加空格。\n负号后不加空格。\n\n\n\n\n\n全角和半角对于很多人来说，全角符号和半角符号可能是最熟悉的陌生人，虽然它们随处可见，但大部分人都没用对。\n全角：中文标点符号是全角，占两个字节。\n半角：英文标点符号和数字是半角，占1个字节。\n全角：，。；：!#\n半角：,.;:!#\n\n在中文排版中，要使用全角标点符号。\n在英文排版中，要使用半角标点符号。\n\n\n\n正确的英文大小写很多人在文章、邮件甚至简历中，会把专有名词写错，虽然这并不会影响人们对内容的理解，但有时的确会让人觉得你不太“专业”。\n专有名词要使用正确的大小写，请参考它们的官方文档。\n","categories":["Markdown","进阶"],"tags":["markdown"]},{"title":"Markdown笔记（8）——表格","url":"https://lujw666.github.io/2021/02/18/markdown-08/","content":"Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。\n语法格式如下：\n|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |\n以上代码显示结果如下：\n\n\n\n表头\n表头\n\n\n\n单元格\n单元格\n\n\n单元格\n单元格\n\n\n\n\n对齐方式\n-: 设置内容和标题栏居右对齐。\n:- 设置内容和标题栏居左对齐。\n:-: 设置内容和标题栏居中对齐。\n\n实例：\n| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |\n以上代码显示结果如下：\n\n\n\n左对齐\n右对齐\n居中对齐\n\n\n\n单元格\n单元格\n单元格\n\n\n单元格\n单元格\n单元格\n\n\n","categories":["Markdown","基础"],"tags":["markdown"]},{"title":"Markdown笔记（7）——图片","url":"https://lujw666.github.io/2021/02/18/markdown-07/","content":"Markdown 图片语法格式如下：\n![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)\n\n开头一个感叹号 !\n接着一个方括号，里面放上图片的替代文字\n接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。\n\nMarkdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。\n&lt;img src=&quot;http://static.runoob.com/images/runoob-logo.png&quot; width=&quot;50%&quot;&gt;\n","categories":["Markdown","基础"],"tags":["markdown"]},{"title":"Markdown笔记（6）——链接","url":"https://lujw666.github.io/2021/02/18/markdown-06/","content":"链接使用方法如下：\n[链接名称](链接地址)或者&lt;链接地址&gt;\n例如：\n这是一个链接 [learn](https://lujw666.gitbook.io/learn/)\n显示结果如下：\n这是一个链接 learn\n直接使用链接地址：\n&lt;https://lujw666.gitbook.io/learn/&gt;\n显示结果如下：\nhttps://lujw666.gitbook.io/learn/\n\n\n高级链接可以通过变量来设置一个链接，变量赋值在文档末尾进行：\n这个链接用 1 作为网址变量 [Google][1]这个链接用 learn 作为网址变量 [learn][learn]然后在文档的结尾为变量赋值（网址）[1]: http://www.google.com/[learn]: https://lujw666.gitbook.io/learn/\n显示结果如下：\n这个链接用 1 作为网址变量 Google\n这个链接用 learn 作为网址变量 learn\n然后在文档的结尾为变量赋值（网址）\n","categories":["Markdown","基础"],"tags":["markdown"]},{"title":"Markdown笔记（5）——代码","url":"https://lujw666.github.io/2021/02/18/markdown-05/","content":"如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：\n`printf()` 函数\n显示结果如下：\nprintf() 函数\n\n\n代码区块代码区块使用 4 个空格或者一个制表符（Tab 键）。\n&lt;?phpecho &#x27;learn&#x27;;function test() &#123;    echo &#x27;test&#x27;&#125;\n显示结果如下：\n&lt;?php\necho &#39;learn&#39;;\nfunction test() &#123;\n    echo &#39;test&#39;\n&#125;\n\n也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：\n$(document).ready(function () &#123;    alert(&#x27;learn&#x27;);&#125;);\n\n显示结果如下：\n$(document).ready(function () &#123;    alert(&#x27;learn&#x27;);&#125;);\n","categories":["Markdown","基础"],"tags":["markdown"]},{"title":"Markdown笔记（4）——区块","url":"https://lujw666.github.io/2021/02/18/markdown-04/","content":"区块Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：\n&gt; 区块引用&gt; 学的不仅是技术更是梦想\n\n区块引用学的不仅是技术更是梦想\n\n另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：\n&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套\n显示结果如下：\n\n最外层\n\n第一层嵌套\n\n第二层嵌套\n\n\n\n\n\n区块中使用列表区块中使用列表实例如下：\n&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项&gt; + 第三项\n显示结果如下：\n\n区块中使用列表\n\n第一项\n第二项\n\n\n第一项\n第二项\n第三项\n\n\n列表中使用区块如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。\n列表中使用区块实例如下：\n* 第一项    &gt; 学的不仅是技术更是梦想* 第二项\n显示结果如下：\n\n第一项\n\n学的不仅是技术更是梦想\n\n\n第二项\n\n\n","categories":["Markdown","基础"],"tags":["markdown"]},{"title":"Markdown笔记（3）——列表","url":"https://lujw666.github.io/2021/02/17/markdown-03/","content":"Markdown 支持有序列表和无序列表。\n\n\n无序列表无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：\n* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项\n显示结果如下：\n\n第一项\n第二项\n第三项\n\n\n第一项\n第二项\n第三项\n\n\n第一项\n第二项\n第三项\n\n\n\n有序列表有序列表使用数字并加上 . 号来表示，如：\n1. 第一项2. 第二项3. 第三项\n显示结果如下：\n\n第一项\n第二项\n第三项\n\n\n\n列表嵌套列表嵌套只需在子列表中的选项前面添加四个空格即可：\n1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素\n显示结果如下：\n\n第一项：\n第一项嵌套的第一个元素\n第一项嵌套的第二个元素\n\n\n第二项：\n第二项嵌套的第一个元素\n第二项嵌套的第二个元素\n\n\n\n","categories":["Markdown","基础"],"tags":["markdown"]},{"title":"Markdown笔记（2）——段落格式","url":"https://lujw666.github.io/2021/02/17/markdown-02/","content":"段落Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。\ntext  末尾添加两个空格text或text使用空行来换行text\n显示效果如下所示：\ntexttext\n\n\n字体Markdown 可以使用以下几种字体：\n*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___\n显示效果如下所示：\n斜体文本斜体文本粗体文本粗体文本粗斜体文本粗斜体文本\n\n\n分隔线在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n**** * ******- - -----------\n显示效果如下所示：\n\n\n\n\n\n\n\n删除线如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：\nBAIDU.COM~~BAIDU.COM~~\n显示效果如下所示：\nBAIDU.COMBAIDU.COM\n\n\n下划线下划线可以通过 HTML 的  标签来实现：\n&lt;u&gt;带下划线文本&lt;/u&gt;\n显示效果如下所示：\n带下划线文本\n\n\n脚注脚注是对文本的补充说明。\nMarkdown 脚注的格式如下:\n创建脚注格式类似这样 [^要注明的文本]。[^要注明的文本]: 学的不仅是技术，更是梦想！！！\n显示效果如下所示：\n创建脚注格式类似这样 ^要注明的文本。\n","categories":["Markdown","基础"],"tags":["markdown"]},{"title":"学习前言","url":"https://lujw666.github.io/2021/02/17/learntask/","content":"学习python、R、docker and sql的总结。希望大家协同打造一个编程学习笔记。\n\n\n学习内容存放位置Github:https://github.com/lujw666/learn.git\nGitbook:https://lujw666.gitbook.io/learn/\nBlog:https://lujw666.github.io/\nDockerhub:https://hub.docker.com/repository/docker/lujiawei/learn\n","categories":[],"tags":["其他"]},{"title":"Markdown笔记（1）——标题","url":"https://lujw666.github.io/2021/02/17/markdown-01/","content":"Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\nMarkdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。\nMarkdown 编写的文档后缀为 .md, .markdown。\n\n\nMarkdown 标题Markdown 标题有两种格式。\n使用 = 和 - 标记一级和二级标题= 和 - 标记语法格式如下：\n我展示的是一级标题=================我展示的是二级标题-----------------\n显示效果如下图：\n\n\n\n使用 # 号标记使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。\n# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题\n显示效果如下图：\n\n","categories":["Markdown","基础"],"tags":["markdown","简介"]},{"title":"Hexo-快速搭建博客框架","url":"https://lujw666.github.io/2021/02/17/hexo/","content":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n\n\n相关链接Hexo 中文官网:https://hexo.io/zh-cn/docs/theme-kaze 模板:https://demo.theme-kaze.top/\n\n\n建站步骤\n安装hexonpm install -g hexo-cli &amp;&amp; npm install hexo-deployer-git --save\n创建项目hexo init myblog\n切换到项目并安装依赖cd myblog &amp;&amp; npm install\n新建文章hexo new test\n编辑文章vim source/_posts/test.md\n在Github上新建一个 repository。如果站点通过 &lt;你的 GitHub 用户名&gt;.github.io 域名访问，你的 repository 应该直接命名为 /&lt;你的 GitHub 用户名&gt;.github.io。\n编辑configvim _config.yml,如下\n本地预览hexo g &amp;&amp; hexo s\n推送Githubhexo d\n\ndeploy:    type: git    repo: https://github.com/&lt;username&gt;/&lt;project&gt;    branch: master\n\n\nProject page如果你更希望你的站点部署在 &lt;你的 GitHub 用户名&gt;.github.io 的子目录中，你的 repository 需要直接命名为子目录的名字，这样你的站点可以通过 https://&lt;你的 GitHub 用户名&gt;.github.io/&lt;repository 的名字&gt; 访问。\n需要检查的 Hexo 配置文件，将 url 修改为 https://&lt;你的 GitHub 用户名&gt;.github.io/&lt;repository 的名字&gt;、将 root 的值修改为 /&lt;repository 的名字&gt;/。\n\n\nhexo new 创建新文章hexo new [layout] &lt;title&gt;\n\n\nLayoutHexo 有三种默认布局：post、page 和 draft。在创建这三种不同类型的文件时，它们将会被保存到不同的路径。\n\n\n\n布局\n路径\n\n\n\npost\nsource/_posts\n\n\npage\nsource\n\n\ndraft\nsource/_drafts\n\n\n\n\n文件名称Hexo 默认以标题做为文件名称，但您可编辑 new_post_name 参数来改变默认的文件名称，举例来说，设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章。\n\n\n\n变量\n描述\n\n\n\n:title\n标题（小写，空格将会被替换为短杠）\n\n\n:year\n建立的年份，比如， 2015\n\n\n:month\n建立的月份（有前导零），比如， 04\n\n\n:i_month\n建立的月份（无前导零），比如， 4\n\n\n:day\n建立的日期（有前导零），比如， 07\n\n\n:i_day\n建立的日期（无前导零），比如， 7\n\n\n\n\n草稿Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 source/_drafts 文件夹，可通过 publish 命令将草稿移动到 source/_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局。\nhexo publish [layout] &lt;title&gt;\n草稿默认不会显示在页面中，您可在执行时加上 --draft 参数，或是把 render_drafts 参数设为 true 来预览草稿。\n\n\n模版（Scaffold）在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如：\nhexo new photo &quot;My Gallery&quot;\n在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章。\n\n\nFront-matter文章md文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说：\n---title: Hello Worlddate: 2013/7/13 20:46:25---\n以下是预先定义的参数，可在模板中使用这些参数值并加以利用。\n\n\n\n参数\n描述\n默认值\n\n\n\nlayout\n布局\nconfig.default_layout\n\n\ntitle\n标题\n文章的文件名\n\n\ndate\n建立日期\n文件建立日期\n\n\nupdated\n更新日期\n文件更新日期\n\n\ncomments\n开启文章的评论功能\ntrue\n\n\ntags\n标签（不适用于分页）\n\n\n\ncategories\n分类（不适用于分页）\n\n\n\n\n\n资源文件夹资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。\n\n\n文章资源文件夹对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。可以通过将 config.yml 文件中的 post_asset_folder 选项设为 true 来打开。\n当资源文件管理功能打开后，Hexo将会在你每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。\n\n\n相对路径引用的标签插件通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。\n&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125;\n比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ![](example.jpg) ，它将不会出现在首页上。（但是它会在文章中按你期待的方式工作）\n正确的引用图片方式是使用下列的标签插件而不是 markdown ：\n&#123;% asset_img example.jpg This is an example image %&#125;\n通过这种方式，图片将会同时出现在文章和主页以及归档页中。\n\n\n使用标记嵌入图像hexo3.1.0引入了一个新选项，允许您在markdown中嵌入图像，而无需使用asset_img 标记插件。\n_config.ymlpost_asset_folder: truemarked:  prependRoot: true  postAsset: true\n启用后，资源映像将自动解析为其相应的post路径。例如 image.jpg 文件位于 source/_post/2020-01-02-foo ，这意味可以通过 /2020/01/02/foo/image.jpg调用。\n","categories":["Markdown","扩展","Git","扩展"],"tags":["markdown","hexo","blog","git","github"]},{"title":"Hello World","url":"https://lujw666.github.io/2021/02/17/hello-world/","content":"大家好！今天是我的诞生日。\nHello World！！！！！\n","categories":[],"tags":["其他"]}]